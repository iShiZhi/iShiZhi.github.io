<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="一个非主流程序员">
<meta property="og:type" content="website">
<meta property="og:title" content="柿子的果盘">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="柿子的果盘">
<meta property="og:description" content="一个非主流程序员">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="柿子的果盘">
<meta name="twitter:description" content="一个非主流程序员">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/"/>





  <title>柿子的果盘</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?30798a6e72702e12c529efb9326dc7e1";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>










</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">柿子的果盘</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">随手记录一些所读、所思、所感</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/11/03/redis_zip_list/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="柿子">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柿子的果盘">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/11/03/redis_zip_list/" itemprop="url">Redis数据结构: 压缩列表</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-11-03T00:00:00+08:00">
                2016-11-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/开源项目/" itemprop="url" rel="index">
                    <span itemprop="name">开源项目</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>与整数集合类似，压缩列表也是 Redis 为了节约内存而开发的。它是由一系列特殊编码的内存块构成的列表。一个压缩列表可以包含多个节点，每个节点可以保存一个长度受限的字符数组或者整数。通过特殊的编码方式，可以用最少的空间来存储不同长度的字符串和整数，使得使用的存储空间最小。</p>
<h3 id="压缩列表的基本结构"><a href="#压缩列表的基本结构" class="headerlink" title="压缩列表的基本结构"></a>压缩列表的基本结构</h3><p>一个压缩列表包含如下的字段：</p>
<ul>
<li>zlbytes：uint32_t，记录整个压缩列表占用的内存字节数</li>
<li>zltail：uint32_t，记录压缩列表表尾节点距离压缩列表的起始发位置的字节数</li>
<li>zllen：uint16_t，记录了压缩列表包含的节点数量，注意，这个节点的数量不一定是真实的数量，当节点的数量小于 65535（uint16_t 所能表达的最大的值）时，这个字段记录了节点的数量，当数量超过这个限制的时候，就需要遍历整个压缩列表才能获得节点的数量</li>
<li>entryX：在上述 10 个节点之后，是保存在这个压缩列表中的节点，长度由具体的结构决定。每个压缩列表的节点保存了一个长度受限的字节数组，或者一个整数值，具体的结构如下：<ul>
<li>previous_entry_length：记录前一个节点的长度，如果前一个节点的长度小于 254，即 1 个字节能够存储，则使用 1 个字节来存储这个长度；否则使用 5 个字节来保存，其中第一个字节固定保存 255，后续四个字节保存长度。这个字段与 zltail 联合起来，可以完成从压缩列表的末端开始，向表头遍历的操作：首先，通过表头指针和 zltail 计算获得最后一个节点的指针；然后，通过最后一个节点的 previous_entry_length 计算获得前一个节点的指针，重复上述过程，就可以持续向前直到表头</li>
<li>encoding：保存节点的 content 属性对应的数据类型和长度，encoding 的第一个字节的前两位决定了保存的数据类型<ul>
<li>00：表示的是长度小于等于 63（2^4 - 1）的字节数组，此时 encoding 的长度是 1 个字节</li>
<li>01：表示的是长度小于等于 16383（2^4 - 1）的字节数组，此时 encoding 的长度是 2 个字节</li>
<li>10：表示的是长度小于等于 4294967295（23^2 - 1）的字节数组，此时 encoding 的长度是 5 个字节，此时第一个字节除了前两位以外全部留空</li>
<li>11：表示的是整数，对应五种整数类型<ul>
<li>11000000：int16_t</li>
<li>11010000：int32_t</li>
<li>11100000：int64_t</li>
<li>11110000：24 位有符号整数</li>
<li>11111110：8 位有符号整数</li>
<li>1111xxxx：可以表示 0 - 12 这几个数，由于 0000、1110 和 1111 被占用，因此二进制值为 1 - 13，减 1 表示实际的值</li>
</ul>
</li>
</ul>
</li>
<li>content：节点保存的值</li>
</ul>
</li>
<li>zlend：uint8_t，用特殊值 0xFF（255）来标记压缩列表的末端</li>
</ul>
<h3 id="Push-和-Pop-操作"><a href="#Push-和-Pop-操作" class="headerlink" title="Push 和 Pop 操作"></a>Push 和 Pop 操作</h3><p>Redis 的压缩列表支持从两端插入（Push）或删除（Pop）节点，以 Push 为例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">ziplistPush</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl, <span class="keyword">unsigned</span> <span class="keyword">char</span> *s, <span class="keyword">unsigned</span> <span class="keyword">int</span> slen, <span class="keyword">int</span> where)</span> </span>&#123;</div><div class="line">    <span class="comment">// 根据 where 参数的值，决定将值插入到表头还是表尾</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *p;</div><div class="line">    p = (where == ZIPLIST_HEAD) ? ZIPLIST_ENTRY_HEAD(zl) : ZIPLIST_ENTRY_END(zl);</div><div class="line">    <span class="comment">// 返回添加新值后的 ziplist</span></div><div class="line">    <span class="keyword">return</span> __ziplistInsert(zl,p,s,slen);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在 __ziplistInsert 函数中实现了新节点的插入，主要的步骤为：</p>
<ol>
<li>根据前置节点和当前节点计算 entry 的 previous_entry_length、encoding 和 contents 字段占用的字节数</li>
<li>判断当前指针指向的位置是否能够存储当前的节点，如果不能存储，则需用 realloc 函数调整压缩列表的大小</li>
<li>移动后续节点腾出空间，将当前需要插入的节点放入，同时需要更新后续的节点的 previous_entry_length</li>
</ol>
<p>具体的代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *__ziplistInsert(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl, <span class="keyword">unsigned</span> <span class="keyword">char</span> *p, <span class="keyword">unsigned</span> <span class="keyword">char</span> *s, <span class="keyword">unsigned</span> <span class="keyword">int</span> slen) &#123;</div><div class="line">    <span class="comment">// 记录当前 ziplist 的长度</span></div><div class="line">    <span class="keyword">size_t</span> curlen = intrev32ifbe(ZIPLIST_BYTES(zl)), reqlen, prevlen = <span class="number">0</span>;</div><div class="line">    <span class="keyword">size_t</span> offset;</div><div class="line">    <span class="keyword">int</span> nextdiff = <span class="number">0</span>;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> encoding = <span class="number">0</span>;</div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> value = <span class="number">123456789</span>;</div><div class="line">    zlentry entry, tail;</div><div class="line">    <span class="keyword">if</span> (p[<span class="number">0</span>] != ZIP_END) &#123;</div><div class="line">        <span class="comment">// 如果 p[0] 不指向列表末端，说明列表非空，并且 p 正指向列表的其中一个节点，那么取出 p 所指向节点的信息，并将它保存到 entry 结构中</span></div><div class="line">        <span class="comment">// 然后用 prevlen 变量记录前置节点的长度，当插入新节点之后 p 所指向的节点就成了新节点的前置节点</span></div><div class="line">        entry = zipEntry(p);</div><div class="line">        prevlen = entry.prevrawlen;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 如果 p 指向表尾末端，那么程序需要检查列表是否为：</span></div><div class="line">        <span class="comment">// 1)如果 ptail 也指向 ZIP_END ，那么列表为空；</span></div><div class="line">        <span class="comment">// 2)如果列表不为空，那么 ptail 将指向列表的最后一个节点。</span></div><div class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> *ptail = ZIPLIST_ENTRY_TAIL(zl);</div><div class="line">        <span class="keyword">if</span> (ptail[<span class="number">0</span>] != ZIP_END) &#123;</div><div class="line">            <span class="comment">// 表尾节点为新节点的前置节点</span></div><div class="line">            <span class="comment">// 取出表尾节点的长度</span></div><div class="line">            <span class="comment">// T = O(1)</span></div><div class="line">            prevlen = zipRawEntryLength(ptail);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 尝试看能否将输入字符串转换为整数，如果成功的话：</span></div><div class="line">    <span class="comment">// 1)value 将保存转换后的整数值</span></div><div class="line">    <span class="comment">// 2)encoding 则保存适用于 value 的编码方式</span></div><div class="line">    <span class="comment">// 无论使用什么编码， reqlen 都保存节点值的长度</span></div><div class="line">    <span class="keyword">if</span> (zipTryEncoding(s,slen,&amp;value,&amp;encoding)) &#123;</div><div class="line">        reqlen = zipIntSize(encoding);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        reqlen = slen;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 计算编码前置节点的长度所需的大小</span></div><div class="line">    reqlen += zipPrevEncodeLength(<span class="literal">NULL</span>,prevlen);</div><div class="line">    <span class="comment">// 计算编码当前节点值所需的大小</span></div><div class="line">    reqlen += zipEncodeLength(<span class="literal">NULL</span>,encoding,slen);</div><div class="line">    <span class="comment">// 只要新节点不是被添加到列表末端，</span></div><div class="line">    <span class="comment">// 那么程序就需要检查看 p 所指向的节点（的 header）能否编码新节点的长度。</span></div><div class="line">    <span class="comment">// nextdiff 保存了新旧编码之间的字节大小差，如果这个值大于 0</span></div><div class="line">    <span class="comment">// 那么说明需要对 p 所指向的节点（的 header ）进行扩展</span></div><div class="line">    <span class="comment">// T = O(1)</span></div><div class="line">    nextdiff = (p[<span class="number">0</span>] != ZIP_END) ? zipPrevLenByteDiff(p,reqlen) : <span class="number">0</span>;</div><div class="line">    <span class="comment">// 因为重分配空间可能会改变 zl 的地址</span></div><div class="line">    <span class="comment">// 所以在分配之前，需要记录 zl 到 p 的偏移量，然后在分配之后依靠偏移量还原 p</span></div><div class="line">    offset = p-zl;</div><div class="line"></div><div class="line">    <span class="comment">// curlen 是 ziplist 原来的长度</span></div><div class="line">    <span class="comment">// reqlen 是整个新节点的长度</span></div><div class="line">    <span class="comment">// nextdiff 是新节点的后继节点扩展 header 的长度（要么 0 字节，要么 4 个字节）</span></div><div class="line">    zl = ziplistResize(zl,curlen+reqlen+nextdiff);</div><div class="line">    p = zl+offset;</div><div class="line">    <span class="keyword">if</span> (p[<span class="number">0</span>] != ZIP_END) &#123;</div><div class="line">        <span class="comment">// 新元素之后还有节点，因为新元素的加入，需要对这些原有节点进行调整</span></div><div class="line">        <span class="comment">// 移动现有元素，为新元素的插入空间腾出位置</span></div><div class="line">        memmove(p+reqlen,p-nextdiff,curlen-offset<span class="number">-1</span>+nextdiff);</div><div class="line">        <span class="comment">// 将新节点的长度编码至后置节点</span></div><div class="line">        <span class="comment">// p+reqlen 定位到后置节点</span></div><div class="line">        <span class="comment">// reqlen 是新节点的长度</span></div><div class="line">        zipPrevEncodeLength(p+reqlen,reqlen);</div><div class="line">        <span class="comment">// 更新到达表尾的偏移量，将新节点的长度也算上</span></div><div class="line">        ZIPLIST_TAIL_OFFSET(zl) =</div><div class="line">            intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+reqlen);</div><div class="line">        <span class="comment">// 如果新节点的后面有多于一个节点</span></div><div class="line">        <span class="comment">// 那么程序需要将 nextdiff 记录的字节数也计算到表尾偏移量中</span></div><div class="line">        <span class="comment">// 这样才能让表尾偏移量正确对齐表尾节点</span></div><div class="line">        tail = zipEntry(p+reqlen);</div><div class="line">        <span class="keyword">if</span> (p[reqlen+tail.headersize+tail.len] != ZIP_END) &#123;</div><div class="line">            ZIPLIST_TAIL_OFFSET(zl) =</div><div class="line">                intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+nextdiff);</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">/* This element will be the new tail. */</span></div><div class="line">        <span class="comment">// 新元素是新的表尾节点</span></div><div class="line">        ZIPLIST_TAIL_OFFSET(zl) = intrev32ifbe(p-zl);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/* When nextdiff != 0, the raw length of the next entry has changed, so</span></div><div class="line">     * we need to cascade the update throughout the ziplist */</div><div class="line">    <span class="comment">// 当 nextdiff != 0 时，新节点的后继节点的（header 部分）长度已经被改变，</span></div><div class="line">    <span class="comment">// 所以需要级联地更新后续的节点</span></div><div class="line">    <span class="keyword">if</span> (nextdiff != <span class="number">0</span>) &#123;</div><div class="line">        offset = p-zl;</div><div class="line">        <span class="comment">// T  = O(N^2)</span></div><div class="line">        zl = __ziplistCascadeUpdate(zl,p+reqlen);</div><div class="line">        p = zl+offset;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/* Write the entry */</span></div><div class="line">    <span class="comment">// 一切搞定，将前置节点的长度写入新节点的 header</span></div><div class="line">    p += zipPrevEncodeLength(p,prevlen);</div><div class="line">    <span class="comment">// 将节点值的长度写入新节点的 header</span></div><div class="line">    p += zipEncodeLength(p,encoding,slen);</div><div class="line">    <span class="comment">// 写入节点值</span></div><div class="line">    <span class="keyword">if</span> (ZIP_IS_STR(encoding)) &#123;</div><div class="line">        <span class="comment">// T = O(N)</span></div><div class="line">        <span class="built_in">memcpy</span>(p,s,slen);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// T = O(1)</span></div><div class="line">        zipSaveInteger(p,value,encoding);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 更新列表的节点数量计数器</span></div><div class="line">    <span class="comment">// T = O(1)</span></div><div class="line">    ZIPLIST_INCR_LENGTH(zl,<span class="number">1</span>);</div><div class="line">    <span class="keyword">return</span> zl;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在更新后续节点的 previous_entry_length 的过程中，可能会发生如下一种情况：当前的节点原先的长度小于 254，而新插入的节点长度大于 254，那么 encoding 的长度变长了，这样，若后续节点是一系列长度为 250 - 254，那么需要连续地更新后续节点的 header（即计算节点长度、重新分配空间然后后移后续节点插入新的 encoding 字段，直到整个压缩列表满足条件）。这个过程是在函数 __ziplistCascadeUpdate 中完成的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *__ziplistCascadeUpdate(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl, <span class="keyword">unsigned</span> <span class="keyword">char</span> *p) &#123;</div><div class="line">    <span class="keyword">size_t</span> curlen = intrev32ifbe(ZIPLIST_BYTES(zl)), rawlen, rawlensize;</div><div class="line">    <span class="keyword">size_t</span> offset, noffset, extra;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *np;</div><div class="line">    zlentry cur, next;</div><div class="line">    <span class="keyword">while</span> (p[<span class="number">0</span>] != ZIP_END) &#123;</div><div class="line">        <span class="comment">// 将 p 所指向的节点的信息保存到 cur 结构中</span></div><div class="line">        cur = zipEntry(p);</div><div class="line">        <span class="comment">// 当前节点的长度</span></div><div class="line">        rawlen = cur.headersize + cur.len;</div><div class="line">        <span class="comment">// 计算编码当前节点的长度所需的字节数</span></div><div class="line">        <span class="comment">// T = O(1)</span></div><div class="line">        rawlensize = zipPrevEncodeLength(<span class="literal">NULL</span>,rawlen);</div><div class="line">        <span class="comment">/* Abort if there is no next entry. */</span></div><div class="line">        <span class="comment">// 如果已经没有后续空间需要更新了，跳出</span></div><div class="line">        <span class="keyword">if</span> (p[rawlen] == ZIP_END) <span class="keyword">break</span>;</div><div class="line">        <span class="comment">// 取出后续节点的信息，保存到 next 结构中</span></div><div class="line">        next = zipEntry(p+rawlen);</div><div class="line">        <span class="comment">// 后续节点编码当前节点的空间已经足够，无须再进行任何处理，跳出</span></div><div class="line">        <span class="comment">// 可以证明，只要遇到一个空间足够的节点，</span></div><div class="line">        <span class="comment">// 那么这个节点之后的所有节点的空间都是足够的</span></div><div class="line">        <span class="keyword">if</span> (next.prevrawlen == rawlen) <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">if</span> (next.prevrawlensize &lt; rawlensize) &#123;</div><div class="line">            <span class="comment">// 执行到这里，表示 next 空间的大小不足以编码 cur 的长度</span></div><div class="line">            <span class="comment">// 所以程序需要对 next 节点的（header 部分）空间进行扩展</span></div><div class="line">            <span class="comment">// 记录 p 的偏移量</span></div><div class="line">            offset = p-zl;</div><div class="line">            <span class="comment">// 计算需要增加的节点数量</span></div><div class="line">            extra = rawlensize-next.prevrawlensize;</div><div class="line">            <span class="comment">// 扩展 zl 的大小</span></div><div class="line">            zl = ziplistResize(zl,curlen+extra);</div><div class="line">            <span class="comment">// 还原指针 p</span></div><div class="line">            p = zl+offset;</div><div class="line">            <span class="comment">/* Current pointer and offset for next element. */</span></div><div class="line">            <span class="comment">// 记录下一节点的偏移量</span></div><div class="line">            np = p+rawlen;</div><div class="line">            noffset = np-zl;</div><div class="line">            <span class="comment">// 当 next 节点不是表尾节点时，更新列表到表尾节点的偏移量</span></div><div class="line">            <span class="keyword">if</span> ((zl+intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))) != np) &#123;</div><div class="line">                ZIPLIST_TAIL_OFFSET(zl) =</div><div class="line">                    intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+extra);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 向后移动 cur 节点之后的数据，为 cur 的新 header 腾出空间</span></div><div class="line">            memmove(np+rawlensize,</div><div class="line">                np+next.prevrawlensize,</div><div class="line">                curlen-noffset-next.prevrawlensize<span class="number">-1</span>);</div><div class="line">            <span class="comment">// 将新的前一节点长度值编码进新的 next 节点的 header</span></div><div class="line">            zipPrevEncodeLength(np,rawlen);</div><div class="line">            <span class="comment">// 移动指针，继续处理下个节点</span></div><div class="line">            p += rawlen;</div><div class="line">            curlen += extra;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">if</span> (next.prevrawlensize &gt; rawlensize) &#123;</div><div class="line">                <span class="comment">/* This would result in shrinking, which we want to avoid.</span></div><div class="line">                 * So, set "rawlen" in the available bytes. */</div><div class="line">                <span class="comment">// 执行到这里，说明 next 节点编码前置节点的 header 空间有 5 字节</span></div><div class="line">                <span class="comment">// 而编码 rawlen 只需要 1 字节</span></div><div class="line">                <span class="comment">// 但是程序不会对 next 进行缩小，</span></div><div class="line">                <span class="comment">// 所以这里只将 rawlen 写入 5 字节的 header 中就算了。</span></div><div class="line">                <span class="comment">// T = O(1)</span></div><div class="line">                zipPrevEncodeLengthForceLarge(p+rawlen,rawlen);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// 运行到这里，说明 cur 节点的长度正好可以编码到 next 节点的 header 中</span></div><div class="line">                zipPrevEncodeLength(p+rawlen,rawlen);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> zl;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>不仅是插入有可能导致这样的连锁更新，当删除或改变一个节点的内容时，也可能发生这样的连锁更新。这样的连锁更新是非常耗费时间的（最差的情况时间复杂度为 O(N)），但是只有碰到连续长度为 250 - 254 的节点串时，才会触发该操作，当遍历到第一个满足条件的节点以后，操作就停止了。</p>
<p>值得注意的是，由于压缩列表的各项操作都需要遍历整个列表才能完成，因此，操作的时间复杂度都为 O(N)，这样使得在使用压缩列表时，表中的节点数不能太多，否则将极度影响操作的效率。在后续的数据结构介绍过程中，我们可以看到 Redis 对于压缩列表的使用是有限制的，使得既能利用压缩列表节省空间的特性，也能通过其它的设计或约束降低操作的时间复杂度。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/10/28/redis_intset/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="柿子">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柿子的果盘">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/10/28/redis_intset/" itemprop="url">Redis数据结构: 整数集合</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-10-28T00:00:00+08:00">
                2016-10-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/开源项目/" itemprop="url" rel="index">
                    <span itemprop="name">开源项目</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Redis 实现的整数集合是一种只包含整数数值的集合，是一种非常简单的数据结构，它按照数值的大小依次存储这些整数。为了节省存储空间，整数集合使用基本的一个字节作为存储单位，在更大的数值插入时完成整个集合的类型提升。</p>
<p>C 语言对应的整数值可以存在不同大小的类型（short int、int、long 和 long long）中，这些类型使用的是不同数量的字节（分别是 1 字节、2 字节、4 字节 和 8 字节）。如果我们给整数集合统一使用 long long 类型（8 个字节），那么全部由小整数组成的集合将浪费多余的空间；而如果使用太小的类型，则许多大的整数数值将无法存储。因此，需要能够动态调节整数的类型，使得在不同的场景下，用不同的类型存储整数，而 Redis 正是这么做的。Redis 使用 int8_t（即一个字节）作为整数集合的基本存储单位，对于 short int、int、long、long long 对应的数值采用数组中连续的多个字节来保存。初始使用 int16_t 来保存整数值；一旦发现更大的数值存入的时候，对于原先的数组进行类型提升，使得更大的数值能够存入。了解了这个基本的想法以后，对于整数集合的设计和实现就变得很简单。</p>
<p>整数集合的实现在 intset.h 和 intset.c 中，我们先来看看它的结构：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span> &#123;</span></div><div class="line">    <span class="keyword">uint32_t</span> encoding;     <span class="comment">// 编码方式</span></div><div class="line">    <span class="keyword">uint32_t</span> length;       <span class="comment">// 集合包含的元素数量</span></div><div class="line">    <span class="keyword">int8_t</span> contents[];     <span class="comment">// 保存元素的数组</span></div><div class="line">&#125; intset;</div></pre></td></tr></table></figure></p>
<p>在这个结构中，所有的整数保存在 contents 数组中，而这个数组的类型是 int8_t（一个字节，现行的计算机通常都是以一个字节为存储单位），但是这个数据结构并不保存 int8_t 类型的整数，而是用于保存 int16_t, int32_t 或 int62_t 的整数，具体保存的类型由 encoding 来决定。按照这样的保存方式，一个整数是由数组中的若干个连续的数合起来进行表示的，例如 int16_t 类型的整数 12345 就需要数组中的连续 2 个元素进行保存，分别是 48 和 57，这两个数的顺序由整数在内存中的存储顺序（大端或小端）决定。Redis 对于大端小端这两种存储方式的处理在 endianconv.h 和 endianconv.c 中，比较简单就不展开介绍了。<br>当创建一个新的整数集合时，默认将编码方式设置为 int16_t。当一个新的整数被添加的时候，此时需要检查该整数的类型是否是是 int16_t。若是，则直接找到需要插入的位置，将其插入；若不是 int16_t，而是更大的数据类型，则需要分配更大的空间，然后将数据从后到前依次放入新的位置。举个例子，一个 int16_t 类型的整数集合：</p>
<table>
<thead>
<tr>
<th>位</th>
<th>0至15位</th>
<th>16至31位</th>
<th>32至47位</th>
</tr>
</thead>
<tbody>
<tr>
<td>元素</td>
<td>123</td>
<td>2322</td>
<td>56223</td>
</tr>
</tbody>
</table>
<p>此时我们需要插入一个 int32_t 类型的数据 123456，这个时候需要先分配一些新的空间：</p>
<table>
<thead>
<tr>
<th>位</th>
<th>0至15位</th>
<th>16至31位</th>
<th>32至47位</th>
<th>48位至127位</th>
</tr>
</thead>
<tbody>
<tr>
<td>元素</td>
<td>123</td>
<td>2322</td>
<td>56223</td>
<td>(新分配空间)</td>
</tr>
</tbody>
</table>
<p>然后由后向前依次将原来的数放到新的位置上，这里需要预先判断一下，新加入的数的位置，由于类型变大，所以新存入的整数不是最大的，就是最小的：</p>
<table>
<thead>
<tr>
<th>位</th>
<th>0至31位</th>
<th>32至63位</th>
<th>64至95位</th>
<th>96位至127位</th>
</tr>
</thead>
<tbody>
<tr>
<td>元素</td>
<td>123</td>
<td>2322</td>
<td>56223</td>
<td>(新分配空间)</td>
</tr>
</tbody>
</table>
<p>由于 12345 比 原先的数都大，因此存入最后的位置，自此插入整数操作就完成了。由于需要挪动所有的元素，所以时间复杂度为 O(N)。</p>
<table>
<thead>
<tr>
<th>位</th>
<th>0至31位</th>
<th>32至63位</th>
<th>64至95位</th>
<th>96位至127位</th>
</tr>
</thead>
<tbody>
<tr>
<td>元素</td>
<td>123</td>
<td>2322</td>
<td>56223</td>
<td>123456</td>
</tr>
</tbody>
</table>
<p>具体的代码可以查看 intsetMoveTail 函数，由于类型发生增大的情况（否则将高位的 0 去掉，可以直接存入当前的集合）只有可能有两种：</p>
<ol>
<li>比集合中所有的元素都大</li>
<li>比集合中所有的元素都小，此时，插入的数为负数</li>
</ol>
<p>所以插入的位置肯定在两端：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">uint8_t</span> _intsetValueEncoding(<span class="keyword">int64_t</span> v) &#123;</div><div class="line">    <span class="comment">// 查找最小的整型类型存储对应的整数值</span></div><div class="line">    <span class="keyword">if</span> (v &lt; INT32_MIN || v &gt; INT32_MAX)</div><div class="line">        <span class="keyword">return</span> INTSET_ENC_INT64;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (v &lt; INT16_MIN || v &gt; INT16_MAX)</div><div class="line">        <span class="keyword">return</span> INTSET_ENC_INT32;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        <span class="keyword">return</span> INTSET_ENC_INT16;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">static</span> intset *<span class="title">intsetUpgradeAndAdd</span><span class="params">(intset *is, <span class="keyword">int64_t</span> value)</span> </span>&#123;</div><div class="line">    <span class="keyword">uint8_t</span> curenc = intrev32ifbe(is-&gt;encoding);</div><div class="line">    <span class="keyword">uint8_t</span> newenc = _intsetValueEncoding(value);</div><div class="line">    <span class="keyword">int</span> length = intrev32ifbe(is-&gt;length);</div><div class="line">    <span class="comment">// 判断若发生了类型增大，则在集合的哪头进行插入</span></div><div class="line">    <span class="keyword">int</span> prepend = value &lt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</div><div class="line">    <span class="comment">// 调整整数结合的大小</span></div><div class="line">    is-&gt;encoding = intrev32ifbe(newenc);</div><div class="line">    is = intsetResize(is,intrev32ifbe(is-&gt;length)+<span class="number">1</span>);</div><div class="line">    <span class="comment">//自后向前将值放入新的位置</span></div><div class="line">    <span class="keyword">while</span>(length--)</div><div class="line">        _intsetSet(is,length+prepend,_intsetGetEncoded(is,length,curenc));</div><div class="line">    <span class="comment">// 将新的整数放入集合</span></div><div class="line">    <span class="keyword">if</span> (prepend)</div><div class="line">        _intsetSet(is,<span class="number">0</span>,value);</div><div class="line">    <span class="keyword">else</span></div><div class="line">        _intsetSet(is,intrev32ifbe(is-&gt;length),value);</div><div class="line">    is-&gt;length = intrev32ifbe(intrev32ifbe(is-&gt;length)+<span class="number">1</span>);</div><div class="line">    <span class="keyword">return</span> is;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意，整数集合并没有提供降级操作，即一旦该整数集合被升级了以后，即使插入数据类型大的数被删除以后，对于该整数集合的提升并不会撤销。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/10/21/redis_dict/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="柿子">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柿子的果盘">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/10/21/redis_dict/" itemprop="url">Redis数据结构: 字典</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-10-21T00:00:00+08:00">
                2016-10-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/开源项目/" itemprop="url" rel="index">
                    <span itemprop="name">开源项目</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>字典是一种常用的数据结构，在很多其它的高级编程语言里都有内置的实现方式，但是 C 语言没有，所以 Redis 自己实现了一个。Redis 使用哈希表作为字典的实现方式，代码主要在 dict.h 和 dict.c 中。</p>
<p>首先来看看哈希表的节点结构，这里面包含键值对和一个指向下个节点的指针：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></div><div class="line">    <span class="keyword">void</span> *key;</div><div class="line">    <span class="keyword">union</span> &#123;</div><div class="line">        <span class="keyword">void</span> *val;</div><div class="line">        <span class="keyword">uint64_t</span> u64;</div><div class="line">        <span class="keyword">int64_t</span> s64;</div><div class="line">        <span class="keyword">double</span> d;</div><div class="line">    &#125; v;</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></div><div class="line">&#125; dictEntry;</div></pre></td></tr></table></figure>
<p>通过这个结构能知道，Redis 的哈希解决冲突的方式是链表，将相同哈希值的键值对保存在一个单项列表中，而且为了性能的考虑，Redis 总是将最后插入链表的节点作为这个链表的表头，这样使得插入操作的时间复杂度为 O(1)，例如 dictRehash 函数中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">de-&gt;next = d-&gt;ht[<span class="number">1</span>].table[h];</div><div class="line">d-&gt;ht[<span class="number">1</span>].table[h] = de;</div></pre></td></tr></table></figure>
<p>其次是哈希表的结构，里面包含了哈希表内容、长度、掩码值和已使用的空间，其中掩码值用于将哈希函数计算出的哈希值对应到表中的索引值，对于哈希函数的使用可以看后面的介绍：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></div><div class="line">    dictEntry **table;       <span class="comment">// 哈希表内容</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> size;      <span class="comment">// 哈希表的长度</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask;  <span class="comment">// 掩码值，永远等于 size - 1，用于将哈希值对应到索引值</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used;      <span class="comment">// 已使用的空间大小</span></div><div class="line">&#125; dictht;</div></pre></td></tr></table></figure>
<p>接下来是字典的结构，在字典中包含了两个哈希表，自定义类型相关的函数和私有数据，以及 rehash 过程需要用到的索引和安全迭代器的数量，具体的 Rehash 过程在后面进行介绍：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></div><div class="line">    dictType *type;           <span class="comment">// 类型特定函数</span></div><div class="line">    <span class="keyword">void</span> *privdata;           <span class="comment">// 私有数据</span></div><div class="line">    dictht ht[<span class="number">2</span>];             <span class="comment">// 哈希表</span></div><div class="line">    <span class="keyword">int</span> rehashidx;            <span class="comment">// rehash 索引，当 rehash 不在进行时，值为 -1</span></div><div class="line">    <span class="keyword">int</span> iterators;            <span class="comment">// 目前正在运行的安全迭代器的数量</span></div><div class="line">&#125; dict;</div></pre></td></tr></table></figure>
<p>通过 dictType 的定义，可以看到 privdata 保存了类型特定函数的一些可选参数，在调用函数时传入。Redis 给不同的字典实现不同的类型函数以及定义不同的私有数据，从而实现字典的多态：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictType</span> &#123;</span></div><div class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span> <span class="params">(*hashFunction)</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *key)</span></span>;</div><div class="line">    <span class="keyword">void</span> *(*keyDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key);</div><div class="line">    <span class="keyword">void</span> *(*valDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *obj);</div><div class="line">    <span class="keyword">int</span> (*keyCompare)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key1, <span class="keyword">const</span> <span class="keyword">void</span> *key2);</div><div class="line">    <span class="keyword">void</span> (*keyDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *key);</div><div class="line">    <span class="keyword">void</span> (*valDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *obj);</div><div class="line">&#125; dictType;</div></pre></td></tr></table></figure>
<p>在了解完基本的结构以后，我们再来看哈希表和字典的具体实现细节进行。</p>
<h2 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h2><p>从上述的介绍中，我们可以知道 Redis 利用 dictType 定义的类型特定函数来实现多态，在这些类型函数中，hashFunction 负责将 key 进行转换，得到对应的哈希值。根据不同的字典，使用的哈希算法也不相同。得到哈希值以后，再通过与哈希表的掩码值进行与操作，就获得 key 对应的索引值，具体可以看 dictRehash 函数中计算索引值的操作：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> dictHashKey(d, key) (d)-&gt;type-&gt;hashFunction(key)</span></div><div class="line">h = dictHashKey(d, de-&gt;key) &amp; d-&gt;ht[<span class="number">1</span>].sizemask;</div></pre></td></tr></table></figure>
<p>Redis 提供了几种种哈希函数:</p>
<ol>
<li>Thomas Wang 发明的 32 bits / 64 bits 的整数哈希函数<br>在之前的版本中，使用这个哈希函数来对整数进行哈希操作，这个哈希函数通过加法和位移操作进行哈希值的计算，避免了乘法操作带来的性能损失，同时使结果具有均匀的分布，以及雪崩效应。在之前的版本中单独编写函数，对于整数进行哈希，而在最新的版本中，只作为 figureprint 生成的函数。对于这个哈希函数的细节，可以参考我之前翻译的 Thomas Wang 写的整数哈希函数。</li>
<li>Austin Appleby 发明的 MurmurHash2 算法<br>murmur 是 multiply and rotate 的意思，因为算法的核心就是不断的乘和移位。MurmurHash 算法具有高运算性能，低碰撞率的特点，由 Austin Appleby 创建于2008年，最新的版本是 MurmurHash3，现已应用到Hadoop、libstdc++、nginx、libmemcached等开源系统。<br>通过 murmur 函数获得的哈希值分布均匀，比如：murmur计算”abc”是1118836419，”abd”是413429783。而使用 Horner 算法，”abc”是96354， “abd”就比它多1（96355）。</li>
<li>DJB 算法的修改版<br>DJB 算法同样是用于字符串类型的哈希函数，原理也非常简单，就是不断乘以 33 再加上对应的字符。该算法的执行效率和随机性都不错。在 Redis 中对该算法进行了简单的修改，使得它对大小写不敏感。</li>
</ol>
<p>对于 MurmurHash2 和 DJB 两种字符串哈希函数的比较：</p>
<ol>
<li>有人做过一个<a href="http://blog.csdn.net/wwwsq/article/details/4254123" target="_blank" rel="external">性能对比的实验</a>，得出结论：从计算速度上来看，MurmurHash只适用于已知长度的、长度比较长的字符串。长度未知或者长度不超过10字节，都应该使用DJB。而在前面介绍 SDS 的时候，我们知道 Redis 的字符串的 strlen 操作的时间复杂度是 O(1)，因此在长度大于 10 字节时，使用 MurmurHash2 可以获得一个随机性更好的哈希值，性能也更优；</li>
<li>另外，在代码的实现中，也将 DJB 和 MurmurHash2 算法进行了区别，DJB 的实现对字母的大小写不敏感，而 MurmurHash2 则是敏感的。</li>
</ol>
<h2 id="Rehash"><a href="#Rehash" class="headerlink" title="Rehash"></a>Rehash</h2><p>随着各类操作的不断执行，字典中的键值对的数量会不断地变化。当键值对的数量增加到一定数量以后，会使得碰撞冲突变得剧烈，影响哈希表的性能；而当键值对减少到一定程度以后，则会空闲大量的存储空间。因此，为了让哈希表的负载因子（键值对数量 / 哈希表大小）维持在一个合理的范围内，我们需要对哈希表进行适当的收缩和扩张。这个操作的基本步骤为：</p>
<ol>
<li>根据不同的操作（不同的大小）创建一个新的哈希表 ht[1]</li>
<li>渐进式地进行哈希表节点的迁移</li>
<li>完成迁移以后，将 ht[0] 的空间释放掉，将 ht[1] 替换 ht[0]</li>
</ol>
<h3 id="进行-Rehash-操作的条件"><a href="#进行-Rehash-操作的条件" class="headerlink" title="进行 Rehash 操作的条件"></a>进行 Rehash 操作的条件</h3><p>Redis 基于哈希表的性能和整体服务的性能考虑，将进行 Rehash 的情况分为两种：</p>
<ol>
<li>正常使用 Redis 时，当负载因子超过 1 时，就考虑进行 Rehash 操作；</li>
<li>Redis 利用后台线程进行持久化，这个时候为了最大程度利用 Copy On Write 机制带来的性能提升，会暂时停止 Rehash 操作，除非负载因子超过 dict_force_resize_ratio 的值</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> _dictExpandIfNeeded(dict *d)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (dictIsRehashing(d)) <span class="keyword">return</span> DICT_OK;</div><div class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].size == <span class="number">0</span>) <span class="keyword">return</span> dictExpand(d, DICT_HT_INITIAL_SIZE);</div><div class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].used &gt;= d-&gt;ht[<span class="number">0</span>].size &amp;&amp;</div><div class="line">        (dict_can_resize ||</div><div class="line">         d-&gt;ht[<span class="number">0</span>].used/d-&gt;ht[<span class="number">0</span>].size &gt; dict_force_resize_ratio))</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> dictExpand(d, d-&gt;ht[<span class="number">0</span>].used*<span class="number">2</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> DICT_OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="创建新的哈希表"><a href="#创建新的哈希表" class="headerlink" title="创建新的哈希表"></a>创建新的哈希表</h3><p>扩张哈希表的操作是在 _dictExpandIfNeeded 函数里进行判断和扩张的，而收缩哈希表的操作则是通过调用 dictResize 函数进行。而这两个函数同时调用了 dictExpand 函数。具体如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictExpand</span><span class="params">(dict *d, <span class="keyword">unsigned</span> <span class="keyword">long</span> size)</span></span></div><div class="line">&#123;</div><div class="line">    dictht n; <span class="comment">// 新哈希表</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> realsize = _dictNextPower(size);  <span class="comment">// 根据 size 参数，计算哈希表的大小</span></div><div class="line">    <span class="comment">// 不能在字典正在 rehash 时进行</span></div><div class="line">    <span class="comment">// size 的值也不能小于 0 号哈希表的当前已使用节点</span></div><div class="line">    <span class="keyword">if</span> (dictIsRehashing(d) || d-&gt;ht[<span class="number">0</span>].used &gt; size)</div><div class="line">        <span class="keyword">return</span> DICT_ERR;</div><div class="line">    <span class="comment">// 为哈希表分配空间，并将所有指针指向 NULL</span></div><div class="line">    n.size = realsize;</div><div class="line">    n.sizemask = realsize<span class="number">-1</span>;</div><div class="line">    n.table = zcalloc(realsize*<span class="keyword">sizeof</span>(dictEntry*));</div><div class="line">    n.used = <span class="number">0</span>;</div><div class="line">    <span class="comment">// 如果此时 ht[0] 如果为空，则表示当前的操作是初始化哈希表</span></div><div class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].table == <span class="literal">NULL</span>) &#123;</div><div class="line">        d-&gt;ht[<span class="number">0</span>] = n;</div><div class="line">        <span class="keyword">return</span> DICT_OK;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 设置新的哈希表大小，开始进行迁移</span></div><div class="line">    d-&gt;ht[<span class="number">1</span>] = n;</div><div class="line">    d-&gt;rehashidx = <span class="number">0</span>;</div><div class="line">    <span class="keyword">return</span> DICT_OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这个函数中，根据传入 size 的大小，查找到第一个大于等于 size 的 2 的次幂，作为新的哈希表的大小。在 dictResize 函数中，传入的是 ht[0].used，而在 _dictExpandIfNeeded 中传入的是 ht[0].used * 2。</p>
<h3 id="渐进式迁移"><a href="#渐进式迁移" class="headerlink" title="渐进式迁移"></a>渐进式迁移</h3><p>如果保存的哈希表节点特别多，将整个迁移过程一次性完成的话，将很长时间无法进行正常的插入操作，所以 Redis 使用渐进式的方式来完成哈希节点的迁移。具体的过程在 dictRehash 中实现，这个函数完成 n 个哈希表节点的迁移，并同时检测 rehash 操作是否已经完成：当整个 ht[0] 中的节点都迁移到 ht[1] 以后，释放 ht[0] 的空间，将 ht[1] 换入 ht[0]，同时重置所有的 rehash 相关的参数，就完成 rehash 的过程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictRehash</span><span class="params">(dict *d, <span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">    <span class="comment">// 只可以在 rehash 进行中时执行</span></div><div class="line">    <span class="keyword">if</span> (!dictIsRehashing(d)) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    <span class="comment">// 进行 N 步迁移</span></div><div class="line">    <span class="keyword">while</span>(n--) &#123;</div><div class="line">        dictEntry *de, *nextde;</div><div class="line">        <span class="comment">// 如果 0 号哈希表为空，那么表示 rehash 执行完毕</span></div><div class="line">        <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].used == <span class="number">0</span>) &#123;</div><div class="line">            zfree(d-&gt;ht[<span class="number">0</span>].table);</div><div class="line">            d-&gt;ht[<span class="number">0</span>] = d-&gt;ht[<span class="number">1</span>];</div><div class="line">            _dictReset(&amp;d-&gt;ht[<span class="number">1</span>]);</div><div class="line">            d-&gt;rehashidx = <span class="number">-1</span>;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 确保 rehashidx 没有越界</span></div><div class="line">        assert(d-&gt;ht[<span class="number">0</span>].size &gt; (<span class="keyword">unsigned</span>)d-&gt;rehashidx);</div><div class="line">        <span class="comment">// 略过数组中为空的索引，找到下一个非空索引</span></div><div class="line">        <span class="keyword">while</span>(d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx] == <span class="literal">NULL</span>) d-&gt;rehashidx++;</div><div class="line">        <span class="comment">// 指向该索引的链表表头节点</span></div><div class="line">        de = d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx];</div><div class="line">        <span class="comment">// 将链表中的所有节点迁移到新哈希表</span></div><div class="line">        <span class="keyword">while</span>(de) &#123;</div><div class="line">            <span class="keyword">unsigned</span> <span class="keyword">int</span> h;</div><div class="line">            <span class="comment">// 保存下个节点的指针</span></div><div class="line">            nextde = de-&gt;next;</div><div class="line">            <span class="comment">// 计算新哈希表的哈希值，以及节点插入的索引位置</span></div><div class="line">            h = dictHashKey(d, de-&gt;key) &amp; d-&gt;ht[<span class="number">1</span>].sizemask;</div><div class="line">            <span class="comment">// 插入节点到新哈希表</span></div><div class="line">            de-&gt;next = d-&gt;ht[<span class="number">1</span>].table[h];</div><div class="line">            d-&gt;ht[<span class="number">1</span>].table[h] = de;</div><div class="line">            <span class="comment">// 更新计数器</span></div><div class="line">            d-&gt;ht[<span class="number">0</span>].used--;</div><div class="line">            d-&gt;ht[<span class="number">1</span>].used++;</div><div class="line"></div><div class="line">            de = nextde;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 将刚迁移完的哈希表索引的指针设为空</span></div><div class="line">        d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx] = <span class="literal">NULL</span>;</div><div class="line">        <span class="comment">// 更新 rehash 索引</span></div><div class="line">        d-&gt;rehashidx++;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>那么什么时候执行 Rehash 的操作呢？Redis 定义了两个进行渐进式操作的时机：</p>
<ul>
<li>在哈希表被使用的同时，例如对哈希表进行查询或修改，执行 n = 1 的 dictRehash 操作，即调用 _dictRehashStep</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> _dictRehashStep(dict *d) &#123;</div><div class="line">    <span class="keyword">if</span> (d-&gt;iterators == <span class="number">0</span>) dictRehash(d,<span class="number">1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>如果哈希表长时间没有被使用，同样也需要将 rehash 操作进行下去，dictRehashMilliseconds 函数在指定时间内（10ms）以 100 次为单位进行 dictRehash 操作</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictRehashMilliseconds</span><span class="params">(dict *d, <span class="keyword">int</span> ms)</span> </span>&#123;</div><div class="line">    <span class="comment">// 记录开始时间</span></div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> start = timeInMilliseconds();</div><div class="line">    <span class="keyword">int</span> rehashes = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span>(dictRehash(d,<span class="number">100</span>)) &#123;</div><div class="line">        rehashes += <span class="number">100</span>;</div><div class="line">        <span class="comment">// 如果时间已过，跳出</span></div><div class="line">        <span class="keyword">if</span> (timeInMilliseconds()-start &gt; ms) <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> rehashes;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Rehash-执行期间的哈希表使用"><a href="#Rehash-执行期间的哈希表使用" class="headerlink" title="Rehash 执行期间的哈希表使用"></a>Rehash 执行期间的哈希表使用</h3><p>在字典进行 Rehash 的过程中，两个哈希表 ht[0] 和 ht[1] 同时存在并且被使用。因此，所有的查找、更新和删除都需要在两个哈希表上同时进行（先在 ht[0] 上进行操作，如果没有对应的目标，则在 ht[1] 上继续进行）。而增加操作只在 ht[1] 上进行，随着渐进式的迁移操作，ht[0] 表中的节点会越来越少，直到所有的节点都进入 ht[1]，rehash就完成了。</p>
<h2 id="哈希表的迭代器"><a href="#哈希表的迭代器" class="headerlink" title="哈希表的迭代器"></a>哈希表的迭代器</h2><p>迭代器的结构定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictIterator</span> &#123;</span></div><div class="line"></div><div class="line">    <span class="comment">// 被迭代的字典</span></div><div class="line">    dict *d;</div><div class="line">    <span class="comment">// table ：正在被迭代的哈希表号码，值可以是 0 或 1 。</span></div><div class="line">    <span class="comment">// index ：迭代器当前所指向的哈希表索引位置。</span></div><div class="line">    <span class="comment">// safe ：标识这个迭代器是否安全</span></div><div class="line">    <span class="keyword">int</span> table, index, safe;</div><div class="line">    <span class="comment">// entry ：当前迭代到的节点的指针</span></div><div class="line">    <span class="comment">// nextEntry ：当前迭代节点的下一个节点</span></div><div class="line">    <span class="comment">//             因为在安全迭代器运作时， entry 所指向的节点可能会被修改，</span></div><div class="line">    <span class="comment">//             所以需要一个额外的指针来保存下一节点的位置，</span></div><div class="line">    <span class="comment">//             从而防止指针丢失</span></div><div class="line">    dictEntry *entry, *nextEntry;</div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> fingerprint;</div><div class="line">&#125; dictIterator;</div></pre></td></tr></table></figure>
<p>Redis 的哈希表的迭代器按照是否 Rehash 安全分为两种，由 safe 字段进行标注。当 Rehash 安全的迭代器存在的时候，将不会进行单步的 Rehash，即在 _dictRehashStep 函数中先判断字典是否存在使用中的安全迭代器，不存在时才会进行 dictRehash。但是对于定时执行的情况，我没有找到在代码中保证在有安全迭代器时不进行 dictRehash 的判断，或许需要阅读更多的代码才能进行判断。<br>此外，由于迭代器返回以后可能会将迭代器当前指针对应的节点删除，所以还需要保存后续节点指针。而fingerprint 是使用 Thomas Wang 64bits 哈希算法在创建不安全迭代器时生成的指纹，用于在迭代器释放的时候判断在该迭代器在执行的过程中哈希表是否发生了变化。<br>为什么需要设置这两类迭代器呢？主要针对进行迭代的哈希表是否是可变的。由于在安全迭代器运行的期间不能执行 Rehash 操作，因此会影响性能，在对不可变的哈希表进行迭代操作时（例如 Redis 利用子线程进行 dump 操作），就可以使用不安全的迭代器。</p>
<h2 id="Scan-操作"><a href="#Scan-操作" class="headerlink" title="Scan 操作"></a>Scan 操作</h2><p>由于整体的数据设计，Redis 没有办法提供特别准确的 Scan 操作，它的特点是：</p>
<ul>
<li>提供键空间的遍历操作，支持游标，遍历一遍值需要 O(N) 的时间复杂度</li>
<li>无法提供完整的快照遍历，也就是中间如果有数据修改，可能有些涉及改动的数据遍历不到</li>
<li>每次返回的数据条数不一定，极度依赖内部实现</li>
<li>返回的数据可能有重复，应用层必须能够处理重入逻辑</li>
</ul>
<p>整个 Scan 操作的算法比较让人费解，我找到了一个写得比较好的博客，直接在这里转载一下，有兴趣的可以直接看，这里就不做过多的解释了：<a href="http://chenzhenianqing.cn/articles/1101.html" target="_blank" rel="external">http://chenzhenianqing.cn/articles/1101.html</a></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://redisbook.readthedocs.io/en/latest/internal-datastruct/dict.html" target="_blank" rel="external">Redis 设计与实现 - 字典</a></li>
<li><a href="http://www.tuicool.com/articles/3eeIJrR" target="_blank" rel="external">Redis的字典(dict)rehash过程源码解析</a></li>
<li><a href="http://chenzhenianqing.cn/articles/1090.html" target="_blank" rel="external">Redis Scan迭代器遍历操作原理（一）– 基础</a></li>
<li><a href="http://chenzhenianqing.cn/articles/1101.html" target="_blank" rel="external">Redis Scan迭代器遍历操作原理（二）– dictScan反向二进制迭代器</a></li>
<li><a href="http://stackoverflow.com/questions/9223397/whats-the-difference-of-safe-non-safe-dict-itereator-in-redis-dict-implementat" target="_blank" rel="external">what’s the difference of safe/non-safe dict itereator in redis’ dict implementation?</a></li>
<li><a href="http://github.thinkingbar.com/redisbook_chapter01/" target="_blank" rel="external">Redis设计与实现（一）内部数据结构</a></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/10/16/integer_hash_function/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="柿子">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柿子的果盘">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/10/16/integer_hash_function/" itemprop="url">整数哈希函数</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-10-16T00:00:00+08:00">
                2016-10-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/翻译/" itemprop="url" rel="index">
                    <span itemprop="name">翻译</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在阅读 Redis Hash 源代码的过程中，看到一些整数的哈希函数，以前没有接触过，所以拜读了一下 Thomas Wang 写的文章，顺手翻译一下。 由于我对整个文章内容还没有完全理解，当前的翻译还有些不够通畅，等到查阅更多资料以后再进行修订。附上原文：<a href="http://web.archive.org/web/20071223173210/http://www.concentric.net/~Ttwang/tech/inthash.htm。" target="_blank" rel="external">http://web.archive.org/web/20071223173210/http://www.concentric.net/~Ttwang/tech/inthash.htm。</a></p>
<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>整数哈希函数是指以一个整数作为输入值，经过哈希变换以后得到一个整数作为输出值，所有通过这个函数得到的输出值具有均匀的分布。在这篇文章里，我们将讨论这个整数哈希函数的构造过程。</p>
<h3 id="导论"><a href="#导论" class="headerlink" title="导论"></a>导论</h3><p>哈希表是一种重要的数据结构。在所有介绍基础数据结构的书籍中都包含了哈希表的一些算法。但是，这些书籍中讨论的哈希算法总是适合某些特定的场景，导致这些算法在实际使用的过程中性能低下。<br>众所周知，整数的哈希函数是哈希函数中最基本的一种形式。它将一个整型的输入值进行哈希转换以后，得到一个整型的结果。对于这样的哈希函数，得到的输出值的分布必须是均匀的。这意味着，当输入值经过变换以后映射到不同的哈希桶的地址时，所有的哈希桶有相同的概率被映射。此外，相似的输入值应该被哈希变换得到差异比较大的输出值；并且希望，输入值一个 bit 位的变化，会造成输出值所有的 bit 位的变化。</p>
<h3 id="哈希函数构造原则"><a href="#哈希函数构造原则" class="headerlink" title="哈希函数构造原则"></a>哈希函数构造原则</h3><p>一个设计优良的哈希函数必须是可逆的。如果存在 h(x) -&gt; y，h(x) 的输入值的字长与输出值一样，且 h() 是可逆的，那么：</p>
<ol>
<li>如果 h(x1) == y1，那么存在 h_inverse(y1) == x1</li>
<li>因为逆函数存在，所以不存在 x2 使得 x1 != x2 且 h(x2)</li>
</ol>
<p>h(x1) == y1 且 h(x2) == y1 的情形被称为冲突，使用可逆的哈希函数将避免这样的情况。所有的输入值和输出值将一一对应。<br>此外，这个函数需要通过一系列的计算和变换造成“雪崩效应”。雪崩效应表示在输入值上产生了一个 bit 位的变化，将导致输出值在约一半的 bit 位上发生变化，这个新的值将在这一系列的计算中产生。<br>例如，运算 a = a + b 是可逆的，如果我们知道 b 的数值和计算后 a 的数值，那么我们就可以通过减法运算知道 a 的前值。</p>
<h3 id="Knuth的乘法哈希算法"><a href="#Knuth的乘法哈希算法" class="headerlink" title="Knuth的乘法哈希算法"></a>Knuth的乘法哈希算法</h3><p>在 Knuth 编写的”The Art of Computer Programming”（计算机程序设计艺术）一书的 6.4 部分，介绍了一种通过乘法的方式获得哈希函数的方法。用 2^32 的黄金分割（2654435761）乘以输入值来获取输出值。<br>由于 2654435761 和 2^32 没有公因子，这个算法产生了一个没有重合的，从输入值到输出值的完全映射。这个算法对于输入值较小的情况有比较好的哈希效果，但是对于输入值较大时的处理并不是很理想。因为对于所有基于乘法的哈希方法，对于输入值高位的 bit 值的改变，将无法造成输出值低位的 bit 值发生变化。</p>
<h3 id="Robert-Jenkin-的-96bit-杂凑函数"><a href="#Robert-Jenkin-的-96bit-杂凑函数" class="headerlink" title="Robert Jenkin 的 96bit 杂凑函数"></a>Robert Jenkin 的 96bit 杂凑函数</h3><p>Robert Jenkin 发明了一个基于减法、按位异或和位移的哈希函数。<br>本文中所有的源代码是按照 Java 的语法编写的，操作符 ‘&gt;&gt;&gt;’ 表示无符号向右位移。如果要把源代码转成 C 语言，那么需要用 ‘uint32_t’ 替换 int，用 ‘uint64_t’ 替换 long。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">mix</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span></div><div class="line">&#123;</div><div class="line">  a=a-b;  a=a-c;  a=a^(c &gt;&gt;&gt; <span class="number">13</span>);</div><div class="line">  b=b-c;  b=b-a;  b=b^(a &lt;&lt; <span class="number">8</span>);</div><div class="line">  c=c-a;  c=c-b;  c=c^(b &gt;&gt;&gt; <span class="number">13</span>);</div><div class="line">  a=a-b;  a=a-c;  a=a^(c &gt;&gt;&gt; <span class="number">12</span>);</div><div class="line">  b=b-c;  b=b-a;  b=b^(a &lt;&lt; <span class="number">16</span>);</div><div class="line">  c=c-a;  c=c-b;  c=c^(b &gt;&gt;&gt; <span class="number">5</span>);</div><div class="line">  a=a-b;  a=a-c;  a=a^(c &gt;&gt;&gt; <span class="number">3</span>);</div><div class="line">  b=b-c;  b=b-a;  b=b^(a &lt;&lt; <span class="number">10</span>);</div><div class="line">  c=c-a;  c=c-b;  c=c^(b &gt;&gt;&gt; <span class="number">15</span>);</div><div class="line">  <span class="keyword">return</span> c;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>变量 ‘c’ 是输入值，当杂凑结束以后，又是输出值。变量 ‘a’ 和 ‘b’ 是两个经过初始化的一位随机 bit 位。注意到，在内部计算过程中产生的中间结果是 96bits 的，远远大于输出值的 32bits。同样注意到从变量 ‘a’ 到变量 ‘c’ 的三次减法运算。每一列作用于其中一个变量，通过位移操作，将另外两个变量的信息混入。<br>与乘法算法类似，减法也无法将输入值中高位的 bit 值变化反应到输出值的低位 bit 值中。在 Robert Jenkin 算法中的 9 次位移操作，将输入值向右位移了总计 61bits，向左位移了总计 34bits。由于上述所有的运算会连续作用在输入值上，每一个异或操作将会使产生的可能状态倍增。通过这些不同的位移操作，将会至少产生 2^9 种不同的状态。这也是为什么输入值中 1 个 bit 的变化会导致在输出值中那么多位的变化。<br>另一方面，减法的特性保证了这个哈希函数的均匀分布。观察输入值和随机 bit 的单位减法运算。如果随机 bit 是0，则输入值保持不变，否则所有输入值中所有的 bit 都将翻转（1变为0，0变为1）。因为只有当输入值和随机 bit 位都为 1 时才会产生进位。将输入值减掉随机 bit 将会导致大约一半的输入值的 bit 发生翻转。所以即使输入值不是均匀的，通过与随机 bit 进行减法运算也会得到一个分布均匀的结果。</p>
<h3 id="32bit-杂凑函数"><a href="#32bit-杂凑函数" class="headerlink" title="32bit 杂凑函数"></a>32bit 杂凑函数</h3><p>基于 Robert Jenkin 在1997年提出的一个想法，我进行了相关的研究，并完成了一个整数的哈希函数。如下是我在2007年一月提出的最新版本。在函数中使用的常数是通过运行相关的搜索程序获得的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hash32shift</span><span class="params">(<span class="keyword">int</span> key)</span></span></div><div class="line">&#123;</div><div class="line">  key = ~key + (key &lt;&lt; <span class="number">15</span>); <span class="comment">// key = (key &lt;&lt; 15) - key - 1;</span></div><div class="line">  key = key ^ (key &gt;&gt;&gt; <span class="number">12</span>);</div><div class="line">  key = key + (key &lt;&lt; <span class="number">2</span>);</div><div class="line">  key = key ^ (key &gt;&gt;&gt; <span class="number">4</span>);</div><div class="line">  key = key * <span class="number">2057</span>; <span class="comment">// key = (key + (key &lt;&lt; 3)) + (key &lt;&lt; 11);</span></div><div class="line">  key = key ^ (key &gt;&gt;&gt; <span class="number">16</span>);</div><div class="line">  <span class="keyword">return</span> key;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在补码表示下，(~x) + y 等价于 y - x - 1。<br>通过使用机器原生指令 ‘加补码’ 和 ‘位移 加’，上述的哈希函数可以在 HP9000 工作站上仅使用 11 个时钟周期完成。<br>通过多次的计算会增强输出值的随机性，但是同样会降低算法的性能。通过模拟运算发现，尽量在中间的计算中使用较小的位移数操作，而在前后的计算中使用较大的位移数操作是比较好的选择。</p>
<h3 id="Robert-Jenkin-的-32bit-整数哈希函数"><a href="#Robert-Jenkin-的-32bit-整数哈希函数" class="headerlink" title="Robert Jenkin 的 32bit 整数哈希函数"></a>Robert Jenkin 的 32bit 整数哈希函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">uint32_t</span> hash( <span class="keyword">uint32_t</span> a)</div><div class="line">&#123;</div><div class="line">   a = (a+<span class="number">0x7ed55d16</span>) + (a&lt;&lt;<span class="number">12</span>);</div><div class="line">   a = (a^<span class="number">0xc761c23c</span>) ^ (a&gt;&gt;<span class="number">19</span>);</div><div class="line">   a = (a+<span class="number">0x165667b1</span>) + (a&lt;&lt;<span class="number">5</span>);</div><div class="line">   a = (a+<span class="number">0xd3a2646c</span>) ^ (a&lt;&lt;<span class="number">9</span>);</div><div class="line">   a = (a+<span class="number">0xfd7046c5</span>) + (a&lt;&lt;<span class="number">3</span>);</div><div class="line">   a = (a^<span class="number">0xb55a4f09</span>) ^ (a&gt;&gt;<span class="number">16</span>);</div><div class="line">   <span class="keyword">return</span> a;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个版本的整数哈希函数通过操作一些整数常数来辅助获得哈希值。我怀疑这些常数值的具体数值并没有对整个哈希过程产生特别重要的影响，即使使用 16bits 的常数，也依然可以产生很好的效果。<br>但是这些常数对于获得一个完美的整数哈希函数还是有一定意义的。一个测试函数可以不断改变这些常数值来获得一个完美的整数哈希函数。</p>
<h3 id="使用乘法来进行哈希"><a href="#使用乘法来进行哈希" class="headerlink" title="使用乘法来进行哈希"></a>使用乘法来进行哈希</h3><p>如果使用乘法来进行哈希过程，则需要一个机制将输入值的高位变化反应在输出值的低位上。bit 翻转是最佳的选择，但是实现起来比较慢。一个可行的替代方案是向左位移操作。<br>使用乘法进行哈希会陷入一些困境。一些硬件平台在硬件层面上支持整数的乘法操作，这样使得一次的乘法可以在 4 个或者更少的时钟周期里完成；但是对于另外的一些硬件平台而言，需要耗费 8 个或者更多的时钟周期。而另外一方面，通过位移操作实现的哈希过程可以在所有的平台上都有良好的表现。<br>一个折中的方案是将输入值乘以一个 bit 位稀疏的值，这样在乘法操作比较慢的硬件平台上，就可以通过 “位移 加” 操作来进行替代。例如乘数设置为 (4096 + 8 + 1)，对应的位移表达式为 (key + (key &lt;&lt; 3)) + (key &lt;&lt; 12)。<br>在几乎所有的机器上，一个 3bits 的位移加上一个加法运算可以在一个时钟周期里完成。例如，奔腾指令集中的 ‘lea’ 指令可以在一个时钟周期里实现 “位移 加” 操作。<br>函数 hash32shiftmult() 使用一个位移操作和乘法运算的组合来对输入值进行哈希操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hash32shiftmult</span><span class="params">(<span class="keyword">int</span> key)</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">int</span> c2=<span class="number">0x27d4eb2d</span>; <span class="comment">// a prime or an odd constant</span></div><div class="line">  key = (key ^ <span class="number">61</span>) ^ (key &gt;&gt;&gt; <span class="number">16</span>);</div><div class="line">  key = key + (key &lt;&lt; <span class="number">3</span>);</div><div class="line">  key = key ^ (key &gt;&gt;&gt; <span class="number">4</span>);</div><div class="line">  key = key * c2;</div><div class="line">  key = key ^ (key &gt;&gt;&gt; <span class="number">15</span>);</div><div class="line">  <span class="keyword">return</span> key;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="64bit-杂凑函数"><a href="#64bit-杂凑函数" class="headerlink" title="64bit 杂凑函数"></a>64bit 杂凑函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">hash64shift</span><span class="params">(<span class="keyword">long</span> key)</span></span></div><div class="line">&#123;</div><div class="line">  key = (~key) + (key &lt;&lt; <span class="number">21</span>); <span class="comment">// key = (key &lt;&lt; 21) - key - 1;</span></div><div class="line">  key = key ^ (key &gt;&gt;&gt; <span class="number">24</span>);</div><div class="line">  key = (key + (key &lt;&lt; <span class="number">3</span>)) + (key &lt;&lt; <span class="number">8</span>); <span class="comment">// key * 265</span></div><div class="line">  key = key ^ (key &gt;&gt;&gt; <span class="number">14</span>);</div><div class="line">  key = (key + (key &lt;&lt; <span class="number">2</span>)) + (key &lt;&lt; <span class="number">4</span>); <span class="comment">// key * 21</span></div><div class="line">  key = key ^ (key &gt;&gt;&gt; <span class="number">28</span>);</div><div class="line">  key = key + (key &lt;&lt; <span class="number">31</span>);</div><div class="line">  <span class="keyword">return</span> key;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由于 64bits 的位数比较多，所以需要更多的杂凑操作。</p>
<h3 id="64bit-转换为-32bit-哈希函数"><a href="#64bit-转换为-32bit-哈希函数" class="headerlink" title="64bit 转换为 32bit 哈希函数"></a>64bit 转换为 32bit 哈希函数</h3><p>这类哈希函数的一个应用是将一个 64bit 的虚拟地址转为一个哈希表的索引值。由于函数的输出值的位数小于输入值，因此这类哈希函数不再是一一映射。<br>另外一个应用是将两个 32bit 整数转化为一个哈希值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hash6432shift</span><span class="params">(<span class="keyword">long</span> key)</span></span></div><div class="line">&#123;</div><div class="line">  key = (~key) + (key &lt;&lt; <span class="number">18</span>); <span class="comment">// key = (key &lt;&lt; 18) - key - 1;</span></div><div class="line">  key = key ^ (key &gt;&gt;&gt; <span class="number">31</span>);</div><div class="line">  key = key * <span class="number">21</span>; <span class="comment">// key = (key + (key &lt;&lt; 2)) + (key &lt;&lt; 4);</span></div><div class="line">  key = key ^ (key &gt;&gt;&gt; <span class="number">11</span>);</div><div class="line">  key = key + (key &lt;&lt; <span class="number">6</span>);</div><div class="line">  key = key ^ (key &gt;&gt;&gt; <span class="number">22</span>);</div><div class="line">  <span class="keyword">return</span> (<span class="keyword">int</span>) key;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="并行操作"><a href="#并行操作" class="headerlink" title="并行操作"></a>并行操作</h3><p>如果CPU可以在一个时钟周期里同时分发多个指令，那么可以考虑在公式中加入一些并发处理的机制。<br>例如，如下公式中的两个位移操作可以并发执行。但是，如果是一台有多个 ALU，但是只有一个位移单元的机器上，这样的想法并不能提高速度。</p>
<p>key ^= (key &lt;&lt; 17) | (key &gt;&gt;&gt; 16);</p>
<p>对于 32bit 位宽的操作，只有一些位移对才是可逆的。这些位移对是：(17,16) (16,17) (14,19) (19,14) (13,20) (20,13) (10,23) (23,10) (8,25) (25,8)<br>乘法运算可以并发执行，所有的奇数乘法运算都是可逆的。</p>
<p>key += (key &lt;&lt; 3) + (key &lt;&lt; 9); // key = key * (1 + 8 + 512)</p>
<p>对于一些特定的机器，bit 翻转操作可以在一个时钟周期里完成。对于所有的奇数个 bit 翻转，只要对于非翻转的 bit 位与 1 或 0 进行异或操作，这样的操作是可逆的。</p>
<p>key = (key | 64) ^ ((key &gt;&gt;&gt; 15) | (key &lt;&lt; 17));</p>
<p>然而，对于其它的一些机器或者编译器，运行这些代码可能会需要 4 个时钟周期。</p>
<h3 id="使用伪随机"><a href="#使用伪随机" class="headerlink" title="使用伪随机"></a>使用伪随机</h3><p>有一些关于这些杂凑函数是否可以用于伪随机过程的疑问。尽管上述的哈希过程看起来像是随机的，但是官方的建议是使用一个真正的伪随机数生成器来进行这个过程，例如 <a href="http://web.archive.org/web/20071223173210/http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/emt.html" target="_blank" rel="external">Mercenne Twister</a>。<br>所有在本文中出现的哈希函数都只进行了哈希相关的测试，并没有进行随机性的测试。</p>
<h3 id="测试程序"><a href="#测试程序" class="headerlink" title="测试程序"></a>测试程序</h3><p><a href="http://web.archive.org/web/20071214220545/http://www.concentric.net/~Ttwang/tech/testchange.java" target="_blank" rel="external">测试程序</a>对不同的位移操作的量进行了雪崩效应的测试。这个程序检测了不同的 bit 位的值上是否发生了变化，保证了对于所有的输入值而言，这些位移量能够产生约 50% 左右的 bit 位的值发生变化。<br>这个测试程序打印出了所有的经过测试的算法的名字，以及经过了雪崩效应测试的参数值。</p>
<h3 id="2次幂哈希表大小"><a href="#2次幂哈希表大小" class="headerlink" title="2次幂哈希表大小"></a>2次幂哈希表大小</h3><p>因为 2 的次幂在计算机中计算速度快，因此程序员通常使用 2 的次幂作为哈希表的大小。整数哈希函数可以用于将主哈希过程获得的输出值映射到实际的存储地址。</p>
<p>addr = inthash(marginal_hash_value) &amp; (tablesize - 1);</p>
<p>使用内置的整数哈希函数比对一个质数进行取余操作更快。一次的整数取余操作需要花费 18 个时钟周期甚至更多，主要取决于硬件平台的架构。</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>在这篇文章中，我们讨论了一系列整数相关的哈希函数。Knuth 的乘法方法最简单，但是有一些已知的缺点。Robert Jenkins 的 96bits 杂凑函数可以作为整数哈希函数使用，只是对于比较大的输入值更适用。本文还介绍了一个专门用于整数哈希的函数。<br>此外，我们还在文章中介绍了一个用于优化哈希值的应用程序。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/10/15/redis_list/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="柿子">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柿子的果盘">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/10/15/redis_list/" itemprop="url">Redis数据结构: 双端链表</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-10-15T00:00:00+08:00">
                2016-10-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/开源项目/" itemprop="url" rel="index">
                    <span itemprop="name">开源项目</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>链表是一种常用的数据结构，在很多的编程语言，例如 C++ 里都有现成的容器可以使用，除了 Redis 使用的 C 语言。因此，在 Redis 中，作者自己实现了一个双端链表的结构，在这个结构中，保存了头节点，尾节点和长度，这样可以很方便地从两端进行链表的遍历，也可以用 O(1) 的时间复杂度获得链表的长度。</p>
<p>链表的结构在 adlist.h 中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> &#123;</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span>    <span class="comment">// 前置节点</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span>    <span class="comment">// 后继节点</span></div><div class="line">    <span class="keyword">void</span> *value;              <span class="comment">// 节点的值</span></div><div class="line">&#125; listNode;</div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span></div><div class="line">    listNode *head;           <span class="comment">// 表头节点</span></div><div class="line">    listNode *tail;           <span class="comment">// 表尾节点</span></div><div class="line">    <span class="keyword">void</span> *(*dup)(<span class="keyword">void</span> *ptr);  <span class="comment">// 节点值复制函数</span></div><div class="line">    <span class="keyword">void</span> (*<span class="built_in">free</span>)(<span class="keyword">void</span> *ptr);  <span class="comment">// 节点值释放函数</span></div><div class="line">    <span class="keyword">int</span> (*match)(<span class="keyword">void</span> *ptr, <span class="keyword">void</span> *key);  <span class="comment">// 节点值对比函数</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;        <span class="comment">// 链表所包含的节点数量</span></div><div class="line">&#125; <span class="built_in">list</span>;</div></pre></td></tr></table></figure>
<p>在上述的结构中，链表的值使用 void* 指针来保存节点的值，而节点的值通过三个属性保存的函数来进行节点值的复制、比较和释放，这样实现了链表的多态。<br>另外，需要注意的是，表头节点的前置节点和表尾节点的后继节点都指向 NULL，意味着这个链表是无环的。</p>
<p>由于双端链表可以由两个方向进行遍历，所以实现的迭代器中也包含了方向：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 从表头向表尾进行迭代</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> AL_START_HEAD 0</span></div><div class="line"><span class="comment">// 从表尾到表头进行迭代</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> AL_START_TAIL 1</span></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listIter</span> &#123;</span></div><div class="line">    listNode *next;           <span class="comment">// 当前迭代到的节点</span></div><div class="line">    <span class="keyword">int</span> direction;            <span class="comment">// 迭代的方向</span></div><div class="line">&#125; listIter;</div></pre></td></tr></table></figure>
<p>由于这个结构比较简单，可以直接阅读 adlist.h 和 adlist.c 中的源代码，不再赘述。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/10/14/redis_sds/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="柿子">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柿子的果盘">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/10/14/redis_sds/" itemprop="url">Redis数据结构: 简单动态字符串</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-10-14T00:00:00+08:00">
                2016-10-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/开源项目/" itemprop="url" rel="index">
                    <span itemprop="name">开源项目</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Redis 是用 C 语言编写的，而 C 语言用空字符（’\0’）结尾的字符数组表示字符串的方式又备受诟病。因此，Redis 的作者自己设计了一个新的结构，命名为简单动态字符串（Simple Dynamic String, SDS）。在 Redis 内部绝大部分需要使用字符串的地方，使用的都是 SDS，除了一些不需要改变的字面量以外，例如打印日志。</p>
<p>Redis 是一个 key-value 类型的数据库，所有的 key 都是字符串。而在 Redis 的各种操作中，会频繁地使用字符串的长度查询和增加字符两种操作。对于原生的 C 字符串而言，长度查询的时间复杂度是 O(N)，而多次的 append 操作则需要频繁地调用 malloc 和 realloc 操作，这些操作的耗时较多。因此，优化这两个操作势在必行。此外，为了在客户端和服务器之间传输，并且可以保存除了文本数据以外的数据格式，因此字符串必须是二进制安全的。这些就是设计 SDS 要考虑的基本因素。由于在具体实现的过程中，使用了一些关于 C 语言的特性，因此我们对照着源代码进行解释。</p>
<h3 id="SDS-结构"><a href="#SDS-结构" class="headerlink" title="SDS 结构"></a>SDS 结构</h3><p>在 sds.h 中可以看到 SDS 的定义，我们可以看到 sds 对应的是字符串数组（与 C 字符串定义一致）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> *sds;</div></pre></td></tr></table></figure>
<p>其后定义了五个 struct（sdshdr5、sdshdr8、sdshdr16、sdshdr32、sdshdr64），它们的结构一样（除了 sdshdr5 以外），包含了四个对应的属性，分别是：</p>
<ul>
<li>len：SDS 保存的字符串的实际长度，不包含最后的空字符</li>
<li>alloc：SDS 用于保存字符串的所有空间的大小，不包括空字符以及 header</li>
<li>flags：低 3 位用于保存字符串对应的 struct，高 5 位只有 sdshdr5 用于保存字符串长度，其它的 struct 没有用到</li>
<li>buf：指向保存的字符串的指针，上面定义的 sds 实际上就是这里的 buf</li>
</ul>
<p>上述除了 buf 以外的三个字段组成了 SDS 的 header，保存了除了字符串内容以外的信息，用于快速实现一些操作，提高字符串操作的效率。<br>注意：sdshdr5 的结构有所不同，它没有 len 和 alloc 两个字段，字符串长度保存在 flags 的高 5 位中，所以最大的值为 31 ，这样的字符串适合于保存较短的不可变字符串。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr5</span> &#123;</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, and 5 msb of string length */</span></div><div class="line">    <span class="keyword">char</span> buf[];</div><div class="line">&#125;;</div><div class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr8</span> &#123;</span></div><div class="line">    <span class="keyword">uint8_t</span> len; <span class="comment">/* used */</span></div><div class="line">    <span class="keyword">uint8_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></div><div class="line">    <span class="keyword">char</span> buf[];</div><div class="line">&#125;;</div><div class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr16</span> &#123;</span></div><div class="line">    <span class="keyword">uint16_t</span> len; <span class="comment">/* used */</span></div><div class="line">    <span class="keyword">uint16_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></div><div class="line">    <span class="keyword">char</span> buf[];</div><div class="line">&#125;;</div><div class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr32</span> &#123;</span></div><div class="line">    <span class="keyword">uint32_t</span> len; <span class="comment">/* used */</span></div><div class="line">    <span class="keyword">uint32_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></div><div class="line">    <span class="keyword">char</span> buf[];</div><div class="line">&#125;;</div><div class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr64</span> &#123;</span></div><div class="line">    <span class="keyword">uint64_t</span> len; <span class="comment">/* used */</span></div><div class="line">    <span class="keyword">uint64_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></div><div class="line">    <span class="keyword">char</span> buf[];</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>与 flags 相关的常量如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* sds 的类型常量，类型存于 flags 的最低 3 位 */</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_5  0</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_8  1</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_16 2</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_32 3</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_64 4</span></div><div class="line"><span class="comment">/* SDS_TYPE_MASK 用来与 flags 配合，获得 sds 的类型，注意 7 的二进制表示是 111，与它进行 &amp; 操作以后能获得最低 3 位的值 */</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_MASK 7</span></div><div class="line"><span class="comment">/* 与 sdshdr5 配合使用，flags 的最低 3 位存储类型，高位用于长度 */</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_BITS 3</span></div></pre></td></tr></table></figure>
<h3 id="使用的-C-语言特性"><a href="#使用的-C-语言特性" class="headerlink" title="使用的 C 语言特性"></a>使用的 C 语言特性</h3><p>在上述 sdshdr 的定义中，用到了 C 语言的几个特性，从而使 SDS 变得比 C 字符串更加灵活：</p>
<ul>
<li>柔性数组（flexible array member）：sdshdr 的 buf 属性并没有指明数组的尺寸，被称为柔性数组，它只是作为一个标记存在在 struct 中，在 sizeof 操作的时候并不计入</li>
<li>Struct Hack：Struct 中有且仅有一个变长的字段，且该字段是 Struct 中最后的一个字段，这样在分配空间的时候，可以直接给这个变长字段分配空间，使得该变长字段的内容和 struct 中其它的字段放在连续的空间中，直接通过该变长变量的指针就可以获得其它的字段。在 sdshdr 的定义中，使用了 Struct Hack，使得只要知道 buf 字段的起始位置指针，就可以推导获得 header 字段的起始位置指针</li>
<li>attribute ((packed))：它的作用就是告诉编译器取消结构在编译过程中的优化对齐，按照实际占用字节数进行对齐，是 GCC 特有的语法。这个功能是跟操作系统没关系，跟编译器有关，GCC 编译器不是紧凑模式的。在 Windows 下，用 VC 的编译器也不是紧凑的，用 TC 的编译器就是紧凑的。例如：<ul>
<li>在 TC 下：struct my{ char ch; int a;} sizeof(int) = 2; sizeof(my) = 3;（紧凑模式）</li>
<li>在 GCC 下：struct my{ char ch; int a;} sizeof(int) = 4; sizeof(my) = 8;（非紧凑模式）</li>
<li>在 GCC 下：struct my{ char ch; int a;}attrubte ((packed)) sizeof(int) = 4; sizeof(my) = 5;（紧凑模式）</li>
</ul>
</li>
</ul>
<p>从上述的解释中，我们可以得知 SDS 设计的主要内容：</p>
<ul>
<li>通过使用 Struct Hack，我们可以将 SDS 的 header 和对应的字符串分配在连续的空间中，然后仅通过字符串指针就可以找到对应的 header</li>
<li>在使用的过程中，直接使用 sds 类型，这个与 C 字符串的使用无异，可以方便的使用 str 的各种库函数，需要 header 的信息的时候，使用额外的操作，找到对应的辅助信息</li>
</ul>
<h3 id="获取-header-的操作"><a href="#获取-header-的操作" class="headerlink" title="获取 header 的操作"></a>获取 header 的操作</h3><p>由于不同的 sdshdr struct 存储 len 和 alloc 的变量类型不同，所以需要先获取类型的信息，而类型存储在 flags 中的第三位，flags 又固定存储在字符串第一个字符的前一个字节，因此，通过 s[-1] &amp; SDS_TYPE_MASK 就可以获得类型的信息，而后通过指针减去 header 的 size，就可以获得 header 的指针，具体如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_HDR(T,s) ((struct sdshdr##T *)((s)-(sizeof(struct sdshdr##T))))</span></div></pre></td></tr></table></figure>
<p>在获得 header 的指针以后，就得到了对应的 struct，就可以取出对应的字段，以 len 为例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> size_t <span class="title">sdslen</span><span class="params">(<span class="keyword">const</span> sds s)</span> </span>&#123;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags = s[<span class="number">-1</span>];</div><div class="line">    <span class="keyword">switch</span>(flags&amp;SDS_TYPE_MASK) &#123;</div><div class="line">        <span class="keyword">case</span> SDS_TYPE_5:</div><div class="line">            <span class="keyword">return</span> SDS_TYPE_5_LEN(flags);</div><div class="line">        <span class="keyword">case</span> SDS_TYPE_8:</div><div class="line">            <span class="keyword">return</span> SDS_HDR(<span class="number">8</span>,s)-&gt;len;</div><div class="line">        <span class="keyword">case</span> SDS_TYPE_16:</div><div class="line">            <span class="keyword">return</span> SDS_HDR(<span class="number">16</span>,s)-&gt;len;</div><div class="line">        <span class="keyword">case</span> SDS_TYPE_32:</div><div class="line">            <span class="keyword">return</span> SDS_HDR(<span class="number">32</span>,s)-&gt;len;</div><div class="line">        <span class="keyword">case</span> SDS_TYPE_64:</div><div class="line">            <span class="keyword">return</span> SDS_HDR(<span class="number">64</span>,s)-&gt;len;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="创建与销毁"><a href="#创建与销毁" class="headerlink" title="创建与销毁"></a>创建与销毁</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">sdsReqType</span><span class="params">(<span class="keyword">size_t</span> string_size)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (string_size &lt; <span class="number">1</span>&lt;&lt;<span class="number">5</span>)</div><div class="line">        <span class="keyword">return</span> SDS_TYPE_5;</div><div class="line">    <span class="keyword">if</span> (string_size &lt; <span class="number">1</span>&lt;&lt;<span class="number">8</span>)</div><div class="line">        <span class="keyword">return</span> SDS_TYPE_8;</div><div class="line">    <span class="keyword">if</span> (string_size &lt; <span class="number">1</span>&lt;&lt;<span class="number">16</span>)</div><div class="line">        <span class="keyword">return</span> SDS_TYPE_16;</div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> (LONG_MAX == LLONG_MAX)</span></div><div class="line">    <span class="keyword">if</span> (string_size &lt; <span class="number">1l</span>l&lt;&lt;<span class="number">32</span>)</div><div class="line">        <span class="keyword">return</span> SDS_TYPE_32;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">    <span class="keyword">return</span> SDS_TYPE_64;</div><div class="line">&#125;</div><div class="line"><span class="function">sds <span class="title">sdsnewlen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *init, <span class="keyword">size_t</span> initlen)</span> </span>&#123;</div><div class="line">    <span class="keyword">void</span> *sh;</div><div class="line">    sds s;</div><div class="line">    <span class="keyword">char</span> type = sdsReqType(initlen);</div><div class="line">    <span class="comment">/* Empty strings are usually created in order to append. Use type 8</span></div><div class="line">     * since type 5 is not good at this.</div><div class="line">     * 如果是空字符串，则使用 SDS_TYPE_8</div><div class="line">     */</div><div class="line">    <span class="keyword">if</span> (type == SDS_TYPE_5 &amp;&amp; initlen == <span class="number">0</span>) type = SDS_TYPE_8;</div><div class="line">    <span class="keyword">int</span> hdrlen = sdsHdrSize(type);</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *fp; <span class="comment">/* flags pointer. */</span></div><div class="line">    <span class="comment">// 使用 Struct Hack，同时分配 header 和 buf 的空间，最后加上的 1 是给空字符留的空间</span></div><div class="line">    sh = s_malloc(hdrlen+initlen+<span class="number">1</span>);</div><div class="line">    <span class="keyword">if</span> (!init)</div><div class="line">        <span class="built_in">memset</span>(sh, <span class="number">0</span>, hdrlen+initlen+<span class="number">1</span>);</div><div class="line">    <span class="keyword">if</span> (sh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 找到 buf 的起始位置，以及 flags 的位置</span></div><div class="line">    s = (<span class="keyword">char</span>*)sh+hdrlen;</div><div class="line">    fp = ((<span class="keyword">unsigned</span> <span class="keyword">char</span>*)s)<span class="number">-1</span>;</div><div class="line">    <span class="comment">// 设置 header</span></div><div class="line">    <span class="keyword">switch</span>(type) &#123;</div><div class="line">        <span class="keyword">case</span> SDS_TYPE_5: &#123;</div><div class="line">            *fp = type | (initlen &lt;&lt; SDS_TYPE_BITS);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">case</span> SDS_TYPE_8: &#123;</div><div class="line">            SDS_HDR_VAR(<span class="number">8</span>,s);</div><div class="line">            sh-&gt;len = initlen;</div><div class="line">            sh-&gt;alloc = initlen;</div><div class="line">            *fp = type;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">case</span> SDS_TYPE_16: &#123;</div><div class="line">            SDS_HDR_VAR(<span class="number">16</span>,s);</div><div class="line">            sh-&gt;len = initlen;</div><div class="line">            sh-&gt;alloc = initlen;</div><div class="line">            *fp = type;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">case</span> SDS_TYPE_32: &#123;</div><div class="line">            SDS_HDR_VAR(<span class="number">32</span>,s);</div><div class="line">            sh-&gt;len = initlen;</div><div class="line">            sh-&gt;alloc = initlen;</div><div class="line">            *fp = type;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">case</span> SDS_TYPE_64: &#123;</div><div class="line">            SDS_HDR_VAR(<span class="number">64</span>,s);</div><div class="line">            sh-&gt;len = initlen;</div><div class="line">            sh-&gt;alloc = initlen;</div><div class="line">            *fp = type;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 拷贝存储在 init 中的字符串</span></div><div class="line">    <span class="keyword">if</span> (initlen &amp;&amp; init)</div><div class="line">        <span class="built_in">memcpy</span>(s, init, initlen);</div><div class="line"></div><div class="line">    <span class="comment">// 在最后加上 空字符</span></div><div class="line">    s[initlen] = <span class="string">'\0'</span>;</div><div class="line">    <span class="comment">// 返回 buf 的指针</span></div><div class="line">    <span class="keyword">return</span> s;</div><div class="line">&#125;</div><div class="line"><span class="function">sds <span class="title">sdsempty</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> sdsnewlen(<span class="string">""</span>,<span class="number">0</span>);</div><div class="line">&#125;</div><div class="line"><span class="function">sds <span class="title">sdsnew</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *init)</span> </span>&#123;</div><div class="line">    <span class="keyword">size_t</span> initlen = (init == <span class="literal">NULL</span>) ? <span class="number">0</span> : <span class="built_in">strlen</span>(init);</div><div class="line">    <span class="keyword">return</span> sdsnewlen(init, initlen);</div><div class="line">&#125;</div><div class="line"><span class="function">sds <span class="title">sdsdup</span><span class="params">(<span class="keyword">const</span> sds s)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> sdsnewlen(s, sdslen(s));</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsfree</span><span class="params">(sds s)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span>) <span class="keyword">return</span>;</div><div class="line">    s_free((<span class="keyword">char</span>*)s-sdsHdrSize(s[<span class="number">-1</span>]));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>无论是何种方式进行创建，底层都是通过调用 sdsnewlen 函数来完成的，值得注意的是：</p>
<ul>
<li>通过对于初始字符串的长度判断，可以获得对应的 struct 类型，这个是创建 SDS header 的基础</li>
<li>若是空字符串，将使用 sdshdr8 而不是 sdshdr5 来进行创建，因为 sdshdr5 里没有活动的可用空间，不利于后续的拓展</li>
<li>与 C 字符串一样，SDS 会在创建的新字符串的末尾自动地添加空字符（’\0’）</li>
</ul>
<p>由于添加了空字符，因此，SDS 在将字符串进行截短或者是清除的时候，只需要调整 header 中的信息以及空字符的位置，而不用处理原先字符串的内容：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsclear</span><span class="params">(sds s)</span> </span>&#123;</div><div class="line">    sdssetlen(s, <span class="number">0</span>);</div><div class="line">    s[<span class="number">0</span>] = <span class="string">'\0'</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="连接（追加）字符串操作"><a href="#连接（追加）字符串操作" class="headerlink" title="连接（追加）字符串操作"></a>连接（追加）字符串操作</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div></pre></td><td class="code"><pre><div class="line"><span class="function">sds <span class="title">sdsMakeRoomFor</span><span class="params">(sds s, <span class="keyword">size_t</span> addlen)</span> </span>&#123;</div><div class="line">    <span class="keyword">void</span> *sh, *newsh;</div><div class="line">    <span class="keyword">size_t</span> avail = sdsavail(s);</div><div class="line">    <span class="keyword">size_t</span> len, newlen;</div><div class="line">    <span class="keyword">char</span> type, oldtype = s[<span class="number">-1</span>] &amp; SDS_TYPE_MASK;</div><div class="line">    <span class="keyword">int</span> hdrlen;</div><div class="line">    <span class="comment">/* Return ASAP if there is enough space left.</span></div><div class="line">     * 如果已经有足够空间了，直接返回</div><div class="line">     */</div><div class="line">    <span class="keyword">if</span> (avail &gt;= addlen) <span class="keyword">return</span> s;</div><div class="line">    len = sdslen(s);</div><div class="line">    sh = (<span class="keyword">char</span>*)s-sdsHdrSize(oldtype);</div><div class="line">    <span class="comment">// 设定新的长度，以及对应的类型</span></div><div class="line">    newlen = (len+addlen);</div><div class="line">    <span class="keyword">if</span> (newlen &lt; SDS_MAX_PREALLOC)</div><div class="line">        newlen *= <span class="number">2</span>;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        newlen += SDS_MAX_PREALLOC;</div><div class="line">    type = sdsReqType(newlen);</div><div class="line">    <span class="comment">/* Don't use type 5: the user is appending to the string and type 5 is</span></div><div class="line">     * not able to remember empty space, so sdsMakeRoomFor() must be called</div><div class="line">     * at every appending operation.</div><div class="line">     * SDS_TYPE_5 没有办法保存空闲的空间长度，所以在拓展的时候避免使用它</div><div class="line">     */</div><div class="line">    <span class="keyword">if</span> (type == SDS_TYPE_5) type = SDS_TYPE_8;</div><div class="line">    hdrlen = sdsHdrSize(type);</div><div class="line">    <span class="keyword">if</span> (oldtype==type) &#123;</div><div class="line">        newsh = s_realloc(sh, hdrlen+newlen+<span class="number">1</span>);</div><div class="line">        <span class="keyword">if</span> (newsh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">        s = (<span class="keyword">char</span>*)newsh+hdrlen;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">/* Since the header size changes, need to move the string forward,</span></div><div class="line">         * and can't use realloc</div><div class="line">         * 当长度改变以后，没有办法直接使用 realloc，因为 header 的长度也发生变化了</div><div class="line">         */</div><div class="line">        newsh = s_malloc(hdrlen+newlen+<span class="number">1</span>);</div><div class="line">        <span class="keyword">if</span> (newsh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">        <span class="built_in">memcpy</span>((<span class="keyword">char</span>*)newsh+hdrlen, s, len+<span class="number">1</span>);</div><div class="line">        s_free(sh);</div><div class="line">        s = (<span class="keyword">char</span>*)newsh+hdrlen;</div><div class="line">        s[<span class="number">-1</span>] = type;</div><div class="line">        sdssetlen(s, len);</div><div class="line">    &#125;</div><div class="line">    sdssetalloc(s, newlen);</div><div class="line">    <span class="keyword">return</span> s;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">sdssetlen</span><span class="params">(sds s, <span class="keyword">size_t</span> newlen)</span> </span>&#123;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags = s[<span class="number">-1</span>];</div><div class="line">    <span class="keyword">switch</span>(flags&amp;SDS_TYPE_MASK) &#123;</div><div class="line">        <span class="keyword">case</span> SDS_TYPE_5:</div><div class="line">            &#123;</div><div class="line">                <span class="comment">/* 直接将长度设置到 flags 字段的高 5 位 */</span></div><div class="line">                <span class="keyword">unsigned</span> <span class="keyword">char</span> *fp = ((<span class="keyword">unsigned</span> <span class="keyword">char</span>*)s)<span class="number">-1</span>;</div><div class="line">                *fp = SDS_TYPE_5 | (newlen &lt;&lt; SDS_TYPE_BITS);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> SDS_TYPE_8:</div><div class="line">            SDS_HDR(<span class="number">8</span>,s)-&gt;len = newlen;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> SDS_TYPE_16:</div><div class="line">            SDS_HDR(<span class="number">16</span>,s)-&gt;len = newlen;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> SDS_TYPE_32:</div><div class="line">            SDS_HDR(<span class="number">32</span>,s)-&gt;len = newlen;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> SDS_TYPE_64:</div><div class="line">            SDS_HDR(<span class="number">64</span>,s)-&gt;len = newlen;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="function">sds <span class="title">sdscatlen</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">void</span> *t, <span class="keyword">size_t</span> len)</span> </span>&#123;</div><div class="line">    <span class="keyword">size_t</span> curlen = sdslen(s);</div><div class="line">    s = sdsMakeRoomFor(s,len);</div><div class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">    <span class="built_in">memcpy</span>(s+curlen, t, len);</div><div class="line">    sdssetlen(s, curlen+len);</div><div class="line">    s[curlen+len] = <span class="string">'\0'</span>;</div><div class="line">    <span class="keyword">return</span> s;</div><div class="line">&#125;</div><div class="line"><span class="function">sds <span class="title">sdscat</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *t)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> sdscatlen(s, t, <span class="built_in">strlen</span>(t));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，sdscat 操作底层是通过 sdscatLen 实现的，它主要分为如下几个步骤：</p>
<ul>
<li>检查剩余的空间是否足够，如果不够的话需要分配新的空间，在 sdsMakeRoomFor 函数里完成</li>
<li>将需要追加的字符串拷贝入新的空间中</li>
<li>更新字符串长度</li>
</ul>
<p>值得注意的是，在追加了新的字符串以后，SDS header的长度可能发生变化，例如 sdshdr8 类型的 SDS 追加了字符串以后变成了 sdshdr16 类型，这时候 header 增加了 2 个字节，这时候需要使用 realloc 重新分配空间，SDS 的指针就会随之发生变化。所以，所有改变 SDS 内容的操作都需要注意，操作前的 SDS 指针在操作完成以后不一定可用，需要使用函数返回的指针。</p>
<h3 id="回收空闲空间"><a href="#回收空闲空间" class="headerlink" title="回收空闲空间"></a>回收空闲空间</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function">sds <span class="title">sdsRemoveFreeSpace</span><span class="params">(sds s)</span> </span>&#123;</div><div class="line">    <span class="keyword">void</span> *sh, *newsh;</div><div class="line">    <span class="keyword">char</span> type, oldtype = s[<span class="number">-1</span>] &amp; SDS_TYPE_MASK;</div><div class="line">    <span class="keyword">int</span> hdrlen;</div><div class="line">    <span class="keyword">size_t</span> len = sdslen(s);</div><div class="line">    sh = (<span class="keyword">char</span>*)s-sdsHdrSize(oldtype);</div><div class="line">    type = sdsReqType(len);</div><div class="line">    hdrlen = sdsHdrSize(type);</div><div class="line">    <span class="keyword">if</span> (oldtype==type) &#123;</div><div class="line">        newsh = s_realloc(sh, hdrlen+len+<span class="number">1</span>);</div><div class="line">        <span class="keyword">if</span> (newsh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">        s = (<span class="keyword">char</span>*)newsh+hdrlen;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        newsh = s_malloc(hdrlen+len+<span class="number">1</span>);</div><div class="line">        <span class="keyword">if</span> (newsh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">        <span class="built_in">memcpy</span>((<span class="keyword">char</span>*)newsh+hdrlen, s, len+<span class="number">1</span>);</div><div class="line">        s_free(sh);</div><div class="line">        s = (<span class="keyword">char</span>*)newsh+hdrlen;</div><div class="line">        s[<span class="number">-1</span>] = type;</div><div class="line">        sdssetlen(s, len);</div><div class="line">    &#125;</div><div class="line">    sdssetalloc(s, len);</div><div class="line">    <span class="keyword">return</span> s;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>即使 SDS 发生截短操作，也并不会立刻回收空间，而是留待下一次可能的连接（追加）操作使用，除非主动调用 sdsRemoveFreeSpace 函数。</p>
<h3 id="二进制安全"><a href="#二进制安全" class="headerlink" title="二进制安全"></a>二进制安全</h3><p>由于 SDS header 中储存着字符串的长度，所以即使在字符串中出现了空字符（’\0’），Redis 定义的函数也可以正确地进行处理。而这些带有空字符的字符串在使用 C 语言的字符串函数的时候需要特别注意，有可能产生错误。因此，需要 SDS 的使用者自己对内容进行分辨和正确地使用。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/10/11/redis_data_structure_summary/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="柿子">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柿子的果盘">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/10/11/redis_data_structure_summary/" itemprop="url">Redis数据结构: 综述</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-10-11T00:00:00+08:00">
                2016-10-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/开源项目/" itemprop="url" rel="index">
                    <span itemprop="name">开源项目</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>很有没有看开源项目的源代码了，正好最近公司的两个功能用了 Redis，觉得挺有意思的，就想拆开来看看，里面具体是怎么实现的，算是今年给自己留点小作业吧，希望能坚持看完它。同时，在这里做些记录，把这个过程中的一些体会记录下来，方便后面回顾的时候查阅。</p>
<p>在国庆期间，我大概花了 5 天左右的时间通读了一遍 huangz 写的《redis设计与实现（第二版）》，这本书大概 400 页左右，对于 Redis 的基本数据结构和实现原理有一个了解。然后，开始阅读最新的 Redis 源代码，在阅读的过程中写一些注释，同时在博客上写总结进行记录。huangz 针对“2.9.11”做了一个标注版的<a href="https://github.com/huangz1990/redis-3.0-annotated" target="_blank" rel="external">源代码</a>，对应地，我在阅读的过程中也对源代码添加了一些注释，放在我的 <a href="https://github.com/iShiZhi/redis" target="_blank" rel="external">GitHub</a> 上，不如 huangz 标注的详细，主要是给自己留下一些思考和记录，一些新的变化和功能也做上的标记，也可以给大家做一个参考。</p>
<p>这篇文章先大概介绍一下 Redis 的数据结构的设计初衷，作为后续各类数据结构详细介绍的综述。</p>
<p>众所周知，所有的计算机程序都需要考虑两类的因素：时间复杂度和空间复杂度。通常情况下，在存储系统中，这两者是相互矛盾的。使用的存储空间越大，那么进行各类操作时消耗的时间越少，而使用的存储空间越少，则操作时需要寻址或者解压缩就带来额外的时间开销，导致耗费的时间增多。在不同的使用场景中，我们对于时间和空间的敏感程度和要求并不相同。举个例子，我们需要存储一些整数，并对一些特定的数进行查找，那么我们可能会有如下的选择：</p>
<ul>
<li>假设这些整数的范围确定，使用一个最小数到最大数的一个布尔数组来标记元素是否存在，这样查找操作的时间复杂度为 O(1)；</li>
<li>如果存入二分查找树，通过二分查找的方式进行查询，时间复杂度为 O(log N)；</li>
<li>如果这些数本身就存在链表中，那么查询时间就是 O(N)。</li>
</ul>
<p>因此，使用场景对于数据结构的设计至关重要。Redis 针对各种不同的使用场景设计了不同的基础数据结构，这里先对设计思路进行一些简要的介绍，而后的博客将结合代码进行更详细解释。</p>
<h3 id="简单动态字符串（Simple-Dynamic-String-SDS）"><a href="#简单动态字符串（Simple-Dynamic-String-SDS）" class="headerlink" title="简单动态字符串（Simple Dynamic String, SDS）"></a>简单动态字符串（Simple Dynamic String, SDS）</h3><p>与 C 语言原生的表示动态字符串的方法有所不同，SDS 对于字符串常见的操作进行了优化：</p>
<ul>
<li>增加了长度记录，使得 strlen 的时间复杂度从 O(N) 降为 O(1)；</li>
<li>通过保持空闲存储空间和惰性回收机制，减少对于 malloc 和 realloc 函数的调用，提升了 append 操作的性能</li>
</ul>
<h3 id="双端链表"><a href="#双端链表" class="headerlink" title="双端链表"></a>双端链表</h3><p>这是一个基础的数据结构，包含了表头指针和表尾指针，每个节点中都有前驱指针和后继指针，加快了从表尾开始进行的各类操作。</p>
<h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><p>字典的底层实现是哈希表，大家都比较熟悉的数据结构，而 Redis 实现的哈希列表有如下的特点：</p>
<ul>
<li>通过链表来解决冲突，通过 rehash 操作来降低冲突</li>
<li>针对不同的场景，使用不同的 rehash 操作和触发条件</li>
<li>rehash 操作按照渐进式的方式进行</li>
</ul>
<h3 id="整数集合"><a href="#整数集合" class="headerlink" title="整数集合"></a>整数集合</h3><p>整数集合是用来有序、无重复地保存多个整数值的数据结构。在 C 语言里，不同的数据类型占用的字节数是不同的，int8_t 占用 1 个字节，int16_t 占用 2 个字节，依次类推。而在大量的场景中，我们使用的整数的范围都较小，若使用 int64_t 的数组来作为整数集合的实现，则会浪费大量的空间。在这里，Redis 实现了一个根据集合中占用字节数最多的元素来确定数据的类型的数据结构，这个结构就是整数集合。</p>
<h3 id="压缩列表"><a href="#压缩列表" class="headerlink" title="压缩列表"></a>压缩列表</h3><p>压缩列表是为了节约空间而设计的数据结构，它是由一系列特殊编码的内存块构成的列表。一个压缩列表可以包含多个节点，每个节点可以保存一个长度受限的字符数组（不以为\0结尾的char数组）或者整数。它通过特殊的规则，使得保存这类数据占用的内存空间最小。但是，它的所有操作都需要通过遍历完成，即时间复杂度为 O(N)。这是一种完全牺牲时间来换取空间节约的数据结构，不适合在节点数多太多的情况下进行使用。</p>
<h3 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h3><p>即使链表中的元素是有序的，链表的查找、添加和删除的时间还是为 O(N)。跳跃表是在链表中元素是有序的基础上，通过增加额外的空间，加快各项操作的时间复杂度的数据结构，各项操作都可以达到 O(log N) 的时间复杂度。</p>
<h3 id="快速列表"><a href="#快速列表" class="headerlink" title="快速列表"></a>快速列表</h3><p>由于压缩列表的时间复杂度很高，为了提高压缩列表的时间复杂度，并且应对各类操作主要在链表两端完成的场景，Redis 发明了快速列表。它本质上是一个双端链表，而每个节点对应了一个压缩列表。通过限制压缩列表的存储空间和节点数量，以及引入 LZF 压缩算法对压缩列表进行进一步压缩，可以既保留压缩列表节省空间的特性，同时在对应的场景中，降低操作的时间复杂度。</p>
<p>以上大概讲了一下我对于 Redis 基本数据结构的设计思路的理解，后续将对各个数据结构进行展开介绍：</p>
<ul>
<li>Redis数据结构: 简单动态字符串</li>
<li>Redis数据结构: 双端链表</li>
<li>Redis数据结构: 字典</li>
<li>Redis数据结构: 整数集合</li>
<li>Redis数据结构: 压缩列表</li>
<li>Redis数据结构: 跳跃表</li>
<li>Redis数据结构: 快速列表</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/09/04/ruby_garbage_collection/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="柿子">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柿子的果盘">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/09/04/ruby_garbage_collection/" itemprop="url">Ruby 垃圾回收机制的演变过程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-09-04T00:00:00+08:00">
                2016-09-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/开发语言/" itemprop="url" rel="index">
                    <span itemprop="name">开发语言</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>垃圾回收（英语：Garbage Collection，缩写为 GC）是一种自动的内存管理机制。当一个电脑上的动态内存不再需要时，就应该予以释放，以让出内存，这种内存资源管理，称为垃圾回收（garbage collection）。垃圾回收最早起源于 LISP 语言。</p>
<h2 id="基本算法"><a href="#基本算法" class="headerlink" title="基本算法"></a>基本算法</h2><h3 id="引用计数器-Reference-Counting"><a href="#引用计数器-Reference-Counting" class="headerlink" title="引用计数器 Reference Counting"></a>引用计数器 Reference Counting</h3><p>对数据存储的物理空间附加多一个计数器空间，当有其他数据与其相关时则加一，反之相关解除时减一，定期检查各储存对象的计数器，为零的话则认为已经被抛弃而将其所占物理空间回收。这是最简单，也是最早在 LISP 实现的垃圾回收方式，其缺点是无法回收循环引用的存储对象。</p>
<p><img src="http://ocx5ae9jo.bkt.clouddn.com/reference-counting.jpeg" width="300px" height="300px"></p>
<h3 id="跟踪收集器-Tracing"><a href="#跟踪收集器-Tracing" class="headerlink" title="跟踪收集器 Tracing"></a>跟踪收集器 Tracing</h3><p>注意到，被回收的对象不再被应用程序使用，即从应用程序的根节点出发，沿着引用查找，将不会再查找到这些需要被回收的对象。因此，可以通过定期对若干根储存对象开始遍历，对整个程序所拥有的储存空间查找与之相关的存储对象和没相关的存储对象进行标记，然后将没相关的存储对象所占物理空间回收。根据标记和回收算法实现的不同，可以将这类跟踪收集的垃圾回收算法分为若干类。</p>
<h3 id="标记-清除-Mark-and-Sweep"><a href="#标记-清除-Mark-and-Sweep" class="headerlink" title="标记-清除 Mark and Sweep"></a>标记-清除 Mark and Sweep</h3><p>先暂停整个程序的全部运行线程（Stop the word），让回收线程以单线程进行扫描标记，并进行直接清除回收，然后回收完成，恢复运行线程。这个算法的缺点是会导致大量零碎的空闲空间碎片，使得大容量对象不容易获得连续的内存空间，而造成空间浪费。</p>
<p><img src="http://ocx5ae9jo.bkt.clouddn.com/mark-and-sweep.jpeg" width="450px" height="300px"></p>
<h3 id="标记-复制-Mark-and-Copy"><a href="#标记-复制-Mark-and-Copy" class="headerlink" title="标记-复制 Mark and Copy"></a>标记-复制 Mark and Copy</h3><p>需要程序将所拥有的内存空间分成两个部分。程序运行所需的存储对象先存储在其中一个分区（定义为“分区0”）。同样暂停整个程序的全部运行线程后，进行标记后，回收期间将将保留的存储对象搬运汇集到另一个分区（定义为“分区1”），完成回收，程序在本次回收后将接下来产生的存储对象会存储到“分区1”。在下一次回收时，两个分区的角色对调。</p>
<p><img src="http://ocx5ae9jo.bkt.clouddn.com/mark-and-copy1.jpeg" width="400px" height="150px"><br><img src="http://ocx5ae9jo.bkt.clouddn.com/mark-and-copy2.jpeg" width="400px" height="150px"></p>
<h3 id="标记-压缩-Mark-and-Compact"><a href="#标记-压缩-Mark-and-Compact" class="headerlink" title="标记-压缩 Mark and Compact"></a>标记-压缩 Mark and Compact</h3><p>和“标记－清除”相似，不同的是，在回收期间同时会将保留的存储对象搬运汇集到连续的内存空间（例如从小端地址开始），从而集成空闲空间。这样既不会像“标记-清除”那样产生内存碎片，也不会像“标记-复制”那样只能使用一半的空间。</p>
<h3 id="增量回收-Incremental-Collection"><a href="#增量回收-Incremental-Collection" class="headerlink" title="增量回收 Incremental Collection"></a>增量回收 Incremental Collection</h3><p>使用这种回收机制时，程序会将所拥有的内存空间分成若干分区。程序运行所需的存储对象会分布在这些分区中，每次只对其中一个分区进行回收操作，从而避免程序全部运行线程暂停来进行回收，允许部分线程在不影响回收行为而保持运行，并且降低回收时间，增加程序响应速度。</p>
<h3 id="分代回收-Generational-Collection"><a href="#分代回收-Generational-Collection" class="headerlink" title="分代回收 Generational Collection"></a>分代回收 Generational Collection</h3><p>不同的储存对象存活的时间差异很大，而不同存活时间的对象回收的特别也不一样：</p>
<ul>
<li>存活时间长，大容量的储存对象在“复制”算法上需要耗费更多的移动时间</li>
<li>存活时间短的储存对象通常在特定的作用域中，且容量小，适合被快速回收</li>
</ul>
<p><img src="http://ocx5ae9jo.bkt.clouddn.com/object-lifecycle.jpeg" width="500px" height="250px"></p>
<p>因此，可以将程序拥有的内存空间划分区域，并标记为年轻代空间和年老代空间。程序运行所需的存储对象会先存放在年轻代分区，年轻代分区会较为频密进行较为激进垃圾回收行为，每次回收完成幸存的存储对象内的寿命计数器加一。当年轻代分区存储对象的寿命计数器达到一定阈值或存储对象的占用空间超过一定阈值时，则被移动到年老代空间，年老代空间会较少运行垃圾回收行为。一般情况下，还有永久代的空间，用于涉及程序整个运行生命周期的对象存储，例如运行代码、数据常量等，该空间通常不进行垃圾回收的操作。</p>
<h2 id="Ruby-1-8-最基本的“标记-清除”"><a href="#Ruby-1-8-最基本的“标记-清除”" class="headerlink" title="Ruby 1.8 最基本的“标记-清除”"></a>Ruby 1.8 最基本的“标记-清除”</h2><p>Ruby 1.8里实现的就是1960年提出来的那个最简单的“标记-清除”算法，在整个 gc 的过程中，程序运行的所有线程都停机。</p>
<p><img src="http://ocx5ae9jo.bkt.clouddn.com/ruby-1-8.jpeg" width="600px" height="150px"></p>
<h2 id="Ruby-1-9-3-Lazy-sweep"><a href="#Ruby-1-9-3-Lazy-sweep" class="headerlink" title="Ruby 1.9.3 Lazy sweep"></a>Ruby 1.9.3 Lazy sweep</h2><p>Ruby 1.9.3实现了增量回收机制的一半，它的基本过程是：</p>
<ul>
<li>暂停整个程序的全部运行线程，让回收线程以单线程进行扫描标记</li>
<li>进行清除回收，直到找到一个可以使用的空间就停止清除回收过程</li>
</ul>
<p><img src="http://ocx5ae9jo.bkt.clouddn.com/ruby-1-9-3.jpeg" width="600px" height="100px"></p>
<h2 id="Ruby-2-0-加入针对-Copy-On-Write-的优化"><a href="#Ruby-2-0-加入针对-Copy-On-Write-的优化" class="headerlink" title="Ruby 2.0 加入针对 Copy-On-Write 的优化"></a>Ruby 2.0 加入针对 Copy-On-Write 的优化</h2><h3 id="Ruby的数据结构和-GC-过程"><a href="#Ruby的数据结构和-GC-过程" class="headerlink" title="Ruby的数据结构和 GC 过程"></a>Ruby的数据结构和 GC 过程</h3><p>我们先来看一下 Ruby 存储 String 的数据结构 RString，可以看到，除了一个指向该 String 具体值的指针以外，还包含了一个特殊的结构——RBasic，它保存了大量的标记位：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RString</span> &#123;</span></div><div class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">RBasic</span> <span class="title">basic</span>;</span></div><div class="line">  <span class="keyword">union</span> &#123;</div><div class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></div><div class="line">      <span class="keyword">long</span> len;</div><div class="line">      <span class="keyword">char</span> *ptr;</div><div class="line">      <span class="keyword">union</span> &#123;</div><div class="line">        <span class="keyword">long</span> capa;</div><div class="line">        VALUE shared;</div><div class="line">      &#125; aux;</div><div class="line">    &#125; heap;</div><div class="line">    <span class="keyword">char</span> ary[RSTRING_EMBED_LEN_MAX + <span class="number">1</span>];</div><div class="line">  &#125; as;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"> <span class="number">290</span>  <span class="class"><span class="keyword">struct</span> <span class="title">RBasic</span> &#123;</span></div><div class="line"> <span class="number">291</span>      <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</div><div class="line"> <span class="number">292</span>      VALUE klass;</div><div class="line"> <span class="number">293</span>  &#125;;</div><div class="line"></div><div class="line">(ruby.h)</div></pre></td></tr></table></figure>
<p>Ruby 程序中还有大量类似的结构，例如 RArray、RHash、RFile等等，它们都是由一些数据和一些标记位组成，统称为 RValue（Ruby Value）。在这些标记位中，有一个特殊的标记位 FL_MARK（包含在RBasic），它用于在 GC 过程中表示该结构是否需要被清除。因此，整个 GC 过程可以描述为：</p>
<ul>
<li>检查对象，标记 FL_MARK</li>
<li>将所有可用的对象放入一个链表中，以待使用</li>
</ul>
<p><img src="http://ocx5ae9jo.bkt.clouddn.com/gc_fl_mark.jpeg" with="600px" height="200px"></p>
<h3 id="Copy-On-Write-机制以及产生的-GC-问题"><a href="#Copy-On-Write-机制以及产生的-GC-问题" class="headerlink" title="Copy-On-Write 机制以及产生的 GC 问题"></a>Copy-On-Write 机制以及产生的 GC 问题</h3><p>众所周知，在基于 Unix 结构的系统中，有一个被称为“Copy-On-Write”的机制：当我们调用 fork 在父进程中创建子进程的时候，此时，子进程共享父进程的所有储存空间，包括数据、变量等等。这样可以使得 fork 命令执行得更快，需要的储存空间更少。当某个子进程需要修改共享的储存空间时，系统才会将这个存储空间进行复制，然后修改对应的数据。而 Ruby 在处理使用的数据结构时，也用了类似的方案，在不同的线程使用相同的数据时，会先使用同一个数据备份，直到其中某个线程需要修改。</p>
<p><img src="http://ocx5ae9jo.bkt.clouddn.com/ruby-share-memory.jpeg" width="500px" height="500px"></p>
<p>但是，由此产生了一个 GC 问题，在 GC 的标记阶段，会扫描所有的 RValue 结构，给 FL_MARK 进行赋值，此时对于共享的数据标记位进行的修改引发了拷贝。这样会大大降低 GC 的效率和存储空间的使用效率。</p>
<p><img src="http://ocx5ae9jo.bkt.clouddn.com/ruby-share_memory2.jpeg" width="500px" height="500px"></p>
<h3 id="Bitmap-Marking"><a href="#Bitmap-Marking" class="headerlink" title="Bitmap Marking"></a>Bitmap Marking</h3><p>在 Ruby2.0 中，FL_MARK 不在存储在 RValue 结构体中，而是存在 bitmap 中。对于每一个堆，都会有一个对应的 bitmap，用来存储堆中结构体的 FL_MARK 标记位。</p>
<p><img src="http://ocx5ae9jo.bkt.clouddn.com/gc-bitmap1.jpeg" width="700px" height="180px"></p>
<p>通过这样的方式，优化了 Copy-On-Write 机制对于 GC 过程的影响，提高了空间的使用率和 GC 的时间复杂度。</p>
<h2 id="Ruby-2-1-Generational-GC"><a href="#Ruby-2-1-Generational-GC" class="headerlink" title="Ruby 2.1 Generational GC"></a>Ruby 2.1 Generational GC</h2><h3 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h3><p>Ruby2.1 引入了分代回收的机制，它将 Object 分成 Yong 和 Mature 两类。新建的 Object 都是 Yong Object，当发生若干次垃圾回收（默认3次）以后，留存下来的 Object 都会变成 Mature Object。在每次发生 minior GC 时，只有 Yong Object 会被回收，而 Mature Object 只会在 full GC 中被回收。</p>
<p><img src="http://ocx5ae9jo.bkt.clouddn.com/generational-gc1.jpeg" width="400px" height="300px"></p>
<p>注意，在 Ruby2.1 中实现的分代回收并没有真的将物理内存分为 Yong Object 和 Mature Object 两个区域，而是在实现的时候通过一些标记位（oldgen bits）和算法来保证被标记成 Mature Object 的结构不会再被 Mark and Swap。</p>
<h3 id="Write-Barriers"><a href="#Write-Barriers" class="headerlink" title="Write Barriers"></a>Write Barriers</h3><p>在上面的实现中，遗留了如下一个问题：当一个新对象被创建以后，并被关联到一个 Mature Object上，这时候发生了 GC，这个对象是否被回收？</p>
<p><img src="http://ocx5ae9jo.bkt.clouddn.com/generational-gc2.jpeg" width="400px" height="300px"></p>
<p>为了解决这个问题，Ruby2.1 使用了一种称为 Write Barriers 的技术。它监控所有的 Mature Object，一旦发生从 Mature Object 到 Yong Object 的引用，则会对这些 Mature Object 进行记录，并在下次的 Mark and Sweep 中使用。事实上，为了支持 用 C 编写的扩展，Ruby2.1 对 Write Barriers的实现比较复杂，并非所有堆中的对象都被保护，而这些没有被保护的对象将不会被提升为 Muture Object，例如 Proc、Ruby::Env等，而被 C 编写的扩展访问的对象也是不安全的，也不会被提升。这些对象使用 remembered set 来加速GC。</p>
<h2 id="Ruby-2-2-Incremental-GC-amp-Symbol-GC"><a href="#Ruby-2-2-Incremental-GC-amp-Symbol-GC" class="headerlink" title="Ruby 2.2 Incremental GC &amp; Symbol GC"></a>Ruby 2.2 Incremental GC &amp; Symbol GC</h2><h3 id="Incremental-GC"><a href="#Incremental-GC" class="headerlink" title="Incremental GC"></a>Incremental GC</h3><p>首先，先介绍三个术语：</p>
<ul>
<li>white object：没有被标记过的 object</li>
<li>grey object：被标记过 object，且引用了 white object</li>
<li>black object：被标记过 object，且没有引用任何 white object</li>
</ul>
<p>使用上述的术语，Mark and Sweep 的过程可以描述为：</p>
<ul>
<li>将所有的 object 标记为 white object；</li>
<li>将程序使用的 object 标记为 gray object；</li>
<li>选择一个 gray object，将它引用的所有的 white object 标记为 gray，而将这个 gray object 标记为 black，重复这个过程，直到所有的 object 都不是 gray object；</li>
<li>回收所有的 white object。</li>
</ul>
<p>如果将上述的 Mark 过程变为增量式的，那么会面临一个问题：在增量 Mark 的过程中，随着程序的执行，一些 black object 会产生对 white object 的引用，而这样与 black object 的定义产生冲突。为了解决这个问题，我们还是使用 Write Barriers 技术。当产生从 black object 到 white object 的引用时，这个 black object 将会自动地被变为 gray object。注意到，由于一些 object 没有办法使用 Write Barriers 进行保护，因此需要对这些 object 进行特殊处理。上述的 Mark and Sweep 过程调整为：</p>
<ul>
<li>将所有的 object 标记为 white object；</li>
<li>将程序使用的 object 标记为 gray object；</li>
<li>选择一个 gray object，将它引用的所有的 white object 标记为 gray，而将这个 gray object 标记为 black，重复这个过程，直到所有的 object 都不是 gray object，这个过程增量式地进行；</li>
<li>遍历所有没有被 Write Barriers 保护的 object，判断它们是否需要被回收；</li>
<li>回收所有的 white object。</li>
</ul>
<p><img src="http://ocx5ae9jo.bkt.clouddn.com/ruby-2-2.jpeg" width="800px" height="150px"></p>
<h3 id="Symbol-GC"><a href="#Symbol-GC" class="headerlink" title="Symbol GC"></a>Symbol GC</h3><p>在 Ruby2.2 以前，程序中的 symbol 是不会被 GC 的，例如：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">before = Symbol.all_symbols.size</div><div class="line"><span class="number">100_000</span>.times <span class="keyword">do</span> <span class="params">|i|</span></div><div class="line">  <span class="string">"sym<span class="subst">#&#123;i&#125;</span>"</span>.to_sym</div><div class="line"><span class="keyword">end</span></div><div class="line">GC.start</div><div class="line">after = Symbol.all_symbols.size</div><div class="line">puts after - before</div><div class="line"><span class="comment"># =&gt; 100001</span></div></pre></td></tr></table></figure>
<p>而如果我们直接对 url 的参数调用 to_sym 获取 symbol，则会导致”symbol DoS”。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span></span></div><div class="line">  step = params[<span class="symbol">:step</span>].to_sym</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>为了支持用 C 编写的拓展，在 Ruby2.2 以前，所有的 symbol 对应一个唯一的 objectID，而由于rb_intern的实现方式，这个 objectID 必须在整个程序的生命周期里保持一致。在 C-Ruby 里创建一个方法时，会同时在方法表中添加一个唯一的 ID 来对应这个方法。在随后的调用过程中，会到方法列表中去寻找 ID 对应的静态内存，如果对应到这个方法的 symbol 被 GC 回收掉，则这个方法就再也不会被调用。<br>在 Ruby2.2 中，将所有的 symbol 分为两类：</p>
<p>在 Ruby 运行过程中动态创建的 symbol（例如通过to_sym创建的），这类的 symbol 将会被 GC<br>在 Ruby 解释器里生成的 symbol，或程序里静态的 symbol，这些将不会被 GC<br>但是，需要注意两点：</p>
<ul>
<li>这样做依然存在一些风险，例如在代码中使用 define_method 来定义函数（它将会调用rb_intern），则这个 symbol 将会被识别为第一类 symbol，从而被 GC</li>
</ul>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">define_method(params[<span class="symbol">:step</span>].to_sym) <span class="keyword">do</span></div><div class="line">  <span class="comment"># ...</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<ul>
<li>将 symbol 转化为 string 会耗费大量的时间</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://www.infoq.com/news/2011/08/ruby193-gc" target="_blank" rel="external">Ruby 1.9.3 Preview 1 Released, Improves GC Pauses With Lazy Sweep GC</a></li>
<li><a href="http://patshaughnessy.net/2012/1/4/never-create-ruby-strings-longer-than-23-characters" target="_blank" rel="external">Never create Ruby strings longer than 23 characters</a></li>
<li><a href="https://ruby-hacking-guide.github.io/object.html" target="_blank" rel="external">Ruby Hacking Guide Chapter 2: Objects</a></li>
<li><a href="http://patshaughnessy.net/2012/3/23/why-you-should-be-excited-about-garbage-collection-in-ruby-2-0" target="_blank" rel="external">Why You Should Be Excited About Garbage Collection in Ruby 2.0</a></li>
<li><a href="http://tmm1.net/ruby21-rgengc/" target="_blank" rel="external">Ruby 2.1: RGenGC</a></li>
<li><a href="http://patshaughnessy.net/2013/10/30/generational-gc-in-python-and-ruby" target="_blank" rel="external">Generational GC in Python and Ruby</a></li>
<li><a href="https://engineering.heroku.com/blogs/2015-02-04-incremental-gc/" target="_blank" rel="external">Incremental Garbage Collection in Ruby 2.2</a></li>
<li><a href="https://www.sitepoint.com/symbol-gc-ruby-2-2/" target="_blank" rel="external">Symbol GC in Ruby 2.2</a></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/09/03/mina_deploy/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="柿子">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柿子的果盘">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/09/03/mina_deploy/" itemprop="url">Mina自动化部署</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-09-03T00:00:00+08:00">
                2016-09-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/运维相关/" itemprop="url" rel="index">
                    <span itemprop="name">运维相关</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近给公司的架构做了下调整，把之前堆在一台服务器上的后台任务、几个产品线做了下拆分，加了几台机器。于是原先使用 Bash 脚本进行部署的方式就显得有些麻烦，就用 Mina 折腾了一下自动化部署，顺便在这里把 Mina 的一些用法记录一下。它的原理很简单，就是生成一个 Bash 脚本文件，然后 SSH 到服务器上运行这个脚本文件。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ gem install mina</div><div class="line">$ mina</div></pre></td></tr></table></figure>
<h2 id="配置部署文件"><a href="#配置部署文件" class="headerlink" title="配置部署文件"></a>配置部署文件</h2><h3 id="创建-config-deploy-rb"><a href="#创建-config-deploy-rb" class="headerlink" title="创建 config/deploy.rb"></a>创建 config/deploy.rb</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ mina init</div><div class="line">Created config/deploy.rb.</div></pre></td></tr></table></figure>
<h3 id="在服务器上创建文件夹"><a href="#在服务器上创建文件夹" class="headerlink" title="在服务器上创建文件夹"></a>在服务器上创建文件夹</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ ssh username@your.server.com</div><div class="line"><span class="comment"># Once in your server, create the deploy folder:</span></div><div class="line">~@your.server.com$ mkdir /var/www/flipstack.com</div><div class="line">~@your.server.com$ chown -R username /var/www/flipstack.com</div></pre></td></tr></table></figure>
<h3 id="运行-mina-setup"><a href="#运行-mina-setup" class="headerlink" title="运行 mina setup"></a>运行 mina setup</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ mina setup</div><div class="line">-----&gt; Creating folders... <span class="keyword">done</span>.</div></pre></td></tr></table></figure>
<h3 id="进行部署"><a href="#进行部署" class="headerlink" title="进行部署"></a>进行部署</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ mina deploy</div><div class="line">-----&gt; Deploying to 2012-06-12-040248</div><div class="line">       ...</div><div class="line">       Lots of things happening...</div><div class="line">       ...</div><div class="line">-----&gt; Done.</div></pre></td></tr></table></figure>
<h2 id="部署过程"><a href="#部署过程" class="headerlink" title="部署过程"></a>部署过程</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">$ mina deploy --verbose</div><div class="line">-----&gt; Creating the build path</div><div class="line">       $ mkdir tmp/build-128293482394</div><div class="line">-----&gt; Cloning the Git repository</div><div class="line">       $ git <span class="built_in">clone</span> https://github.com/nadarei/flipstack.git . -n --recursive</div><div class="line">       Cloning... <span class="keyword">done</span>.</div><div class="line">-----&gt; Installing gem dependencies using Bundler</div><div class="line">       $ bundle install --without development:<span class="built_in">test</span></div><div class="line">       Using i18n (0.6.0)</div><div class="line">       Using multi_json (1.0.4)</div><div class="line">       ...</div><div class="line">       Your bundle is complete! It was installed to ./vendor/bundle</div><div class="line">-----&gt; Moving to releases/4</div><div class="line">       $ mv <span class="string">"./tmp/build-128293482394"</span> <span class="string">"releases/4"</span></div><div class="line">-----&gt; Symlinking to current</div><div class="line">       $ ln -nfs releases/4 current</div><div class="line">-----&gt; Launching</div><div class="line">       $ <span class="built_in">cd</span> releases/4</div><div class="line">       $ sudo service nginx restart</div><div class="line">-----&gt; Done. Deployed v4</div></pre></td></tr></table></figure>
<p>从上面的日志里，我们可以看到 Mina 的部署过程分为如下几个步骤：</p>
<ul>
<li>创建一个临时文件夹，在这个临时文件夹里面完成代码的拷贝以及各类的准备工作；</li>
<li>将临时文件夹移动到 releases，并按照版本号进行重新命名，链接到 current；</li>
<li>运行部署脚本，完成部署。</li>
</ul>
<h2 id="deploy-rb-文件"><a href="#deploy-rb-文件" class="headerlink" title="deploy.rb 文件"></a>deploy.rb 文件</h2><p>注意到，deploy.rb实际上是一个 Rake File，因此可以使用 Ruby 的语法进行编写，主要使用的命令如下：</p>
<ul>
<li>set [variable_name] [value] 对使用的变量进行赋值</li>
</ul>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">set <span class="symbol">:domain</span>, <span class="string">'flipstack.com'</span></div><div class="line">queue 执行一条 Bash 脚本命令</div></pre></td></tr></table></figure>
<ul>
<li>task 创建一个任务，这个任务可以在其它任务中通过 invoke 调用</li>
</ul>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">task <span class="symbol">:down</span> <span class="keyword">do</span></div><div class="line">  invoke <span class="symbol">:maintenance_on</span></div><div class="line">  invoke <span class="symbol">:restart</span></div><div class="line"><span class="keyword">end</span></div><div class="line">task <span class="symbol">:maintenance_on</span></div><div class="line">  queue <span class="string">'touch maintenance.txt'</span></div><div class="line"><span class="keyword">end</span></div><div class="line">task <span class="symbol">:restart</span></div><div class="line">  queue <span class="string">'sudo service restart apache'</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>在上面一个部分介绍了 Mina 部署的过程，因此，在 task 里，同样对应了不同阶段：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 定义 SSH 的参数，以及 GIT 的参数</span></div><div class="line">set <span class="symbol">:domain</span>, <span class="string">'flipstack.com'</span></div><div class="line">set <span class="symbol">:user</span>, <span class="string">'flipstack'</span></div><div class="line">set <span class="symbol">:deploy_to</span>, <span class="string">'/var/www/flipstack.com'</span></div><div class="line">set <span class="symbol">:repository</span>, <span class="string">'http://github.com/flipstack/flipstack.git'</span></div><div class="line">task <span class="symbol">:deploy</span> <span class="keyword">do</span></div><div class="line">  deploy <span class="keyword">do</span></div><div class="line">    <span class="comment"># 放置在这里的命令是在创建临时文件夹以后，移动到 releases 文件夹以前执行的</span></div><div class="line">    <span class="comment"># 因此，注意这里执行的命令对应的路径</span></div><div class="line">    invoke <span class="symbol">:<span class="string">'git:clone'</span></span></div><div class="line">    invoke <span class="symbol">:<span class="string">'bundle:install'</span></span></div><div class="line">    <span class="comment"># 这里是移动到 releases 文件夹，并做完到 current 的链接以后执行的部署命令</span></div><div class="line">    to <span class="symbol">:launch</span> <span class="keyword">do</span></div><div class="line">      queue <span class="string">'touch tmp/restart.txt'</span></div><div class="line">    <span class="keyword">end</span></div><div class="line">    <span class="comment"># 这里是部署失败以后做的清理工作</span></div><div class="line">    to <span class="symbol">:clean</span> <span class="keyword">do</span></div><div class="line">      queue <span class="string">'log "failed deployment"'</span></div><div class="line">    <span class="keyword">end</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure></p>
<h2 id="预定义的一些任务"><a href="#预定义的一些任务" class="headerlink" title="预定义的一些任务"></a>预定义的一些任务</h2><p>Mina 已经将一些常见的任务进行了定义，我们只要通过 invoke 进行调用即可，常用的任务如下：</p>
<ul>
<li>git:clone</li>
<li>bundle:install</li>
<li>rails:db_migrate</li>
<li>rails:assets_precompile</li>
<li>whenever:update</li>
</ul>
<p>Mina 对这些常用的任务进行了不同程度的优化，例如执行git:clone的时候，如果服务器上已经有 repository 了，则只会进行git fetch，而不会真的执行 clone 这个极其耗时的操作；另外，对于 assets，Mina 会进行检查，看看上一次编译以后是否有更新，如果没有更新的话，则会自动跳过这一次的 compile。</p>
<p>另外，还有一些 Gem 也可以使用：</p>
<ul>
<li><a href="https://github.com/d4be4st/mina-delayed_job" target="_blank" rel="external">Delayed Job</a></li>
<li><a href="https://github.com/d4rky-pl/mina-rpush" target="_blank" rel="external">RPush</a></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="柿子" />
          <p class="site-author-name" itemprop="name">柿子</p>
           
              <p class="site-description motion-element" itemprop="description">一个非主流程序员</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">19</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">7</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">柿子</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.1"></script>



  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  





  

  

  

  

  

  

</body>
</html>
