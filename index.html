<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="一个非主流程序员">
<meta property="og:type" content="website">
<meta property="og:title" content="柿子的果盘">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="柿子的果盘">
<meta property="og:description" content="一个非主流程序员">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="柿子的果盘">
<meta name="twitter:description" content="一个非主流程序员">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>柿子的果盘</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">柿子的果盘</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">随手记录一些所读、所思、所感</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/28/python_package/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="柿子">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柿子的果盘">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/28/python_package/" itemprop="url">Python 包管理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-28T00:00:00+08:00">
                2017-06-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/开发语言/" itemprop="url" rel="index">
                    <span itemprop="name">开发语言</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>之前在用 Ruby，Java 和 NodeJs 的时候，都有比较明确的包或模块管理的概念。换工作以后开始使用 Python，由于我们的开发机是一个多人使用的环境（物理机），因此经常会发生包路径的优先级被修改的情况。而我之前对于 Python 的包管理并不熟悉，因此当我在使用环境的时候，被人修改了 pythonpath，结果让我排查了很久才找到原因。因此，特地查阅一下资料，发现有一篇<a href="https://github.com/dccrazyboy/pyeco/blob/master/pyeco.rst" target="_blank" rel="external">Python开发生态环境简介</a>写得很详细，在这里留个记录。</p>
<h3 id="理解包"><a href="#理解包" class="headerlink" title="理解包"></a>理解包</h3><p>Python 没有一个默认的包管理设施。事实上，包的概念在 Python 中是相当弱的。Python 代码被组织为模块。一个模块可能由包含一个函数的单一文件组成，也可能由包含多个模块的目录组成。 包和模块的区别非常小，并且每个模块都能被理解为包。</p>
<p>那么包和模块的区别到底是什么（如果有的话）？为了明白这个，你首先应该明白 Python 是如何查找模块的。</p>
<p>如同别的编程环境一样，Python中的一些函数和类（例如str,len,Exception等）在全局（叫做内置函数）都是可用的。 别的就需要通过手动 import 进来。例如:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> os</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> os.path <span class="keyword">import</span> basename, dirname</div></pre></td></tr></table></figure>
<p>这个包一定存在你的机子上，这样才能被 import 语句导入。但Python是如何知道这些模块的位置呢？这些位置信息在你安装Python虚拟机时就被自动设置好了，并且依赖于你的目标平台。包的路径可以在 sys.path 中查询。下面是在我的笔记本上的结果，运行环境是 Ubuntu 11.10。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> sys.path</div><div class="line">[<span class="string">''</span>,</div><div class="line"> <span class="string">'/usr/lib/python2.7'</span>,</div><div class="line"> <span class="string">'/usr/lib/python2.7/plat-linux2'</span>,</div><div class="line"> <span class="string">'/usr/lib/python2.7/lib-tk'</span>,</div><div class="line"> <span class="string">'/usr/lib/python2.7/lib-old'</span>,</div><div class="line"> <span class="string">'/usr/lib/python2.7/lib-dynload'</span>,</div><div class="line"> <span class="string">'/usr/local/lib/python2.7/dist-packages'</span>,</div><div class="line"> <span class="string">'/usr/lib/python2.7/dist-packages'</span>,</div><div class="line"> <span class="string">'/usr/lib/python2.7/dist-packages/PIL'</span>,</div><div class="line"> <span class="string">'/usr/lib/python2.7/dist-packages/gst-0.10'</span>,</div><div class="line"> <span class="string">'/usr/lib/python2.7/dist-packages/gtk-2.0'</span>,</div><div class="line"> <span class="string">'/usr/lib/pymodules/python2.7'</span>,</div><div class="line"> <span class="string">'/usr/lib/python2.7/dist-packages/ubuntu-sso-client'</span>,</div><div class="line"> <span class="string">'/usr/lib/python2.7/dist-packages/ubuntuone-client'</span>,</div><div class="line"> <span class="string">'/usr/lib/python2.7/dist-packages/ubuntuone-control-panel'</span>,</div><div class="line"> <span class="string">'/usr/lib/python2.7/dist-packages/ubuntuone-couch'</span>,</div><div class="line"> <span class="string">'/usr/lib/python2.7/dist-packages/ubuntuone-installer'</span>,</div><div class="line"> <span class="string">'/usr/lib/python2.7/dist-packages/ubuntuone-storage-protocol'</span>]</div></pre></td></tr></table></figure>
<p>这里给出了 Python 搜索包的路径。它将从最上面开始找，直到找到一个名字相符的。 这表明如果两个不同的路径分别包含了两个具有相同名字的包，搜索将在找到第一个名字的时候停止，然后将永远不会往下查找。</p>
<p>正如你所猜的，包搜索路径很容易被劫持，为了确保 Python 首先载入你的包，所需做的如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>sys.path.insert(<span class="number">0</span>, <span class="string">'/path/to/my/packages'</span>)</div></pre></td></tr></table></figure></p>
<p>尽管这个方法在很多情况下都很好用，但一定要小心不要滥用。 只有当必要时再使用！不要滥用！<br>site 模块控制包的搜索路径。当 Python 虚拟机初始化时它会自动被导入。</p>
<h3 id="PYTHONPATH-变量"><a href="#PYTHONPATH-变量" class="headerlink" title="PYTHONPATH 变量"></a>PYTHONPATH 变量</h3><p>PYTHONPATH 是一个用来增加默认包搜索目录的环境变量。可以认为它是对于 Python 的一个特殊的 PATH 变量。 它仅仅是一个通过“:”分割，包含 Python 模块目录的列表（并不是类似于 sys.path 的 Python list）。 它可能就类似下面这样：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">export</span> PYTHONPATH=/path/to/some/directory:/path/to/another/directory:/path/to/yet/another/directory</div></pre></td></tr></table></figure></p>
<p>有时候你可能并不想覆盖掉现存的 PYTHONPATH ，而仅仅是希望添加新目录到头部或尾部。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">export</span> PYTHONPATH=<span class="variable">$PYTHONPATH</span>:/path/to/some/directory    <span class="comment"># Append</span></div><div class="line"><span class="built_in">export</span> PYTHONPATH=/path/to/some/directory:<span class="variable">$PYTHONPATH</span>    <span class="comment"># Prepend</span></div></pre></td></tr></table></figure></p>
<p>PYTHONPATH，sys.path.insert 这些方法并非完美，我们最好也不要用这些方法。使用它们，你可能可以解决本地的开发环境问题，但它在别的环境下也许并不适用。</p>
<p>我们现在明白的Python如何找到安装的包路径，现在让我们回到开始那个问题。 模块和包的区别到底是什么？包是一个模块或模块/子模块的集合，一般情况下被压缩到一个压缩包中。 其中包含：</p>
<ol>
<li>依赖信息</li>
<li>将文件拷贝到标准的包搜索路径的指令</li>
<li>编译指令(如果在安装前代码必须被编译的话</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/26/python_decorator/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="柿子">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柿子的果盘">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/26/python_decorator/" itemprop="url">Python 装饰器</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-26T00:00:00+08:00">
                2017-06-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/开发语言/" itemprop="url" rel="index">
                    <span itemprop="name">开发语言</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="模式动机"><a href="#模式动机" class="headerlink" title="模式动机"></a>模式动机</h3><p>通常情况下，在不改变类或者对象功能的基础上，我们有两种方式可以实现给一个类或对象增加行为：</p>
<ul>
<li>继承机制：通过继承一个现有类可以使得子类在拥有自身方法的同时还拥有父类的方法。但是这种方法是静态的，用户不能控制增加行为的方式和时机。</li>
<li>关联机制：将一个类的对象嵌入另一个对象中，由另一个对象来决定是否调用嵌入对象的行为以便扩展自己的行为，我们称这个嵌入的对象为装饰器 (Decorator)</li>
</ul>
<p>装饰器本质上是在不对现有函数做任何代码变动的前提下，增加额外的功能。它经常用于有切面需求的场景，比如：插入日志、性能测试、事务处理、缓存、权限校验等场景。</p>
<h3 id="基础：函数是对象"><a href="#基础：函数是对象" class="headerlink" title="基础：函数是对象"></a>基础：函数是对象</h3><p>在 Python 中，函数也是对象，它可以：</p>
<ul>
<li>赋值给变量</li>
<li>作为形参传递给其它的函数</li>
<li>作为函数的返回值</li>
<li>在一个函数的内部定义另外一个函数</li>
</ul>
<p>而这些就是 Python 装饰器的基础。</p>
<h3 id="简单装饰器"><a href="#简单装饰器" class="headerlink" title="简单装饰器"></a>简单装饰器</h3><p>假设我们当前有一个处理业务逻辑的函数，如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">business_logic</span><span class="params">()</span>:</span></div><div class="line">    print(<span class="string">'deal with business logic'</span>)</div></pre></td></tr></table></figure></p>
<p>现在有一个需求，希望可以记录下函数调用的日志，于是在函数中添加日志代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">business_logic</span><span class="params">()</span>:</span></div><div class="line">    logging.info(<span class="string">'business_logic is invoked!'</span>)</div><div class="line">    print(<span class="string">'deal with business logic'</span>)</div></pre></td></tr></table></figure></p>
<p>而在正常的开发过程中，会有很多函数有类似的需求。为了减少重复写代码，我们可以重新定义一个函数：专门处理日志 ，日志处理完之后再执行真正的业务代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">api_logging</span><span class="params">(func)</span>:</span></div><div class="line">    logging.info(<span class="string">"%s is invoked!"</span> % func.__name__)</div><div class="line">    func()</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">business_logic</span><span class="params">()</span>:</span></div><div class="line">    print(<span class="string">'deal with business logic'</span>)</div></pre></td></tr></table></figure></p>
<p>但是这样的话，我们每次都需要将包含业务逻辑的函数作为参数传递给 api_logging 函数。这样的话，就破坏了原有的调用逻辑。<br>使用装饰器模式，我们可以把上述的逻辑改为下面的实现：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">api_logging</span><span class="params">(func)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></div><div class="line">        logging.info(<span class="string">"%s is invoked!"</span> % func.__name__)</div><div class="line">        <span class="keyword">return</span> func(*args, **kwargs)</div><div class="line">    <span class="keyword">return</span> wrapper</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">business_logic</span><span class="params">()</span>:</span></div><div class="line">    print(<span class="string">'deal with business logic'</span>)</div><div class="line"></div><div class="line">business_logic = api_logging(business_logic)</div><div class="line">business_logic()</div></pre></td></tr></table></figure></p>
<p>通过这样的方式，直接调用 business_logic 就可以按照期望地打印调用日志，并且执行业务逻辑了。但是这样每次定义新函数的时候，需要多加一个函数赋值语句。<br>Python 提供了一个语法糖，能省去这个函数赋值语句，就是 @ 符号。我们可以把上述的代码改为如下形式：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">api_logging</span><span class="params">(func)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></div><div class="line">        logging.info(<span class="string">"%s is invoked!"</span> % func.__name__)</div><div class="line">        <span class="keyword">return</span> func(*args, **kwargs)</div><div class="line">    <span class="keyword">return</span> wrapper</div><div class="line"></div><div class="line"><span class="meta">@api_logging</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">business_logic</span><span class="params">()</span>:</span></div><div class="line">    print(<span class="string">'deal with business logic'</span>)</div><div class="line"></div><div class="line">business_logic()</div></pre></td></tr></table></figure></p>
<p>这样就创建了一个简单的装饰器。</p>
<h3 id="functions-wraps"><a href="#functions-wraps" class="headerlink" title="functions.wraps"></a>functions.wraps</h3><p>使用装饰器有一个缺点，就是原函数的原信息不见了，比如 <strong>name</strong>、<strong>doc</strong> 等，具体例子如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">api_logging</span><span class="params">(func)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></div><div class="line">        <span class="keyword">print</span> func.__name__</div><div class="line">        <span class="keyword">print</span> func.__doc__</div><div class="line">        logging.info(<span class="string">"%s is invoked!"</span> % func.__name__)</div><div class="line">        <span class="keyword">return</span> func(*args, **kwargs)</div><div class="line">    <span class="keyword">return</span> wrapper</div><div class="line"></div><div class="line"><span class="meta">@api_logging</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">business_logic</span><span class="params">()</span>:</span></div><div class="line">    print(<span class="string">'deal with business logic'</span>)</div><div class="line"></div><div class="line">api_logging(business_logic)()</div></pre></td></tr></table></figure></p>
<p>不难发现，函数 business_logic 的信息被 wrapper 取代了。Python 提供了一个装饰器 functools.wraps，它能把原函数的元信息拷贝到装饰器里面的 func 函数中，使得装饰器里面的 func 函数拥有和原函数一样的元信息。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">api_logging</span><span class="params">(func)</span>:</span></div><div class="line"><span class="meta">    @wraps(func)</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></div><div class="line">        <span class="keyword">print</span> func.__name__</div><div class="line">        <span class="keyword">print</span> func.__doc__</div><div class="line">        logging.info(<span class="string">"%s is invoked!"</span> % func.__name__)</div><div class="line">        <span class="keyword">return</span> func(*args, **kwargs)</div><div class="line">    <span class="keyword">return</span> wrapper</div></pre></td></tr></table></figure></p>
<h3 id="带参数的装饰器"><a href="#带参数的装饰器" class="headerlink" title="带参数的装饰器"></a>带参数的装饰器</h3><p>装饰器还有更大的灵活性，例如上述的例子中，我们希望针对不同的业务接口的调用使用不同日志级别，那么需要给装饰器传入日志级别作为参数，具体需要的改动如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">api_logging</span><span class="params">(level)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorator</span><span class="params">(func)</span>:</span></div><div class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></div><div class="line">            <span class="keyword">if</span> level == <span class="string">"warn"</span>:</div><div class="line">                logging.warn(<span class="string">"%s is invoked!"</span> % func.__name__)</div><div class="line">            <span class="keyword">elif</span> level == <span class="string">"info"</span>:</div><div class="line">                logging.info(<span class="string">"%s is invoked!"</span> % func.__name__)</div><div class="line">            <span class="keyword">return</span> func(*args, **kwargs)</div><div class="line">        <span class="keyword">return</span> wrapper</div><div class="line">    <span class="keyword">return</span> decorator</div><div class="line"></div><div class="line"><span class="meta">@api_logging('warn')</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">business_logic</span><span class="params">()</span>:</span></div><div class="line">    print(<span class="string">'deal with business logic'</span>)</div><div class="line"></div><div class="line">business_logic()</div></pre></td></tr></table></figure></p>
<p>上述处理方法的核心思想很简单。最外层的函数 api_logging() 接受参数并将它们作用在内部的装饰器函数上面。内层的函数 decorate() 接受一个函数作为参数，然后在函数上面放置一个包装器。这里的关键点是包装器是可以使用传递给 api_logging() 的参数。</p>
<h3 id="类装饰器"><a href="#类装饰器" class="headerlink" title="类装饰器"></a>类装饰器</h3><p>相比函数装饰器，类装饰器更灵活，封装性也更好。当使用 @ 符号将类装饰器附加到函数上时，会调用类的 <strong>call</strong> 方法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logging</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, func)</span>:</span></div><div class="line">        self._func = func</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self)</span>:</span></div><div class="line">        logging.info(<span class="string">"%s is invoked!"</span> % self._func.__name__)</div><div class="line">        self._func()</div><div class="line"></div><div class="line"><span class="meta">@Logging</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">business_logic</span><span class="params">()</span>:</span></div><div class="line">    print(<span class="string">'deal with business logic'</span>)</div><div class="line"></div><div class="line">business_logic()</div></pre></td></tr></table></figure></p>
<p>通过这种方式，我们可以在日志处理的逻辑发生多样化时，还可以继承 Logging 进行实现。</p>
<h3 id="装饰器顺序"><a href="#装饰器顺序" class="headerlink" title="装饰器顺序"></a>装饰器顺序</h3><p>一个函数可以同时定义多个装饰器，比如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@decorator1</span></div><div class="line"><span class="meta">@decorator2</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">pass</span></div></pre></td></tr></table></figure></p>
<p>它的执行顺序是从里到外的，先执行最里面的装饰器，然后依次向外，直到最外层的装饰器，等效于：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">func = decorator1(decorator2(func))</div></pre></td></tr></table></figure></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/22/restart/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="柿子">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柿子的果盘">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/22/restart/" itemprop="url">胜败乃兵家常事，少侠请重新来过</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-22T10:12:23+08:00">
                2017-06-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>今年春节过完以后，各种杂事缠身，先是小团团提早出生闹得一阵鸡飞狗跳，再是换了份工作，匆忙地离职再入职。由于新工作的技术栈跟之前完全不同，领域也几乎没有相关性，所以很是折腾了一番。</p>
<p>待到一切都稍微上了正轨，回来看这个博客，发现当时离职的时候很是潇洒地把公司开发机的硬盘格式化了，忘记把博客的源代码备份了……颇有种小时候玩仙剑的时候看到屏幕上出现“胜败乃兵家常事，少侠请重新来过”时的感受。</p>
<p>于是，一切重来，赶紧把之前写的文章拷贝下来，慢慢重新排版了。之前剩下的几篇写完还没发表的 Redis 相关的博客只能有时间再来补上了。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/12/05/redis_malloc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="柿子">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柿子的果盘">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/12/05/redis_malloc/" itemprop="url">Redis内存管理机制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-12-05T00:00:00+08:00">
                2016-12-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/开源项目/" itemprop="url" rel="index">
                    <span itemprop="name">开源项目</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在阅读各类基本数据结构的时候，看到分配空间或调整空间时，使用的是形如 zmalloc 的函数。由于它的用法与 malloc 无异，所以一直把它等同于 malloc 进行阅读，直到看到 object.c 最后新增加的内存数据统计时，才注意到一些内存统计相关的功能，于是阅读了一下 Redis 内存管理相关的代码。</p>
<h3 id="Redis-的内存管理策略"><a href="#Redis-的内存管理策略" class="headerlink" title="Redis 的内存管理策略"></a>Redis 的内存管理策略</h3><p>Redis 在进行内存空间分配的时候，会在分配的空间前面增加一个额外的空间，用于保存分配的空间的大小。同时，使用一个全局变量 used_memory 来记录 Redis 总共申请分配的空间大小。</p>
<h3 id="第三方的-malloc-库"><a href="#第三方的-malloc-库" class="headerlink" title="第三方的 malloc 库"></a>第三方的 malloc 库</h3><p>Redis 支持使用第三方的 malloc 库（tcmalloc、 jemalloc 以及苹果平台的 malloc.h）来管理内存：</p>
<ul>
<li>tcmalloc：tcmalloc 是 google perftool 的一部分，与一般的内存池不同，它直接与 OS 打交道，内存闲置时 OS 会进行回收 (STL 内存池就不回收)，同时使用 TLS (Thread local storage) 管理内存池，避免一个线程内分配内存都要同步。</li>
<li>jemalloc：jemalloc 与 tcmalloc相似，作者 Jason Evans 是 Free BSD 开发人员，性能与使用率与 tcmalloc 不相伯仲。tcmalloc 更方便与 google perftool 集成，进行性能评测。</li>
</ul>
<p>对于这些第三方库而言，有两个比较重要的特点：</p>
<ul>
<li>包括苹果平台的 malloc.h，这些第三方库与 STL 标准库可以通过调用 malloc_size(p) 直接获得指针 p 在分配时获得的空间大小。</li>
<li>在分配小空间时，这些第三方库可能会多分配一些内存空间以供使用，例如对于 tcmalloc 而言，收到 833 字节到 1024 字节的内存分配请求，都会分配一个 1024 字节大小的内存块，这样会产生内存空间碎片。</li>
</ul>
<p>关于这些第三方库的实现原理，可以参考：<br><a href="http://www.360doc.com/content/13/0915/09/8363527_314549128.shtml。" target="_blank" rel="external">http://www.360doc.com/content/13/0915/09/8363527_314549128.shtml。</a></p>
<p>在使用第三方库的时候，直接用这些库中的函数替换掉预先定义的函数，特别注意到，这些第三方库都实现了获取空间大小的方法，统一重新定义为 zmalloc_size(p)，同时使用 HAVE_MALLOC_SIZE 标记是否由 Redis 自己管理分配的空间大小（为 1 表示不由自己管理）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(USE_TCMALLOC)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ZMALLOC_LIB (<span class="meta-string">"tcmalloc-"</span> __xstr(TC_VERSION_MAJOR) <span class="meta-string">"."</span> __xstr(TC_VERSION_MINOR))</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;google/tcmalloc.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> (TC_VERSION_MAJOR == 1 &amp;&amp; TC_VERSION_MINOR &gt;= 6) || (TC_VERSION_MAJOR &gt; 1)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> HAVE_MALLOC_SIZE 1</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> zmalloc_size(p) tc_malloc_size(p)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">error</span> <span class="meta-string">"Newer version of tcmalloc required"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(USE_JEMALLOC)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ZMALLOC_LIB (<span class="meta-string">"jemalloc-"</span> __xstr(JEMALLOC_VERSION_MAJOR) <span class="meta-string">"."</span> __xstr(JEMALLOC_VERSION_MINOR) <span class="meta-string">"."</span> __xstr(JEMALLOC_VERSION_BUGFIX))</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;jemalloc/jemalloc.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> (JEMALLOC_VERSION_MAJOR == 2 &amp;&amp; JEMALLOC_VERSION_MINOR &gt;= 1) || (JEMALLOC_VERSION_MAJOR &gt; 2)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> HAVE_MALLOC_SIZE 1</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> zmalloc_size(p) je_malloc_usable_size(p)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">error</span> <span class="meta-string">"Newer version of jemalloc required"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(__APPLE__)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc/malloc.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> HAVE_MALLOC_SIZE 1</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> zmalloc_size(p) malloc_size(p)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(USE_TCMALLOC)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> malloc(size) tc_malloc(size)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> calloc(count,size) tc_calloc(count,size)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> realloc(ptr,size) tc_realloc(ptr,size)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> free(ptr) tc_free(ptr)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(USE_JEMALLOC)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> malloc(size) je_malloc(size)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> calloc(count,size) je_calloc(count,size)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> realloc(ptr,size) je_realloc(ptr,size)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> free(ptr) je_free(ptr)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure>
<h3 id="非第三方的内存管理"><a href="#非第三方的内存管理" class="headerlink" title="非第三方的内存管理"></a>非第三方的内存管理</h3><p>在使用标准库提供的内存操作函数时，Redis 会额外多申请 PREFIX_SIZE 定义的大小的空间，用于存储申请空间的大小。同时，每次申请或者更新空间大小时，需要同时更新 used_memory 的值，以 zmalloc 为例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> update_zmalloc_stat_alloc(__n) do &#123; \</span></div><div class="line">    size_t _n = (__n); \</div><div class="line">    <span class="meta-keyword">if</span> (_n&amp;(sizeof(long)-1)) _n += sizeof(long)-(_n&amp;(sizeof(long)-1)); \</div><div class="line">    <span class="meta-keyword">if</span> (zmalloc_thread_safe) &#123; \</div><div class="line">        atomicIncr(used_memory,__n,used_memory_mutex); \</div><div class="line">    &#125; <span class="meta-keyword">else</span> &#123; \</div><div class="line">        used_memory += _n; \</div><div class="line">    &#125; \</div><div class="line">&#125; while(0)</div><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">zmalloc</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>&#123;</div><div class="line">    <span class="keyword">void</span> *ptr = <span class="built_in">malloc</span>(size+PREFIX_SIZE); <span class="comment">// 申请一个指定大小加上 header 的空间</span></div><div class="line">    <span class="keyword">if</span> (!ptr) zmalloc_oom_handler(size);</div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_MALLOC_SIZE</span></div><div class="line">    update_zmalloc_stat_alloc(zmalloc_size(ptr)); <span class="comment">// 计算空间大小</span></div><div class="line">    <span class="keyword">return</span> ptr;</div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">    *((<span class="keyword">size_t</span>*)ptr) = size; <span class="comment">// 自己维护空间的大小</span></div><div class="line">    update_zmalloc_stat_alloc(size+PREFIX_SIZE); <span class="comment">// 计算空间的大小</span></div><div class="line">    <span class="keyword">return</span> (<span class="keyword">char</span>*)ptr+PREFIX_SIZE; <span class="comment">// 返回可以使用的空间的指针</span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="统计使用的内存数"><a href="#统计使用的内存数" class="headerlink" title="统计使用的内存数"></a>统计使用的内存数</h3><p>Redis 在统计使用的内存数的时候，按照如下的步骤进行尝试：</p>
<ul>
<li>如果定义了 PROC_FS，则从 /proc/[getpid()]/stat 中读取</li>
<li>如果定义了 TASK_INFO，从该进程 id 对应的 task_info_t 结构中读取 resident_size 变量</li>
<li>直接返回 used_memory</li>
</ul>
<p>由于第三方的库在分配内存空间的时候，存在空间碎片，因此，通过操作系统底层的调用函数统计出的内存占用量的数值更为准确，使用这个数值与 used_memory 的比例可以估计内存碎片的情况，而 Redis 也是这么做的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">float</span> <span class="title">zmalloc_get_fragmentation_ratio</span><span class="params">(<span class="keyword">size_t</span> rss)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> (<span class="keyword">float</span>)rss/zmalloc_used_memory();</div><div class="line">&#125;</div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/12/01/redis_object/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="柿子">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柿子的果盘">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/12/01/redis_object/" itemprop="url">Redis数据结构: 对象</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-12-01T00:00:00+08:00">
                2016-12-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/开源项目/" itemprop="url" rel="index">
                    <span itemprop="name">开源项目</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Redis 主要的基本数据结构有 SDS，双端链表，整数集合，哈希表，跳跃表，压缩表等等。Redis 并没有直接使用这些基本的数据结构，而是把它们封装成对象来进行使用，对象的类型有字符串对象（OBJ_STRING）、列表对象（OBJ_LIST）、哈希对象（OBJ_HASH）、集合对象（OBJ_SET）和有序集合对象（OBJ_ZSET）。通过这五种不同的对象类型，Redis 可以在不同的场景下使用不同的基本数据结构，从而优化空间的利用率和操作的时间复杂度。</p>
<h3 id="Redis-对象结构"><a href="#Redis-对象结构" class="headerlink" title="Redis 对象结构"></a>Redis 对象结构</h3><p>在 server.h 中定义了 redisObject 的结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></div><div class="line">    <span class="keyword">unsigned</span> type:<span class="number">4</span>;              <span class="comment">// 类型</span></div><div class="line">    <span class="keyword">unsigned</span> encoding:<span class="number">4</span>;          <span class="comment">// 编码</span></div><div class="line">    <span class="keyword">unsigned</span> lru:REDIS_LRU_BITS;  <span class="comment">// 对象最后一次被访问的时间</span></div><div class="line">    <span class="keyword">int</span> refcount;                 <span class="comment">// 引用计数</span></div><div class="line">    <span class="keyword">void</span> *ptr;                    <span class="comment">// 指向实际值的指针</span></div><div class="line">&#125; robj;</div></pre></td></tr></table></figure>
<h4 id="类型、编码、指向实际值的指针"><a href="#类型、编码、指向实际值的指针" class="headerlink" title="类型、编码、指向实际值的指针"></a>类型、编码、指向实际值的指针</h4><p>不同的类型决定了该对象是上述五种对象中的哪一种，而编码则决定了使用了何种底层的基本数据结构，具体的对应关系是：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>编码</th>
<th>对象</th>
</tr>
</thead>
<tbody>
<tr>
<td>OBJ_STRING</td>
<td>OBJ_ENCODING_INT</td>
<td>使用整数值实现的字符串对象</td>
</tr>
<tr>
<td>OBJ_STRING</td>
<td>OBJ_ENCODING_EMBSTR</td>
<td>使用 embstr 编码的 SDS 实现的字符串对象</td>
</tr>
<tr>
<td>OBJ_STRING</td>
<td>OBJ_ENCODING_RAW</td>
<td>使用 SDS 实现的字符串对象</td>
</tr>
<tr>
<td>OBJ_LIST</td>
<td>OBJ_ENCODING_QUICKLIST</td>
<td>使用快速列表实现的列表对象</td>
</tr>
<tr>
<td>OBJ_HASH</td>
<td>OBJ_ENCODING_ZIPLIST</td>
<td>使用压缩列表实现的哈希对象</td>
</tr>
<tr>
<td>OBJ_HASH</td>
<td>OBJ_ENCODING_HT</td>
<td>使用哈希表实现的哈希对象</td>
</tr>
<tr>
<td>OBJ_SET</td>
<td>OBJ_ENCODING_INTSET</td>
<td>使用整数集合实现的集合对象</td>
</tr>
<tr>
<td>OBJ_SET</td>
<td>OBJ_ENCODING_HT</td>
<td>使用哈希表实现的集合对象</td>
</tr>
<tr>
<td>OBJ_ZSET</td>
<td>OBJ_ENCODING_ZIPLIST</td>
<td>使用压缩列表实现的有序集合对象</td>
</tr>
<tr>
<td>OBJ_ZSET</td>
<td>OBJ_ENCODING_SKIPLIST</td>
<td>使用快速列表实现的有序集合对象</td>
</tr>
</tbody>
</table>
<p>具体的组合之间的转换关系和对象的细节后面再进行叙述。</p>
<h4 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h4><p>因为 C 语言本身没有实现垃圾回收机制，因此 Redis 自己实现了一套基于引用计数器的回收机制。而 refcount 则用于记录当前对象被程序引用的次数：</p>
<ul>
<li>对象创建时，refcount 被设置为 1</li>
<li>对象被新的程序引用时，refcount 增加 1</li>
<li>对象不再被程序引用时，refcount 减去 1</li>
<li>refcount = 0 时，销毁对象，回收空间</li>
</ul>
<p>同时，值得一提的是，Redis 在启动的时候会生成 0 - 10000 对应的字符串对象，在使用这些整数值时，所有的字符串指针会指向这些预先生成的字符串对象。这样能够大量节省这些常用字符串的存储空间。那么为什么只对数值类型的字符串进行共享呢？因为程序判定是创建新的字符串对象，还是使用共享对象时，需要对存储的内容进行比对，整数型字符串对象的比对时间为 O(1)，而普通的字符串则需要耗费 O(N)。而由于这样的比对操作在每次创建字符串对象或修改的时候都需要进行，十分频繁，会严重影响 Redis 的性能。</p>
<h4 id="对象最后一次被访问时间"><a href="#对象最后一次被访问时间" class="headerlink" title="对象最后一次被访问时间"></a>对象最后一次被访问时间</h4><p>这个属性记录了对象的空转时长，使用OBJECT IDLETIME可以查看对象的空转时长。注意，除了该命令以外的其它命令都会更新这个属性。<br>当 Redis 的 maxmemory 选项被设置以后，Redis 占用的空间到达 maxmemory 设置的值时，Redis 就会开始清理空转时间较长的对象来获取可用的空间。</p>
<h3 id="字符串对象"><a href="#字符串对象" class="headerlink" title="字符串对象"></a>字符串对象</h3><p>embstr 编码的字符串和普通 SDS 字符串的区别是：对象结构和字符串结构（字符串结构仍是 SDS）是否存储在连续的空间中。它的好处是：</p>
<ul>
<li>只需要一次分配空间和释放空间的操作，而普通 SDS 字符串实现的字符串对象需要两次</li>
<li>由于字符串对象和字符串内容被分配在连续的空间中，能更好地利用缓存</li>
</ul>
<p>字符串对象在选择底层的数据结构实现时，遵循如下的原则：</p>
<ul>
<li>可以用 long 类型保存的字符串用整数值保存</li>
<li>长度小于 44 字节的字符串用 embstr 编码的字符串对象保存</li>
<li>无法用 long 类型保存的，且转化为字符串长度大于 44 字节的数值类型，或长度大于 44 的字符串则用普通的 SDS 对应的字符串类型保存</li>
</ul>
<p>为什么是 44 字节呢？ 因为 EMBSTR 的对象和字符串都保存在一个连续的内存空间中，包括了</p>
<ul>
<li>redisObject 结构 type、encoding 和 lru 共占用 4 个字节，refcount 占用 4 个字节，void* 占用不超过 8 个字节</li>
<li>sdshdr8 header 占用 3 个字节</li>
<li>字符串占用 44 个字节</li>
<li>结尾的空字符占用 1 个字节</li>
</ul>
<p>总计 4 + 4 + 8 + 3 + 44 + 1 = 64，所以可以使用 64 字节的连续空间来进行存储。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_EMBSTR_SIZE_LIMIT 44</span></div><div class="line"><span class="function">robj *<span class="title">createStringObject</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *ptr, <span class="keyword">size_t</span> len)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (len &lt;= OBJ_ENCODING_EMBSTR_SIZE_LIMIT)</div><div class="line">        <span class="keyword">return</span> createEmbeddedStringObject(ptr,len);</div><div class="line">    <span class="keyword">else</span></div><div class="line">        <span class="keyword">return</span> createRawStringObject(ptr,len);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="列表对象"><a href="#列表对象" class="headerlink" title="列表对象"></a>列表对象</h3><p>在最新的 unstable 分值上，Redis 实现的列表对象的底层实现就是快速列表，而之前的版本中可以是压缩列表或者双端列表。之前用于判定压缩列表和双端链表的两个配置 list-max-ziplist-value 和 list-max-ziplist-entries 不再使用。<br>在前面对快速列表的介绍中可以知道，快速列表是一个节点为压缩列表的双端链表，因此，双端链表就是节点为单个元素的快速列表，而压缩列表就是只有一个节点的快速列表，使用一个单独的参数 list-max-ziplist-size 就可以进行控制。</p>
<h3 id="哈希对象"><a href="#哈希对象" class="headerlink" title="哈希对象"></a>哈希对象</h3><p>如果用压缩列表作为哈希对象的底层实现，那么会将键值对保存在压缩列表的相邻两个节点中，哈希键在前，哈希值在后，所有的键值对按照插入的顺序依次放入压缩列表中。<br>当以下两个条件同时满足时，使用压缩列表作为底层实现：</p>
<ul>
<li>保存的所有的字符串对象的长度都不大于 hash-max-ziplist-value 设定的值（默认为 64 字节）</li>
<li>保存的字符串对象的数量不大于 hash-max-ziplist-entries 设定的值（默认为 512）</li>
</ul>
<p>虽然用压缩列表实现的哈希对象在进行键值查询的时候需要通过遍历列表的方式进行查找，但是由于限制了数量，所以查找操作依旧是常数级的时间复杂度。而通过压缩列表的方式，可以节省存储空间。这里使用了用时间换空间的思想，即在对操作时间影响不大的情况下，尽量压缩存储空间，这个思想就是引入压缩列表最主要的动机，在有序集合对象的实现中也是同样的考虑。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">hashTypeTryConversion</span><span class="params">(robj *o, robj **argv, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> i;</div><div class="line">    <span class="keyword">if</span> (o-&gt;encoding != OBJ_ENCODING_ZIPLIST) <span class="keyword">return</span>;</div><div class="line">    <span class="keyword">for</span> (i = start; i &lt;= end; i++) &#123;</div><div class="line">        <span class="comment">// 这边只检查字符串的长度，时间复杂度为 O(1)</span></div><div class="line">        <span class="keyword">if</span> (sdsEncodedObject(argv[i]) &amp;&amp;</div><div class="line">            sdslen(argv[i]-&gt;ptr) &gt; server.hash_max_ziplist_value)</div><div class="line">        &#123;</div><div class="line">            hashTypeConvert(o, OBJ_ENCODING_HT);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">hashTypeSet</span><span class="params">(robj *o, sds field, sds value, <span class="keyword">int</span> flags)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> update = <span class="number">0</span>;</div><div class="line">    <span class="keyword">if</span> (o-&gt;encoding == OBJ_ENCODING_ZIPLIST) &#123;</div><div class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> *zl, *fptr, *vptr;</div><div class="line">        zl = o-&gt;ptr;</div><div class="line">        fptr = ziplistIndex(zl, ZIPLIST_HEAD);</div><div class="line">        <span class="keyword">if</span> (fptr != <span class="literal">NULL</span>) &#123;</div><div class="line">            fptr = ziplistFind(fptr, (<span class="keyword">unsigned</span> <span class="keyword">char</span>*)field, sdslen(field), <span class="number">1</span>);</div><div class="line">            <span class="keyword">if</span> (fptr != <span class="literal">NULL</span>) &#123;</div><div class="line">                <span class="comment">/* Grab pointer to the value (fptr points to the field)</span></div><div class="line">                 *</div><div class="line">                 * 如果能找到对应的键，就更新对应的值</div><div class="line">                 */</div><div class="line">                vptr = ziplistNext(zl, fptr);</div><div class="line">                serverAssert(vptr != <span class="literal">NULL</span>);</div><div class="line">                update = <span class="number">1</span>;</div><div class="line">                <span class="comment">/* Delete value */</span></div><div class="line">                zl = ziplistDelete(zl, &amp;vptr);</div><div class="line">                <span class="comment">/* Insert new value */</span></div><div class="line">                zl = ziplistInsert(zl, vptr, (<span class="keyword">unsigned</span> <span class="keyword">char</span>*)value,</div><div class="line">                        sdslen(value));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 如果不是更新，则将对应的键值对插入表尾</span></div><div class="line">        <span class="keyword">if</span> (!update) &#123;</div><div class="line">            <span class="comment">/* Push new field/value pair onto the tail of the ziplist */</span></div><div class="line">            zl = ziplistPush(zl, (<span class="keyword">unsigned</span> <span class="keyword">char</span>*)field, sdslen(field),</div><div class="line">                    ZIPLIST_TAIL);</div><div class="line">            zl = ziplistPush(zl, (<span class="keyword">unsigned</span> <span class="keyword">char</span>*)value, sdslen(value),</div><div class="line">                    ZIPLIST_TAIL);</div><div class="line">        &#125;</div><div class="line">        o-&gt;ptr = zl;</div><div class="line">        <span class="comment">/* Check if the ziplist needs to be converted to a hash table</span></div><div class="line">         *</div><div class="line">         * 如果节点数超过 hash_max_ziplist_entries 设置的值，则需要转换成 hashtable，如果有必要的话</div><div class="line">         */</div><div class="line">        <span class="keyword">if</span> (hashTypeLength(o) &gt; server.hash_max_ziplist_entries)</div><div class="line">            hashTypeConvert(o, OBJ_ENCODING_HT);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;encoding == OBJ_ENCODING_HT) &#123;</div><div class="line">        <span class="comment">// 查找键，如果存在，则进行更新，否则进行创建</span></div><div class="line">        dictEntry *de = dictFind(o-&gt;ptr,field);</div><div class="line">        <span class="keyword">if</span> (de) &#123;</div><div class="line">            sdsfree(dictGetVal(de));</div><div class="line">            <span class="keyword">if</span> (flags &amp; HASH_SET_TAKE_VALUE) &#123;</div><div class="line">                dictGetVal(de) = value;</div><div class="line">                value = <span class="literal">NULL</span>;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                dictGetVal(de) = sdsdup(value);</div><div class="line">            &#125;</div><div class="line">            update = <span class="number">1</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            sds f,v;</div><div class="line">            <span class="keyword">if</span> (flags &amp; HASH_SET_TAKE_FIELD) &#123;</div><div class="line">                f = field;</div><div class="line">                field = <span class="literal">NULL</span>;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                f = sdsdup(field);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (flags &amp; HASH_SET_TAKE_VALUE) &#123;</div><div class="line">                v = value;</div><div class="line">                value = <span class="literal">NULL</span>;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                v = sdsdup(value);</div><div class="line">            &#125;</div><div class="line">            dictAdd(o-&gt;ptr,f,v);</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        serverPanic(<span class="string">"Unknown hash encoding"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/* Free SDS strings we did not referenced elsewhere if the flags</span></div><div class="line">     * want this function to be responsible.</div><div class="line">     *</div><div class="line">     * 根据 flags 的设置选择性释放键值</div><div class="line">     */</div><div class="line">    <span class="keyword">if</span> (flags &amp; HASH_SET_TAKE_FIELD &amp;&amp; field) sdsfree(field);</div><div class="line">    <span class="keyword">if</span> (flags &amp; HASH_SET_TAKE_VALUE &amp;&amp; value) sdsfree(value);</div><div class="line">    <span class="keyword">return</span> update;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="集合对象"><a href="#集合对象" class="headerlink" title="集合对象"></a>集合对象</h3><p>当以下两个条件同时满足时，使用整数集合作为底层实现：</p>
<ol>
<li>保存的所有元素都是整数</li>
<li>保存的数量不超过 set-max-intset-entries 设置的值（默认为 512）</li>
</ol>
<p>在使用哈希表作为底层实现时，所有的集合元素都作为哈希键保存，而对应的哈希值则设置为 NULL。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">setTypeAdd</span><span class="params">(robj *subject, sds value)</span> </span>&#123;</div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> llval;</div><div class="line">    <span class="keyword">if</span> (subject-&gt;encoding == OBJ_ENCODING_HT) &#123;</div><div class="line">        dict *ht = subject-&gt;ptr;</div><div class="line">        <span class="comment">// 如果已经存在，dictAddRaw 返回的是 NULL，跳过处理</span></div><div class="line">        <span class="comment">// 否则将 value 作为键存入，值设为 NULL</span></div><div class="line">        dictEntry *de = dictAddRaw(ht,value,<span class="literal">NULL</span>);</div><div class="line">        <span class="keyword">if</span> (de) &#123;</div><div class="line">            dictSetKey(ht,de,sdsdup(value));</div><div class="line">            dictSetVal(ht,de,<span class="literal">NULL</span>);</div><div class="line">            <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (subject-&gt;encoding == OBJ_ENCODING_INTSET) &#123;</div><div class="line">        <span class="comment">// 判断是否是整数值，如果是，则插入，否则的话，需要把 intset 换成 hashtable</span></div><div class="line">        <span class="keyword">if</span> (isSdsRepresentableAsLongLong(value,&amp;llval) == C_OK) &#123;</div><div class="line">            <span class="keyword">uint8_t</span> success = <span class="number">0</span>;</div><div class="line">            subject-&gt;ptr = intsetAdd(subject-&gt;ptr,llval,&amp;success);</div><div class="line">            <span class="keyword">if</span> (success) &#123;</div><div class="line">                <span class="comment">/* Convert to regular set when the intset contains</span></div><div class="line">                 * too many entries.</div><div class="line">                 *</div><div class="line">                 * 如果节点数过多，则将 intset 转成 hashtable</div><div class="line">                 */</div><div class="line">                <span class="keyword">if</span> (intsetLen(subject-&gt;ptr) &gt; server.set_max_intset_entries)</div><div class="line">                    setTypeConvert(subject,OBJ_ENCODING_HT);</div><div class="line">                <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">/* Failed to get integer from object, convert to regular set. */</span></div><div class="line">            setTypeConvert(subject,OBJ_ENCODING_HT);</div><div class="line">            <span class="comment">/* The set *was* an intset and this value is not integer</span></div><div class="line">             * encodable, so dictAdd should always work. */</div><div class="line">            serverAssert(dictAdd(subject-&gt;ptr,sdsdup(value),<span class="literal">NULL</span>) == DICT_OK);</div><div class="line">            <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        serverPanic(<span class="string">"Unknown set encoding"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="有序集合对象"><a href="#有序集合对象" class="headerlink" title="有序集合对象"></a>有序集合对象</h3><p>有序集合对象的底层实现可以是压缩列表，也可以是跳跃表。当以下两个条件同时满足时，使用压缩列表作为底层实现：</p>
<ul>
<li>保存的所有的字符串对象的长度都不大于 zset-max-ziplist-value 设定的值（默认为 64 字节）</li>
<li>保存的字符串对象的数量不大于 zset-max-ziplist-entries 设定的值（默认为 512）<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">zsetConvertToZiplistIfNeeded</span><span class="params">(robj *zobj, <span class="keyword">size_t</span> maxelelen)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (zobj-&gt;encoding == OBJ_ENCODING_ZIPLIST) <span class="keyword">return</span>;</div><div class="line">    zset *zset = zobj-&gt;ptr;</div><div class="line">    <span class="keyword">if</span> (zset-&gt;zsl-&gt;length &lt;= server.zset_max_ziplist_entries &amp;&amp;</div><div class="line">        maxelelen &lt;= server.zset_max_ziplist_value)</div><div class="line">            zsetConvert(zobj,OBJ_ENCODING_ZIPLIST);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>当底层实现是压缩列表时，用连续的两个压缩列表的节点来保存有序集合的元素和分值，元素在前，分值在后。同时，所有的元素在压缩列表中，按照分值的大小从小到大保存在压缩列表中，因此需要找到合适的位置将新的元素插入。这样的插入操作可能会引发链式更新后续节点的操作，但是由于压缩列表中的节点数量是有限的，因此时间复杂度并不会变得特别糟糕。<br>当底层实现是跳跃表时，Redis 封装了一个新的数据结构 zset 来作为实现，包含了一个哈希表和一个跳跃表：</p>
<ul>
<li>哈希表的键为成员，值为分值，这样能用 O(1) 的时间复杂度取出对应的分值</li>
<li>而跳跃表按照分值排序成员，用于支持平均复杂度为 O(log N) 的按分值定位成员操作，以及范围操作</li>
</ul>
<p>通过空间换时间的方式，可以使得有序集合对象的各项操作的时间复杂度都维持在一个较低的水平上。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zset</span> &#123;</span></div><div class="line">    <span class="comment">// 字典，键为成员，值为分值，用于支持 O(1) 复杂度的按成员取分值操作</span></div><div class="line">    dict *dict;</div><div class="line">    <span class="comment">// 跳跃表，按分值排序成员，用于支持平均复杂度为 O(log N) 的按分值定位成员操作，以及范围操作</span></div><div class="line">    zskiplist *zsl;</div><div class="line">&#125; zset;</div></pre></td></tr></table></figure>
<p>注意，在给 zset 添加元素的时候，会进行 ziplist 到 skiplist 的转换条件判断，但是删除元素的时候并不会进行反向的判断。Redis 只有在进行 rdb 文件处理时，才会进行反向的判断。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">zsetAdd</span><span class="params">(robj *zobj, <span class="keyword">double</span> score, sds ele, <span class="keyword">int</span> *flags, <span class="keyword">double</span> *newscore)</span> </span>&#123;</div><div class="line">    <span class="comment">/* Turn options into simple to check vars. */</span></div><div class="line">    <span class="keyword">int</span> incr = (*flags &amp; ZADD_INCR) != <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> nx = (*flags &amp; ZADD_NX) != <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> xx = (*flags &amp; ZADD_XX) != <span class="number">0</span>;</div><div class="line">    *flags = <span class="number">0</span>; <span class="comment">/* We'll return our response flags. */</span></div><div class="line">    <span class="keyword">double</span> curscore;</div><div class="line">    <span class="comment">/* NaN as input is an error regardless of all the other parameters.</span></div><div class="line">     *</div><div class="line">     * 如果分值非数值型，直接返回</div><div class="line">     */</div><div class="line">    <span class="keyword">if</span> (isnan(score)) &#123;</div><div class="line">        *flags = ZADD_NAN;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/* Update the sorted set according to its encoding. */</span></div><div class="line">    <span class="keyword">if</span> (zobj-&gt;encoding == OBJ_ENCODING_ZIPLIST) &#123;</div><div class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> *eptr;</div><div class="line">        <span class="keyword">if</span> ((eptr = zzlFind(zobj-&gt;ptr,ele,&amp;curscore)) != <span class="literal">NULL</span>) &#123;</div><div class="line">            <span class="comment">/* NX? Return, same element already exists.</span></div><div class="line">             *</div><div class="line">             * ZADD_NX 被设置，所以直接不操作，返回</div><div class="line">             */</div><div class="line">            <span class="keyword">if</span> (nx) &#123;</div><div class="line">                *flags |= ZADD_NOP;</div><div class="line">                <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">/* Prepare the score for the increment if needed.</span></div><div class="line">             *</div><div class="line">             * 计算新的分值</div><div class="line">             */</div><div class="line">            <span class="keyword">if</span> (incr) &#123;</div><div class="line">                score += curscore;</div><div class="line">                <span class="keyword">if</span> (isnan(score)) &#123;</div><div class="line">                    *flags |= ZADD_NAN;</div><div class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (newscore) *newscore = score;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">/* Remove and re-insert when score changed.</span></div><div class="line">             *</div><div class="line">             * 执行到这里，说明 ZADD_NX 没有被设置，所以直接替换原有的元素</div><div class="line">             */</div><div class="line">            <span class="keyword">if</span> (score != curscore) &#123;</div><div class="line">                zobj-&gt;ptr = zzlDelete(zobj-&gt;ptr,eptr);</div><div class="line">                zobj-&gt;ptr = zzlInsert(zobj-&gt;ptr,ele,score);</div><div class="line">                *flags |= ZADD_UPDATED;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!xx) &#123;</div><div class="line">            <span class="comment">/* Optimize: check if the element is too large or the list</span></div><div class="line">             * becomes too long *before* executing zzlInsert.</div><div class="line">             *</div><div class="line">             * 在这个分支里，元素原先不存在，这个时候需要插入新元素</div><div class="line">             * 这个操作可能导致元素个数过多，或者元素大小过大，使得 zset 的编码由 ziplist 变为 skiplist</div><div class="line">             */</div><div class="line">            zobj-&gt;ptr = zzlInsert(zobj-&gt;ptr,ele,score);</div><div class="line">            <span class="keyword">if</span> (zzlLength(zobj-&gt;ptr) &gt; server.zset_max_ziplist_entries)</div><div class="line">                zsetConvert(zobj,OBJ_ENCODING_SKIPLIST);</div><div class="line">            <span class="keyword">if</span> (sdslen(ele) &gt; server.zset_max_ziplist_value)</div><div class="line">                zsetConvert(zobj,OBJ_ENCODING_SKIPLIST);</div><div class="line">            <span class="keyword">if</span> (newscore) *newscore = score;</div><div class="line">            *flags |= ZADD_ADDED;</div><div class="line">            <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// ZADD_XX 被设置，所以直接不操作，返回</span></div><div class="line">            *flags |= ZADD_NOP;</div><div class="line">            <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (zobj-&gt;encoding == OBJ_ENCODING_SKIPLIST) &#123;</div><div class="line">        zset *zs = zobj-&gt;ptr;</div><div class="line">        zskiplistNode *znode;</div><div class="line">        dictEntry *de;</div><div class="line">        de = dictFind(zs-&gt;dict,ele);</div><div class="line">        <span class="keyword">if</span> (de != <span class="literal">NULL</span>) &#123;</div><div class="line">            <span class="comment">/* NX? Return, same element already exists.</span></div><div class="line">             *</div><div class="line">             * ZADD_NX 被设置，所以直接不操作，返回</div><div class="line">             */</div><div class="line">            <span class="keyword">if</span> (nx) &#123;</div><div class="line">                *flags |= ZADD_NOP;</div><div class="line">                <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">            curscore = *(<span class="keyword">double</span>*)dictGetVal(de);</div><div class="line">            <span class="comment">/* Prepare the score for the increment if needed.</span></div><div class="line">             *</div><div class="line">             * 计算新的分值</div><div class="line">             */</div><div class="line">            <span class="keyword">if</span> (incr) &#123;</div><div class="line">                score += curscore;</div><div class="line">                <span class="keyword">if</span> (isnan(score)) &#123;</div><div class="line">                    *flags |= ZADD_NAN;</div><div class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (newscore) *newscore = score;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">/* Remove and re-insert when score changes.</span></div><div class="line">             *</div><div class="line">             * 执行到这里，说明 ZADD_NX 没有被设置，所以直接替换原有的元素</div><div class="line">             */</div><div class="line">            <span class="keyword">if</span> (score != curscore) &#123;</div><div class="line">                zskiplistNode *node;</div><div class="line">                serverAssert(zslDelete(zs-&gt;zsl,curscore,ele,&amp;node));</div><div class="line">                znode = zslInsert(zs-&gt;zsl,score,node-&gt;ele);</div><div class="line">                <span class="comment">/* We reused the node-&gt;ele SDS string, free the node now</span></div><div class="line">                 * since zslInsert created a new one.</div><div class="line">                 *</div><div class="line">                 * 在 zslInsert 中，为元素新建了一个 SDS，所以这边可以将老的节点释放掉</div><div class="line">                 */</div><div class="line">                node-&gt;ele = <span class="literal">NULL</span>;</div><div class="line">                zslFreeNode(node);</div><div class="line">                <span class="comment">/* Note that we did not removed the original element from</span></div><div class="line">                 * the hash table representing the sorted set, so we just</div><div class="line">                 * update the score. */</div><div class="line">                dictGetVal(de) = &amp;znode-&gt;score; <span class="comment">/* Update score ptr. */</span></div><div class="line">                *flags |= ZADD_UPDATED;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!xx) &#123;</div><div class="line">            <span class="comment">/*</span></div><div class="line">             * 这里直接添加新的元素，注意，这里不做从 skiplist 到 ziplist 的判断</div><div class="line">             * 因为从 ziplist 转换成 skiplist，说明至少一个条件不满足，而这边并不会使不满足的条件重新被满足</div><div class="line">             */</div><div class="line">            ele = sdsdup(ele);</div><div class="line">            znode = zslInsert(zs-&gt;zsl,score,ele);</div><div class="line">            serverAssert(dictAdd(zs-&gt;dict,ele,&amp;znode-&gt;score) == DICT_OK);</div><div class="line">            *flags |= ZADD_ADDED;</div><div class="line">            <span class="keyword">if</span> (newscore) *newscore = score;</div><div class="line">            <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// ZADD_XX 被设置，所以直接不操作，返回</span></div><div class="line">            *flags |= ZADD_NOP;</div><div class="line">            <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        serverPanic(<span class="string">"Unknown sorted set encoding"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* Never reached. */</span></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">zsetDel</span><span class="params">(robj *zobj, sds ele)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (zobj-&gt;encoding == OBJ_ENCODING_ZIPLIST) &#123;</div><div class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> *eptr;</div><div class="line">        <span class="keyword">if</span> ((eptr = zzlFind(zobj-&gt;ptr,ele,<span class="literal">NULL</span>)) != <span class="literal">NULL</span>) &#123;</div><div class="line">            zobj-&gt;ptr = zzlDelete(zobj-&gt;ptr,eptr);</div><div class="line">            <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (zobj-&gt;encoding == OBJ_ENCODING_SKIPLIST) &#123;</div><div class="line">        zset *zs = zobj-&gt;ptr;</div><div class="line">        dictEntry *de;</div><div class="line">        <span class="keyword">double</span> score;</div><div class="line">        <span class="comment">// 这边没有从字典中立刻删除是因为还要获取分值</span></div><div class="line">        de = dictUnlink(zs-&gt;dict,ele);</div><div class="line">        <span class="keyword">if</span> (de != <span class="literal">NULL</span>) &#123;</div><div class="line">            <span class="comment">/* Get the score in order to delete from the skiplist later. */</span></div><div class="line">            score = *(<span class="keyword">double</span>*)dictGetVal(de);</div><div class="line">            <span class="comment">/* Delete from the hash table and later from the skiplist.</span></div><div class="line">             * Note that the order is important: deleting from the skiplist</div><div class="line">             * actually releases the SDS string representing the element,</div><div class="line">             * which is shared between the skiplist and the hash table, so</div><div class="line">             * we need to delete from the skiplist as the final step.</div><div class="line">             *</div><div class="line">             * 注意：一定要先从 dict 中删除以后，再从 skiplist 中删除</div><div class="line">             * 因为在 skiplist 中删除节点，会将 ele 也进行释放</div><div class="line">             */</div><div class="line">            dictFreeUnlinkedEntry(zs-&gt;dict,de);</div><div class="line">            <span class="comment">/* Delete from skiplist.</span></div><div class="line">             *</div><div class="line">             * 从 skiplist 中删除对应的元素</div><div class="line">             */</div><div class="line">            <span class="keyword">int</span> retval = zslDelete(zs-&gt;zsl,score,ele,<span class="literal">NULL</span>);</div><div class="line">            serverAssert(retval);</div><div class="line">            <span class="keyword">if</span> (htNeedsResize(zs-&gt;dict)) dictResize(zs-&gt;dict);</div><div class="line">            <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        serverPanic(<span class="string">"Unknown sorted set encoding"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* No such element found. */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/11/22/redis_quick_list/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="柿子">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柿子的果盘">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/11/22/redis_quick_list/" itemprop="url">Redis数据结构: 快速列表</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-11-22T00:00:00+08:00">
                2016-11-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/开源项目/" itemprop="url" rel="index">
                    <span itemprop="name">开源项目</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在前面对于压缩列表的介绍中，我们可以知道压缩列表的一些缺点，如查找操作需要 O(N) 的时间复杂度（即使有对应节点的索引值），数据变动的时候可能会引发连锁的更新，这些缺点决定了压缩列表无法用于大规模的数据。而快速列表的设计，则一定程度上克服了这些缺点，在空间利用率和时间复杂度上取得一个平衡。</p>
<p>快速列表的本质是一个双端链表，它的每一个节点都是压缩列表。这样的设计好处是：</p>
<ul>
<li>可以通过限制压缩列表的节点数和长度，使得双端链表的每个节点对应的压缩列表不会太大，避免更新数据产生 realloc 时需要大量的数据拷贝；</li>
<li>使用压缩列表作为节点，可以使得连续的节点的存储在同一段内存空间中，减少内存碎片，同时提高存储效率；</li>
<li>由于压缩列表中记录了节点数，所以在使用索引进行查找时，可以比单纯使用双端链表或压缩列表更快。</li>
</ul>
<p>此外，由于 Redis 频繁地在快速列表的两端进行操作，而中间的节点比较少被使用到，因此，使用 LZF 压缩算法对中间的压缩列表进行压缩能够进一步地节省空间。</p>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>quicklist.h 中定义了快速列表的节点结构，包含了：</p>
<ul>
<li>prev、next：前驱节点和后继节点的指针</li>
<li>zl：指向压缩列表的指针</li>
<li>sz：压缩列表中的字节数，包括了 zlbytes、zltail、zllen、zlend 和各个数据项，此外，即使压缩列表被压缩了，这边表示的依旧是压缩前的字节数<br>各类标记，这里使用了一个 C 语言的语法，unsigned int count : 16 表示使用 16 个 bit 来存储 count 变量，因此使用了 32 bit（即 2 个字节）来存储这些标记，包括：<ul>
<li>count（16 bits）：压缩列表包含的数据项</li>
<li>encoding（2 bits）：表示是否压缩过，未压缩则是 1，压缩过的则是 2</li>
<li>container（2 bits）：预留字段，当前是固定值 2</li>
<li>recompress（1 bit）：置为 1 的时候表示需要将压缩列表重新压缩，由于在遍历的时候，需要把压缩的节点解压后使用，所以解压后设置标志位，以便后面再进行压缩</li>
<li>attempted_compress（1 bit）：测试时用的字段，表示不需要进行压缩</li>
<li>extra（10 bits）：还未用上的预留空间</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> &#123;</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> *<span class="title">prev</span>;</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> *<span class="title">next</span>;</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *zl;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> sz;             <span class="comment">/* ziplist size in bytes */</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> count : <span class="number">16</span>;     <span class="comment">/* count of items in ziplist */</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> encoding : <span class="number">2</span>;   <span class="comment">/* RAW==1 or LZF==2 */</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> container : <span class="number">2</span>;  <span class="comment">/* NONE==1 or ZIPLIST==2 */</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> recompress : <span class="number">1</span>; <span class="comment">/* was this node previous compressed? */</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> attempted_compress : <span class="number">1</span>; <span class="comment">/* node can't compress; too small */</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> extra : <span class="number">10</span>; <span class="comment">/* more bits to steal for future usage */</span></div><div class="line">&#125; quicklistNode;</div></pre></td></tr></table></figure>
<p>quicklistLZF 表示了一个被压缩的节点结构，其中：</p>
<ul>
<li>sz：表示压缩以后压缩列表的字节数</li>
<li>compressed：存放压缩后的压缩列表的字节数组，与 SDS 的 buf 一样，这是一个柔性数组。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklistLZF</span> &#123;</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> sz; <span class="comment">/* LZF size in bytes*/</span></div><div class="line">    <span class="keyword">char</span> compressed[];</div><div class="line">&#125; quicklistLZF;</div></pre></td></tr></table></figure>
<p>快速列表的结构则包括：</p>
<ul>
<li>head、tail：列表表头和表尾指针</li>
<li>count：所有的压缩列表的节点数总和</li>
<li>len：快速列表的节点数</li>
<li>32 位的标记：<ul>
<li>fill（16 bits）：ziplist 大小设置，存放 list-max-ziplist-size 参数的值<br>若为负数，则表示ziplist的最大字节数，取值为 -1（4 Kb），-2（8 Kb），-3（16 Kb），-4（32 Kb），-5（64 Kb）<br>若为正数，则表示ziplist的最大节点数，最大为 8192（2^13）</li>
<li>compress（16 bits）：节点压缩深度设置，存放 list-compress-depth 参数的值，表示前后各有几个节点不压缩，0 是个特殊值，表示所有节点都不压缩，这是 Redis 的默认值</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklist</span> &#123;</span></div><div class="line">    quicklistNode *head;</div><div class="line">    quicklistNode *tail;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> count;        <span class="comment">/* total count of all entries in all ziplists */</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> len;           <span class="comment">/* number of quicklistNodes */</span></div><div class="line">    <span class="keyword">int</span> fill : <span class="number">16</span>;              <span class="comment">/* fill factor for individual nodes */</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> compress : <span class="number">16</span>; <span class="comment">/* depth of end nodes not to compress;0=off */</span></div><div class="line">&#125; quicklist;</div></pre></td></tr></table></figure>
<p>快速列表中 fill 属性的设置是为了使存储效率和时间复杂度达到一个平衡：</p>
<ul>
<li>如果压缩列表的节点数太多，则会导致分配连续内存空间的难度加大，同时更新节点数据操作造成大量数据拷贝的风险加大；</li>
<li>如果压缩列表的节点数太少，则会使快速列表退化成双端链表，存储效率低，内存空间随便多。</li>
</ul>
<p>根据使用的场景不同，可以对应地设置限定压缩列表的字节数（每个节点需要的存储空间较大时）或节点数（每个节点需要的存储空间较小时），同时这个参数的设置，也影响了 quicklistNode 结构中的 count 的位数：</p>
<ul>
<li>若这个参数取正值时，压缩列表的最大个数被限定在 2^15（实际上限制为 8192，即 2^13），可以使用 16 bits 进行存储；</li>
<li>若这个参数取负值时，压缩列表的最大字节数是 64 K，由于每一个节点至少占用 2 个字节，因此最大的数量为 32 K，也可以使用 16 bits 进行存储。</li>
</ul>
<p>而 compress 属性的设置主要是由于快速列表的使用场景是针对列表两端的节点进行频繁操作，而对于列表中间的节点进行操作的频率很低，这样压缩中间的节点，可以节省空间，而两端的节点不压缩则方便操作。</p>
<h3 id="压缩列表大小的判定"><a href="#压缩列表大小的判定" class="headerlink" title="压缩列表大小的判定"></a>压缩列表大小的判定</h3><p>由于快速列表设计的关键是压缩列表的大小限定，通过列表结构中的 fill 属性进行约束，因此在进行压缩列表新节点的插入，或者两个压缩列表的合并时，需要判定是否满足 fill 定义的限制条件，具体代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line">REDIS_STATIC <span class="keyword">int</span> _quicklistNodeAllowInsert(<span class="keyword">const</span> quicklistNode *node,</div><div class="line">                                           <span class="keyword">const</span> <span class="keyword">int</span> fill, <span class="keyword">const</span> <span class="keyword">size_t</span> sz) &#123;</div><div class="line">    <span class="keyword">if</span> (unlikely(!node))</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> ziplist_overhead;</div><div class="line">    <span class="comment">/* size of previous offset</span></div><div class="line">     *</div><div class="line">     * 判断 header 占用的字节数</div><div class="line">     */</div><div class="line">    <span class="keyword">if</span> (sz &lt; <span class="number">254</span>)</div><div class="line">        ziplist_overhead = <span class="number">1</span>;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        ziplist_overhead = <span class="number">5</span>;</div><div class="line">    <span class="comment">/* size of forward offset</span></div><div class="line">     *</div><div class="line">     * 判断 encoding 占用的字节数</div><div class="line">     */</div><div class="line">    <span class="keyword">if</span> (sz &lt; <span class="number">64</span>)</div><div class="line">        ziplist_overhead += <span class="number">1</span>;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (likely(sz &lt; <span class="number">16384</span>))</div><div class="line">        ziplist_overhead += <span class="number">2</span>;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        ziplist_overhead += <span class="number">5</span>;</div><div class="line">    <span class="comment">/* new_sz overestimates if 'sz' encodes to an integer type</span></div><div class="line">     *</div><div class="line">     * 当新节点存入的是整型数时，这边会过高估计使用的字节数</div><div class="line">     */</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> new_sz = node-&gt;sz + sz + ziplist_overhead;</div><div class="line">    <span class="comment">// 首先判断字节数是否满足要求，若 fill &gt; 0，则表示对字节数没有限制，只对数量进行限制</span></div><div class="line">    <span class="keyword">if</span> (likely(_quicklistNodeSizeMeetsOptimizationRequirement(new_sz, fill)))</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!sizeMeetsSafetyLimit(new_sz))</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    <span class="comment">// 若到这里进行判断，则要么是字节数不满足限制（这种情况下 fill 为负数，这边也肯定不满足要求）</span></div><div class="line">    <span class="comment">// 要么是字节数没有限制，而节点数有限制，此时 fill 为正数</span></div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="keyword">int</span>)node-&gt;count &lt; fill)</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line">REDIS_STATIC <span class="keyword">int</span> _quicklistNodeAllowMerge(<span class="keyword">const</span> quicklistNode *a,</div><div class="line">                                          <span class="keyword">const</span> quicklistNode *b,</div><div class="line">                                          <span class="keyword">const</span> <span class="keyword">int</span> fill) &#123;</div><div class="line">    <span class="keyword">if</span> (!a || !b)</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    <span class="comment">/* approximate merged ziplist size (- 11 to remove one ziplist</span></div><div class="line">     * header/trailer)</div><div class="line">     *</div><div class="line">     * 11 是 header 和 tail 的大小，合并以后只需要一个 header 和一个 tail</div><div class="line">     */</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> merge_sz = a-&gt;sz + b-&gt;sz - <span class="number">11</span>;</div><div class="line">    <span class="comment">// 首先判断字节数是否满足条件</span></div><div class="line">    <span class="keyword">if</span> (likely(_quicklistNodeSizeMeetsOptimizationRequirement(merge_sz, fill)))</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    <span class="comment">// 其次判断是否满足最大字节数的条件</span></div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!sizeMeetsSafetyLimit(merge_sz))</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    <span class="comment">// 判断节点数是否满足条件</span></div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="keyword">int</span>)(a-&gt;count + b-&gt;count) &lt;= fill)</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Push-和-Pop-操作"><a href="#Push-和-Pop-操作" class="headerlink" title="Push 和 Pop 操作"></a>Push 和 Pop 操作</h3><p>如前所述，快速列表的操作经常在两端进行，因此定义了 Push 和 Pop 两个操作。<br>在进行 Push 操作的时候，需要判断表头节点（或表尾节点）是否有足够的空间（满足 fill 属性）可以存储新的节点。若可以存储，则直接存入，否则需要新建一个快速列表节点（即压缩列表）进行存储。具体代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">quicklistPushHead</span><span class="params">(quicklist *quicklist, <span class="keyword">void</span> *value, <span class="keyword">size_t</span> sz)</span> </span>&#123;</div><div class="line">    quicklistNode *orig_head = quicklist-&gt;head;</div><div class="line">    <span class="keyword">if</span> (likely(</div><div class="line">            _quicklistNodeAllowInsert(quicklist-&gt;head, quicklist-&gt;fill, sz))) &#123;</div><div class="line">        quicklist-&gt;head-&gt;zl =</div><div class="line">            ziplistPush(quicklist-&gt;head-&gt;zl, value, sz, ZIPLIST_HEAD);</div><div class="line">        quicklistNodeUpdateSz(quicklist-&gt;head);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        quicklistNode *node = quicklistCreateNode();</div><div class="line">        node-&gt;zl = ziplistPush(ziplistNew(), value, sz, ZIPLIST_HEAD);</div><div class="line">        quicklistNodeUpdateSz(node);</div><div class="line">        _quicklistInsertNodeBefore(quicklist, quicklist-&gt;head, node);</div><div class="line">    &#125;</div><div class="line">    quicklist-&gt;count++;</div><div class="line">    quicklist-&gt;head-&gt;count++;</div><div class="line">    <span class="keyword">return</span> (orig_head != quicklist-&gt;head);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">quicklistPushTail</span><span class="params">(quicklist *quicklist, <span class="keyword">void</span> *value, <span class="keyword">size_t</span> sz)</span> </span>&#123;</div><div class="line">    quicklistNode *orig_tail = quicklist-&gt;tail;</div><div class="line">    <span class="keyword">if</span> (likely(</div><div class="line">            _quicklistNodeAllowInsert(quicklist-&gt;tail, quicklist-&gt;fill, sz))) &#123;</div><div class="line">        quicklist-&gt;tail-&gt;zl =</div><div class="line">            ziplistPush(quicklist-&gt;tail-&gt;zl, value, sz, ZIPLIST_TAIL);</div><div class="line">        quicklistNodeUpdateSz(quicklist-&gt;tail);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        quicklistNode *node = quicklistCreateNode();</div><div class="line">        node-&gt;zl = ziplistPush(ziplistNew(), value, sz, ZIPLIST_TAIL);</div><div class="line">        quicklistNodeUpdateSz(node);</div><div class="line">        _quicklistInsertNodeAfter(quicklist, quicklist-&gt;tail, node);</div><div class="line">    &#125;</div><div class="line">    quicklist-&gt;count++;</div><div class="line">    quicklist-&gt;tail-&gt;count++;</div><div class="line">    <span class="keyword">return</span> (orig_tail != quicklist-&gt;tail);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicklistPush</span><span class="params">(quicklist *quicklist, <span class="keyword">void</span> *value, <span class="keyword">const</span> <span class="keyword">size_t</span> sz,</span></span></div><div class="line">                   <span class="keyword">int</span> where) &#123;</div><div class="line">    <span class="keyword">if</span> (where == QUICKLIST_HEAD) &#123;</div><div class="line">        quicklistPushHead(quicklist, value, sz);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (where == QUICKLIST_TAIL) &#123;</div><div class="line">        quicklistPushTail(quicklist, value, sz);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在进行 Pop 操作的时候，需要根据传入的 saver 函数将取出的节点内容保存在对应的指针中：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line">int quicklistPopCustom(quicklist *quicklist, int where, unsigned char **data,</div><div class="line">                       unsigned int *sz, long long *sval,</div><div class="line">                       void *(*saver)(unsigned char *data, unsigned int sz)) &#123;</div><div class="line">    unsigned char *p;</div><div class="line">    unsigned char *vstr;</div><div class="line">    unsigned int vlen;</div><div class="line">    long long vlong;</div><div class="line">    int pos = (where == QUICKLIST_HEAD) ? 0 : -1;</div><div class="line">    if (quicklist-&gt;count == 0)</div><div class="line">        return 0;</div><div class="line">    if (data)</div><div class="line">        *data = NULL;</div><div class="line">    if (sz)</div><div class="line">        *sz = 0;</div><div class="line">    if (sval)</div><div class="line">        *sval = -123456789;</div><div class="line">    quicklistNode *node;</div><div class="line">    if (where == QUICKLIST_HEAD &amp;&amp; quicklist-&gt;head) &#123;</div><div class="line">        node = quicklist-&gt;head;</div><div class="line">    &#125; else if (where == QUICKLIST_TAIL &amp;&amp; quicklist-&gt;tail) &#123;</div><div class="line">        node = quicklist-&gt;tail;</div><div class="line">    &#125; else &#123;</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line">    // 取出对应的节点</div><div class="line">    p = ziplistIndex(node-&gt;zl, pos);</div><div class="line">    if (ziplistGet(p, &amp;vstr, &amp;vlen, &amp;vlong)) &#123;</div><div class="line">        if (vstr) &#123;</div><div class="line">            if (data)</div><div class="line">                *data = saver(vstr, vlen);</div><div class="line">            if (sz)</div><div class="line">                *sz = vlen;</div><div class="line">        &#125; else &#123;</div><div class="line">            if (data)</div><div class="line">                *data = NULL;</div><div class="line">            if (sval)</div><div class="line">                *sval = vlong;</div><div class="line">        &#125;</div><div class="line">        quicklistDelIndex(quicklist, node, &amp;p);</div><div class="line">        return 1;</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div><div class="line">REDIS_STATIC void *_quicklistSaver(unsigned char *data, unsigned int sz) &#123;</div><div class="line">    unsigned char *vstr;</div><div class="line">    if (data) &#123;</div><div class="line">        vstr = zmalloc(sz);</div><div class="line">        memcpy(vstr, data, sz);</div><div class="line">        return vstr;</div><div class="line">    &#125;</div><div class="line">    return NULL;</div><div class="line">&#125;</div><div class="line">int quicklistPop(quicklist *quicklist, int where, unsigned char **data,</div><div class="line">                 unsigned int *sz, long long *slong) &#123;</div><div class="line">    unsigned char *vstr;</div><div class="line">    unsigned int vlen;</div><div class="line">    long long vlong;</div><div class="line">    if (quicklist-&gt;count == 0)</div><div class="line">        return 0;</div><div class="line">    int ret = quicklistPopCustom(quicklist, where, &amp;vstr, &amp;vlen, &amp;vlong,</div><div class="line">                                 _quicklistSaver);</div><div class="line">    if (data)</div><div class="line">        *data = vstr;</div><div class="line">    if (slong)</div><div class="line">        *slong = vlong;</div><div class="line">    if (sz)</div><div class="line">        *sz = vlen;</div><div class="line">    return ret;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="任意位置的插入"><a href="#任意位置的插入" class="headerlink" title="任意位置的插入"></a>任意位置的插入</h3><p>除了从头部或尾部插入，快速列表还实现了从任意指定的位置插入，这时候由于需要满足 fill 设定的压缩列表大小，会将逻辑分为如下几种情况：</p>
<ul>
<li>若当前的压缩列表有空间可以存入新的节点，则直接存入；</li>
<li>若当前的压缩列表没有空间，且插入位置在表头或表尾，则考虑前一个或后一个压缩列表是否有空间存储：<ul>
<li>若有空间，则直接存入；</li>
<li>否则，新建一个快速列表的节点，将其插入对应的位置，用于存储新节点；</li>
</ul>
</li>
<li>若当前的压缩列表没有空间，且插入位置不在表头或表尾，则需要将当前的压缩列表拆分以后，插入合适的压缩列表。</li>
</ul>
<p>具体代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div></pre></td><td class="code"><pre><div class="line">REDIS_STATIC <span class="keyword">void</span> _quicklistInsert(quicklist *quicklist, quicklistEntry *entry,</div><div class="line">                                   <span class="keyword">void</span> *value, <span class="keyword">const</span> <span class="keyword">size_t</span> sz, <span class="keyword">int</span> after) &#123;</div><div class="line">    <span class="keyword">int</span> full = <span class="number">0</span>, at_tail = <span class="number">0</span>, at_head = <span class="number">0</span>, full_next = <span class="number">0</span>, full_prev = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> fill = quicklist-&gt;fill;</div><div class="line">    quicklistNode *node = entry-&gt;node;</div><div class="line">    quicklistNode *new_node = <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">if</span> (!node) &#123;</div><div class="line">        <span class="comment">/* we have no reference node, so let's create only node in the list</span></div><div class="line">         *</div><div class="line">         * 若没有指定快速列表的节点，则新建一个节点用于存储压缩列表节点</div><div class="line">         */</div><div class="line">        D(<span class="string">"No node given!"</span>);</div><div class="line">        new_node = quicklistCreateNode();</div><div class="line">        new_node-&gt;zl = ziplistPush(ziplistNew(), value, sz, ZIPLIST_HEAD);</div><div class="line">        __quicklistInsertNode(quicklist, <span class="literal">NULL</span>, new_node, after);</div><div class="line">        new_node-&gt;count++;</div><div class="line">        quicklist-&gt;count++;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/* Populate accounting flags for easier boolean checks later</span></div><div class="line">     *</div><div class="line">     * 判断压缩列表是否还能存入新节点，插入的位置在表头或者表尾</div><div class="line">     */</div><div class="line">    <span class="keyword">if</span> (!_quicklistNodeAllowInsert(node, fill, sz)) &#123;</div><div class="line">        D(<span class="string">"Current node is full with count %d with requested fill %lu"</span>,</div><div class="line">          node-&gt;count, fill);</div><div class="line">        full = <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (after &amp;&amp; (entry-&gt;offset == node-&gt;count)) &#123;</div><div class="line">        D(<span class="string">"At Tail of current ziplist"</span>);</div><div class="line">        at_tail = <span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span> (!_quicklistNodeAllowInsert(node-&gt;next, fill, sz)) &#123;</div><div class="line">            D(<span class="string">"Next node is full too."</span>);</div><div class="line">            full_next = <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (!after &amp;&amp; (entry-&gt;offset == <span class="number">0</span>)) &#123;</div><div class="line">        D(<span class="string">"At Head"</span>);</div><div class="line">        at_head = <span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span> (!_quicklistNodeAllowInsert(node-&gt;prev, fill, sz)) &#123;</div><div class="line">            D(<span class="string">"Prev node is full too."</span>);</div><div class="line">            full_prev = <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/* Now determine where and how to insert the new element</span></div><div class="line">     *</div><div class="line">     * 判断该如何插入节点</div><div class="line">     */</div><div class="line">    <span class="keyword">if</span> (!full &amp;&amp; after) &#123;</div><div class="line">        D(<span class="string">"Not full, inserting after current position."</span>);</div><div class="line">        quicklistDecompressNodeForUse(node);</div><div class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> *next = ziplistNext(node-&gt;zl, entry-&gt;zi);</div><div class="line">        <span class="comment">// 判断是否在压缩列表的表尾插入</span></div><div class="line">        <span class="keyword">if</span> (next == <span class="literal">NULL</span>) &#123;</div><div class="line">            node-&gt;zl = ziplistPush(node-&gt;zl, value, sz, ZIPLIST_TAIL);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            node-&gt;zl = ziplistInsert(node-&gt;zl, next, value, sz);</div><div class="line">        &#125;</div><div class="line">        node-&gt;count++;</div><div class="line">        quicklistNodeUpdateSz(node);</div><div class="line">        quicklistRecompressOnly(quicklist, node);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!full &amp;&amp; !after) &#123;</div><div class="line">        D(<span class="string">"Not full, inserting before current position."</span>);</div><div class="line">        quicklistDecompressNodeForUse(node);</div><div class="line">        node-&gt;zl = ziplistInsert(node-&gt;zl, entry-&gt;zi, value, sz);</div><div class="line">        node-&gt;count++;</div><div class="line">        quicklistNodeUpdateSz(node);</div><div class="line">        quicklistRecompressOnly(quicklist, node);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (full &amp;&amp; at_tail &amp;&amp; node-&gt;next &amp;&amp; !full_next &amp;&amp; after) &#123;</div><div class="line">        <span class="comment">/* If we are: at tail, next has free space, and inserting after:</span></div><div class="line">         *   - insert entry at head of next node.</div><div class="line">         *</div><div class="line">         * 如果当前压缩列表已满，而后一个节点未满，且插入在当前压缩列表的表尾，则插入到后一个节点表头</div><div class="line">         */</div><div class="line">        D(<span class="string">"Full and tail, but next isn't full; inserting next node head"</span>);</div><div class="line">        new_node = node-&gt;next;</div><div class="line">        quicklistDecompressNodeForUse(new_node);</div><div class="line">        new_node-&gt;zl = ziplistPush(new_node-&gt;zl, value, sz, ZIPLIST_HEAD);</div><div class="line">        new_node-&gt;count++;</div><div class="line">        quicklistNodeUpdateSz(new_node);</div><div class="line">        quicklistRecompressOnly(quicklist, new_node);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (full &amp;&amp; at_head &amp;&amp; node-&gt;prev &amp;&amp; !full_prev &amp;&amp; !after) &#123;</div><div class="line">        <span class="comment">/* If we are: at head, previous has free space, and inserting before:</span></div><div class="line">         *   - insert entry at tail of previous node.</div><div class="line">         *</div><div class="line">         * 如果当前压缩列表已满，而前一个节点未满，且插入在当前压缩列表的表头，则插入到前一个节点表尾</div><div class="line">         */</div><div class="line">        D(<span class="string">"Full and head, but prev isn't full, inserting prev node tail"</span>);</div><div class="line">        new_node = node-&gt;prev;</div><div class="line">        quicklistDecompressNodeForUse(new_node);</div><div class="line">        new_node-&gt;zl = ziplistPush(new_node-&gt;zl, value, sz, ZIPLIST_TAIL);</div><div class="line">        new_node-&gt;count++;</div><div class="line">        quicklistNodeUpdateSz(new_node);</div><div class="line">        quicklistRecompressOnly(quicklist, new_node);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (full &amp;&amp; ((at_tail &amp;&amp; node-&gt;next &amp;&amp; full_next &amp;&amp; after) ||</div><div class="line">                        (at_head &amp;&amp; node-&gt;prev &amp;&amp; full_prev &amp;&amp; !after))) &#123;</div><div class="line">        <span class="comment">/* If we are: full, and our prev/next is full, then:</span></div><div class="line">         *   - create new node and attach to quicklist</div><div class="line">         * 如果插入在压缩列表的表头或表尾，且前后节点也已满，则创建新快速列表节点</div><div class="line">         */</div><div class="line">        D(<span class="string">"\tprovisioning new node..."</span>);</div><div class="line">        new_node = quicklistCreateNode();</div><div class="line">        new_node-&gt;zl = ziplistPush(ziplistNew(), value, sz, ZIPLIST_HEAD);</div><div class="line">        new_node-&gt;count++;</div><div class="line">        quicklistNodeUpdateSz(new_node);</div><div class="line">        __quicklistInsertNode(quicklist, node, new_node, after);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (full) &#123;</div><div class="line">        <span class="comment">/* else, node is full we need to split it.</span></div><div class="line">         * covers both after and !after cases</div><div class="line">         *</div><div class="line">         * 如果不是在两端，则将当前的节点进行拆分后再进行插入</div><div class="line">         */</div><div class="line">        D(<span class="string">"\tsplitting node..."</span>);</div><div class="line">        quicklistDecompressNodeForUse(node);</div><div class="line">        new_node = _quicklistSplitNode(node, entry-&gt;offset, after);</div><div class="line">        new_node-&gt;zl = ziplistPush(new_node-&gt;zl, value, sz,</div><div class="line">                                   after ? ZIPLIST_HEAD : ZIPLIST_TAIL);</div><div class="line">        new_node-&gt;count++;</div><div class="line">        quicklistNodeUpdateSz(new_node);</div><div class="line">        __quicklistInsertNode(quicklist, node, new_node, after);</div><div class="line">        _quicklistMergeNodes(quicklist, node);</div><div class="line">    &#125;</div><div class="line">    quicklist-&gt;count++;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicklistInsertBefore</span><span class="params">(quicklist *quicklist, quicklistEntry *entry,</span></span></div><div class="line">                           <span class="keyword">void</span> *value, <span class="keyword">const</span> <span class="keyword">size_t</span> sz) &#123;</div><div class="line">    _quicklistInsert(quicklist, entry, value, sz, <span class="number">0</span>);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicklistInsertAfter</span><span class="params">(quicklist *quicklist, quicklistEntry *entry,</span></span></div><div class="line">                          <span class="keyword">void</span> *value, <span class="keyword">const</span> <span class="keyword">size_t</span> sz) &#123;</div><div class="line">    _quicklistInsert(quicklist, entry, value, sz, <span class="number">1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>快速列表定义了迭代器和压缩列表节点结构，并且可以从表头和表尾两个方向对所有的压缩列表中的节点进行遍历，具体的数据结构定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 快速列表的迭代器，用于遍历快速列表中所有压缩列表的所有节点，按照每个压缩列表节点进行遍历</span></div><div class="line"><span class="comment">// 可以选择遍历压缩列表的方向，从头遍历 AL_START_HEAD 或者从尾遍历 AL_START_TAIL</span></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklistIter</span> &#123;</span></div><div class="line">    <span class="keyword">const</span> quicklist *quicklist;    <span class="comment">// 遍历的快速列表指针</span></div><div class="line">    quicklistNode *current;        <span class="comment">// 遍历的快速列表节点指针</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *zi;             <span class="comment">// 遍历到的压缩列表节点的指针</span></div><div class="line">    <span class="keyword">long</span> offset;                   <span class="comment">// 遍历到的压缩列表节点的偏移量</span></div><div class="line">    <span class="keyword">int</span> direction;                 <span class="comment">// 遍历方向 AL_START_HEAD 或 AL_START_TAIL</span></div><div class="line">&#125; quicklistIter;</div><div class="line"><span class="comment">// 快速列表迭代过程中取出的压缩列表节点的结构</span></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklistEntry</span> &#123;</span></div><div class="line">    <span class="keyword">const</span> quicklist *quicklist;    <span class="comment">// 快速列表指针</span></div><div class="line">    quicklistNode *node;           <span class="comment">// 快速列表的节点指针</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *zi;             <span class="comment">// 压缩列表节点的指针</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *value;          <span class="comment">// 压缩列表节点的字符串指针（如果内容无法保存到 longval 的话）</span></div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> longval;             <span class="comment">// 压缩列表节点的数值</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> sz;               <span class="comment">// 压缩列表节点的字符串长度</span></div><div class="line">    <span class="keyword">int</span> offset;                    <span class="comment">// 压缩列表节点的索引值，如果从后向前遍历时，为负数</span></div><div class="line">&#125; quicklistEntry;</div></pre></td></tr></table></figure>
<p>以下是具体的遍历代码，在进行遍历的过程中，会逐一取出压缩列表的节点，若节点被压缩，则进行解压，同时标注 recompress 为 1，以待该节点被使用完以后重新压缩。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">quicklistNext</span><span class="params">(quicklistIter *iter, quicklistEntry *entry)</span> </span>&#123;</div><div class="line">    initEntry(entry);</div><div class="line">    <span class="keyword">if</span> (!iter) &#123;</div><div class="line">        D(<span class="string">"Returning because no iter!"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 从迭代器里获得当前压缩节点对应的快速列表信息</span></div><div class="line">    entry-&gt;quicklist = iter-&gt;quicklist;</div><div class="line">    entry-&gt;node = iter-&gt;current;</div><div class="line">    <span class="comment">// 如果当前的快速列表的节点为空，则返回</span></div><div class="line">    <span class="keyword">if</span> (!iter-&gt;current) &#123;</div><div class="line">        D(<span class="string">"Returning because current node is NULL"</span>)</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 定义一个函数指针，后面将根据遍历的方向决定具体的实现</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *(*nextFn)(<span class="keyword">unsigned</span> <span class="keyword">char</span> *, <span class="keyword">unsigned</span> <span class="keyword">char</span> *) = <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">int</span> offset_update = <span class="number">0</span>;</div><div class="line">    <span class="comment">// 如果已经有对应的指针，则说明在遍历一个压缩列表没有结束，这时候可以直接使用，否则需要解压一个快速列表的节点，然后查找对应的节点</span></div><div class="line">    <span class="keyword">if</span> (!iter-&gt;zi) &#123;</div><div class="line">        <span class="comment">/* If !zi, use current index.</span></div><div class="line">         *</div><div class="line">         * 上一个压缩列表已经遍历完了，现在要遍历一个新的快速列表节点对应的压缩列表</div><div class="line">         */</div><div class="line">        quicklistDecompressNodeForUse(iter-&gt;current);</div><div class="line">        iter-&gt;zi = ziplistIndex(iter-&gt;current-&gt;zl, iter-&gt;offset);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">/* else, use existing iterator offset and get prev/next as necessary.</span></div><div class="line">         *</div><div class="line">         * 获取下一个节点的指针和偏移量</div><div class="line">         */</div><div class="line">        <span class="keyword">if</span> (iter-&gt;direction == AL_START_HEAD) &#123;</div><div class="line">            nextFn = ziplistNext;</div><div class="line">            offset_update = <span class="number">1</span>;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (iter-&gt;direction == AL_START_TAIL) &#123;</div><div class="line">            nextFn = ziplistPrev;</div><div class="line">            offset_update = <span class="number">-1</span>;</div><div class="line">        &#125;</div><div class="line">        iter-&gt;zi = nextFn(iter-&gt;current-&gt;zl, iter-&gt;zi);</div><div class="line">        iter-&gt;offset += offset_update;</div><div class="line">    &#125;</div><div class="line">    entry-&gt;zi = iter-&gt;zi;</div><div class="line">    entry-&gt;offset = iter-&gt;offset;</div><div class="line">    <span class="keyword">if</span> (iter-&gt;zi) &#123;</div><div class="line">        <span class="comment">/* Populate value from existing ziplist position</span></div><div class="line">         *</div><div class="line">         * 如果当前的压缩列表没有遍历完成，则取出对应的节点的值</div><div class="line">         */</div><div class="line">        ziplistGet(entry-&gt;zi, &amp;entry-&gt;value, &amp;entry-&gt;sz, &amp;entry-&gt;longval);</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">/* We ran out of ziplist entries.</span></div><div class="line">         * Pick next node, update offset, then re-run retrieval.</div><div class="line">         *</div><div class="line">         * 将遍历完的节点压缩，然后按照遍历方向进行下一个快速列表节点对应的压缩列表的遍历</div><div class="line">         */</div><div class="line">        quicklistCompress(iter-&gt;quicklist, iter-&gt;current);</div><div class="line">        <span class="keyword">if</span> (iter-&gt;direction == AL_START_HEAD) &#123;</div><div class="line">            <span class="comment">/* Forward traversal */</span></div><div class="line">            D(<span class="string">"Jumping to start of next node"</span>);</div><div class="line">            iter-&gt;current = iter-&gt;current-&gt;next;</div><div class="line">            iter-&gt;offset = <span class="number">0</span>;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (iter-&gt;direction == AL_START_TAIL) &#123;</div><div class="line">            <span class="comment">/* Reverse traversal */</span></div><div class="line">            D(<span class="string">"Jumping to end of previous node"</span>);</div><div class="line">            iter-&gt;current = iter-&gt;current-&gt;prev;</div><div class="line">            iter-&gt;offset = <span class="number">-1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 获取新的压缩列表的第一个遍历节点（根据遍历方向，有可能是头节点，也可能是尾节点）</span></div><div class="line">        iter-&gt;zi = <span class="literal">NULL</span>;</div><div class="line">        <span class="keyword">return</span> quicklistNext(iter, entry);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>快速列表的主要操作都在上面进行了叙述，其它的操作可以查看相应的源代码注释。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/11/12/redis_skip_list/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="柿子">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柿子的果盘">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/11/12/redis_skip_list/" itemprop="url">Redis数据结构: 跳跃表</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-11-12T00:00:00+08:00">
                2016-11-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/开源项目/" itemprop="url" rel="index">
                    <span itemprop="name">开源项目</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>对于普通的链表而言，即使包含的元素是有序的，包括查找在内的各项操作的时间复杂度也是 O(N)，并没有使用有序的特性。而跳跃表则是对于链表的改良，通过增加额外的空间，使得各项操作的时间复杂度降低。</p>
<p>与双端链表和哈希表相比，跳跃表这个概念大部分人都会觉得陌生一些，之前学数据结构的时候学过，但从来没有使用过，现在看到 Redis 里面实现的跳跃表，就把这个数据结构温习一下，在这边也做个介绍。跳跃表通过对有序链表的每个节点增加一些前进链接，获得快速查找访问节点的能力。下图是一个跳跃表的示例（来自百度百科）：</p>
<p><img src="http://ocx5ae9jo.bkt.clouddn.com/skip-list-example.jpg" width="500px;" height="200px;"></p>
<p>跳跃表是按层建造的。底层是一个普通的有序链表。每个更高层的构建都是为了跳跃若干个节点更快地定位到需要查找的节点。在构建跳跃表的时候，设定每层会向上增长的概率为 1 / p，则第 m 层向上增长的概率为 1 / p^m；假设链表中的元素个数为 n，则在 m 层元素数目的期望是 n / p^m；当这个数量为 1 时，m = log p(n) 即为层数。而将所有的层上的节点数量相加，即 n + n / p + …… + 1 &lt; 2 n，因此跳跃表的空间复杂度是 O(N)。对于一个节点而言，它恰好层数等于 1 的概率为 1 - p，层数等于 2 的概率为 p (1 - p)，层数等于 3 的概率为 p^2 (1 - p)，因此，一个节点的平均层数为 1 (1 - p) + 2 p (1 - p) + 3 p^2 (1 - p) + … = 1 / (1 - p)，这就是一个节点对应的指针数量。<br>跳跃列表的时间复杂度的分析比较复杂，这边只给结论，它的平均时间复杂度为 O(log n)。具体的推导过程可以查看 William Pugh 的论文 <a href="ftp://ftp.cs.umd.edu/pub/skipLists/skiplists.pdf" target="_blank" rel="external">Skip Lists: A Probabilistic Alternative to Balanced Trees</a>。</p>
<p>可能也有人会问，各类的平衡树也可以用类似的时间复杂度来实现同样的功能，那么为什么 Redis 不用平衡树呢？具体的比较如下：</p>
<ul>
<li>在做范围查找的时候，平衡树比跳跃表操作要复杂。在平衡树上，我们找到指定范围的小值之后，还需要以中序遍历的顺序继续寻找其它不超过大值的节点。如果不对平衡树进行一定的改造，这里的中序遍历并不容易实现。而在skiplist上进行范围查找就非常简单，只需要在找到小值之后，对第1层链表进行若干步的遍历就可以实现。</li>
<li>平衡树的插入和删除操作可能引发子树的调整，逻辑复杂，而skiplist的插入和删除只需要修改相邻节点的指针，操作简单又快速。</li>
<li>从内存占用上来说，跳跃表比平衡树更灵活一些。一般来说，平衡树每个节点包含2个指针（分别指向左右子树），而跳跃表每个节点包含的指针数目平均为 1 / (1 - p)，具体取决于参数 p 的大小。在 Redis 实现时，p = 1 / 4，那么平均每个节点包含 1.33 个指针，所需要的存储空间比平衡树更小。</li>
<li>跳跃表的实现比平衡树更简单。</li>
</ul>
<p>基于上述的考虑，Redis 采用了性能相似，但在存储空间更节省，时间复杂度更低的跳跃表来进行有序元素的存储。</p>
<h3 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h3><p>在 server.h 中定义了跳跃表的节点结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></div><div class="line">    sds ele;                                <span class="comment">// 字符串指针</span></div><div class="line">    <span class="keyword">double</span> score;                           <span class="comment">// 分值</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span>         <span class="comment">// 后退指针</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span></div><div class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span>      <span class="comment">// 前进指针</span></div><div class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> span;                  <span class="comment">// 跨度</span></div><div class="line">    &#125; level[];                              <span class="comment">// 该结点出现在的不同层</span></div><div class="line">&#125; zskiplistNode;</div></pre></td></tr></table></figure>
<p>在这个结构中，定义了跳跃表需要的一些基本属性：成员对象、分值和不同层的前进指针和跨度。另外，多定义了一个后退指针，主要是为了能够从表尾开始遍历整个链表。另外，由于在 Redis 中跳跃表的作用比较有限，所以在最新的版本中，把跳跃表的成员对象的类型改为 sds。</p>
<p>在经典的跳跃表中，只需要使用上述定义的节点结构就可以实现跳跃表。但是为了方便诸如节点数量查询，从表尾遍历等操作，定义了一个结构存储链表的一些相关信息，具体如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">header</span>, *<span class="title">tail</span>;</span>    <span class="comment">// 表头节点和表尾节点</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> length;                   <span class="comment">// 表中节点的数量</span></div><div class="line">    <span class="keyword">int</span> level;                              <span class="comment">// 表中层数最大的节点的层数</span></div><div class="line">&#125; zskiplist;</div></pre></td></tr></table></figure>
<h3 id="各类操作"><a href="#各类操作" class="headerlink" title="各类操作"></a>各类操作</h3><p>在上述定义的结构中，我们可以进行链表相关的各类操作，由于添加操作中包含查询的相关逻辑，因此，我们就来看看添加操作的代码，查询元素，或者按照排位查询元素的逻辑也基本类似。<br>添加操作的代码在 tzset.c 中，这个操作的平均时间复杂度为 O(log N)，最差的时间复杂度为 O(N)，具体的细节参见代码的注释：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div></pre></td><td class="code"><pre><div class="line"><span class="function">zskiplistNode *<span class="title">zslInsert</span><span class="params">(zskiplist *zsl, <span class="keyword">double</span> score, robj *obj)</span> </span>&#123;</div><div class="line">    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> rank[ZSKIPLIST_MAXLEVEL];</div><div class="line">    <span class="keyword">int</span> i, level;</div><div class="line">    redisAssert(!isnan(score));</div><div class="line">    <span class="comment">// 在各个层查找节点的插入位置</span></div><div class="line">    x = zsl-&gt;header;</div><div class="line">    <span class="keyword">for</span> (i = zsl-&gt;level<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">        <span class="comment">// 如果 i 不是 zsl-&gt;level-1 层，那么 i 层的起始 rank 值为 i+1 层的 rank 值</span></div><div class="line">        <span class="comment">// 最终 rank[0] 的值加一就是新节点的前置节点的排位</span></div><div class="line">        rank[i] = i == (zsl-&gt;level<span class="number">-1</span>) ? <span class="number">0</span> : rank[i+<span class="number">1</span>];</div><div class="line">        <span class="comment">// 沿着前进指针遍历跳跃表</span></div><div class="line">        <span class="keyword">while</span> (x-&gt;level[i].forward &amp;&amp;</div><div class="line">            (x-&gt;level[i].forward-&gt;score &lt; score ||</div><div class="line">                <span class="comment">// 比对分值</span></div><div class="line">                (x-&gt;level[i].forward-&gt;score == score &amp;&amp;</div><div class="line">                <span class="comment">// 比对成员， T = O(N)</span></div><div class="line">                compareStringObjects(x-&gt;level[i].forward-&gt;obj,obj) &lt; <span class="number">0</span>))) &#123;</div><div class="line">            <span class="comment">// 记录沿途跨越了多少个节点</span></div><div class="line">            rank[i] += x-&gt;level[i].span;</div><div class="line">            <span class="comment">// 移动至下一指针</span></div><div class="line">            x = x-&gt;level[i].forward;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 记录将要和新节点相连接的节点</span></div><div class="line">        update[i] = x;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/*</span></div><div class="line">     * zslInsert() 的调用者会确保同分值且同成员的元素不会出现，</div><div class="line">     * 所以这里不需要进一步进行检查，可以直接创建新元素。</div><div class="line">     */</div><div class="line">    <span class="comment">// 获取一个随机值作为新节点的层数，</span></div><div class="line">    level = zslRandomLevel();</div><div class="line">    <span class="comment">// 如果新节点的层数比表中其他节点的层数都要大</span></div><div class="line">    <span class="comment">// 那么初始化表头节点中未使用的层，并将它们记录到 update 数组中</span></div><div class="line">    <span class="comment">// 将来也指向新节点</span></div><div class="line">    <span class="keyword">if</span> (level &gt; zsl-&gt;level) &#123;</div><div class="line">        <span class="comment">// 初始化未使用层</span></div><div class="line">        <span class="keyword">for</span> (i = zsl-&gt;level; i &lt; level; i++) &#123;</div><div class="line">            rank[i] = <span class="number">0</span>;</div><div class="line">            update[i] = zsl-&gt;header;</div><div class="line">            update[i]-&gt;level[i].span = zsl-&gt;length;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 更新表中节点最大层数</span></div><div class="line">        zsl-&gt;level = level;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 创建新节点</span></div><div class="line">    x = zslCreateNode(level,score,obj);</div><div class="line">    <span class="comment">// 将前面记录的指针指向新节点，并做相应的设置</span></div><div class="line">    <span class="comment">// T = O(1)</span></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; level; i++) &#123;</div><div class="line"></div><div class="line">        <span class="comment">// 设置新节点的 forward 指针</span></div><div class="line">        x-&gt;level[i].forward = update[i]-&gt;level[i].forward;</div><div class="line"></div><div class="line">        <span class="comment">// 将沿途记录的各个节点的 forward 指针指向新节点</span></div><div class="line">        update[i]-&gt;level[i].forward = x;</div><div class="line">        <span class="comment">/* update span covered by update[i] as x is inserted here */</span></div><div class="line">        <span class="comment">// 计算新节点跨越的节点数量</span></div><div class="line">        x-&gt;level[i].span = update[i]-&gt;level[i].span - (rank[<span class="number">0</span>] - rank[i]);</div><div class="line">        <span class="comment">// 更新新节点插入之后，沿途节点的 span 值</span></div><div class="line">        <span class="comment">// 其中的 +1 计算的是新节点</span></div><div class="line">        update[i]-&gt;level[i].span = (rank[<span class="number">0</span>] - rank[i]) + <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/* increment span for untouched levels */</span></div><div class="line">    <span class="comment">// 未接触的节点的 span 值也需要增一，这些节点直接从表头指向新节点</span></div><div class="line">    <span class="comment">// T = O(1)</span></div><div class="line">    <span class="keyword">for</span> (i = level; i &lt; zsl-&gt;level; i++) &#123;</div><div class="line">        update[i]-&gt;level[i].span++;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 设置新节点的后退指针</span></div><div class="line">    x-&gt;backward = (update[<span class="number">0</span>] == zsl-&gt;header) ? <span class="literal">NULL</span> : update[<span class="number">0</span>];</div><div class="line">    <span class="keyword">if</span> (x-&gt;level[<span class="number">0</span>].forward)</div><div class="line">        x-&gt;level[<span class="number">0</span>].forward-&gt;backward = x;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        zsl-&gt;tail = x;</div><div class="line">    <span class="comment">// 跳跃表的节点计数增一</span></div><div class="line">    zsl-&gt;length++;</div><div class="line">    <span class="keyword">return</span> x;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>此外，Redis 实现的跳跃表除了常规的链表操作以外，还增加了一些与范围相关的操作，具体的实现方式与上述的添加操作也类似。Redis 定义的范围有两种，一种是按照数值的大小定义的区间，另一种是按照字典序的先后定义的区间，跳跃表对于这两种范围都定义了操作。主要的操作有：判断给定的节点是否在范围中，范围中的第一个节点或最后一个节点，以及删除范围中的所有节点。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/11/03/redis_zip_list/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="柿子">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柿子的果盘">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/11/03/redis_zip_list/" itemprop="url">Redis数据结构: 压缩列表</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-11-03T00:00:00+08:00">
                2016-11-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/开源项目/" itemprop="url" rel="index">
                    <span itemprop="name">开源项目</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>与整数集合类似，压缩列表也是 Redis 为了节约内存而开发的。它是由一系列特殊编码的内存块构成的列表。一个压缩列表可以包含多个节点，每个节点可以保存一个长度受限的字符数组或者整数。通过特殊的编码方式，可以用最少的空间来存储不同长度的字符串和整数，使得使用的存储空间最小。</p>
<h3 id="压缩列表的基本结构"><a href="#压缩列表的基本结构" class="headerlink" title="压缩列表的基本结构"></a>压缩列表的基本结构</h3><p>一个压缩列表包含如下的字段：</p>
<ul>
<li>zlbytes：uint32_t，记录整个压缩列表占用的内存字节数</li>
<li>zltail：uint32_t，记录压缩列表表尾节点距离压缩列表的起始发位置的字节数</li>
<li>zllen：uint16_t，记录了压缩列表包含的节点数量，注意，这个节点的数量不一定是真实的数量，当节点的数量小于 65535（uint16_t 所能表达的最大的值）时，这个字段记录了节点的数量，当数量超过这个限制的时候，就需要遍历整个压缩列表才能获得节点的数量</li>
<li>entryX：在上述 10 个节点之后，是保存在这个压缩列表中的节点，长度由具体的结构决定。每个压缩列表的节点保存了一个长度受限的字节数组，或者一个整数值，具体的结构如下：<ul>
<li>previous_entry_length：记录前一个节点的长度，如果前一个节点的长度小于 254，即 1 个字节能够存储，则使用 1 个字节来存储这个长度；否则使用 5 个字节来保存，其中第一个字节固定保存 255，后续四个字节保存长度。这个字段与 zltail 联合起来，可以完成从压缩列表的末端开始，向表头遍历的操作：首先，通过表头指针和 zltail 计算获得最后一个节点的指针；然后，通过最后一个节点的 previous_entry_length 计算获得前一个节点的指针，重复上述过程，就可以持续向前直到表头</li>
<li>encoding：保存节点的 content 属性对应的数据类型和长度，encoding 的第一个字节的前两位决定了保存的数据类型<ul>
<li>00：表示的是长度小于等于 63（2^4 - 1）的字节数组，此时 encoding 的长度是 1 个字节</li>
<li>01：表示的是长度小于等于 16383（2^4 - 1）的字节数组，此时 encoding 的长度是 2 个字节</li>
<li>10：表示的是长度小于等于 4294967295（23^2 - 1）的字节数组，此时 encoding 的长度是 5 个字节，此时第一个字节除了前两位以外全部留空</li>
<li>11：表示的是整数，对应五种整数类型<ul>
<li>11000000：int16_t</li>
<li>11010000：int32_t</li>
<li>11100000：int64_t</li>
<li>11110000：24 位有符号整数</li>
<li>11111110：8 位有符号整数</li>
<li>1111xxxx：可以表示 0 - 12 这几个数，由于 0000、1110 和 1111 被占用，因此二进制值为 1 - 13，减 1 表示实际的值</li>
</ul>
</li>
</ul>
</li>
<li>content：节点保存的值</li>
</ul>
</li>
<li>zlend：uint8_t，用特殊值 0xFF（255）来标记压缩列表的末端</li>
</ul>
<h3 id="Push-和-Pop-操作"><a href="#Push-和-Pop-操作" class="headerlink" title="Push 和 Pop 操作"></a>Push 和 Pop 操作</h3><p>Redis 的压缩列表支持从两端插入（Push）或删除（Pop）节点，以 Push 为例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">ziplistPush</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl, <span class="keyword">unsigned</span> <span class="keyword">char</span> *s, <span class="keyword">unsigned</span> <span class="keyword">int</span> slen, <span class="keyword">int</span> where)</span> </span>&#123;</div><div class="line">    <span class="comment">// 根据 where 参数的值，决定将值插入到表头还是表尾</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *p;</div><div class="line">    p = (where == ZIPLIST_HEAD) ? ZIPLIST_ENTRY_HEAD(zl) : ZIPLIST_ENTRY_END(zl);</div><div class="line">    <span class="comment">// 返回添加新值后的 ziplist</span></div><div class="line">    <span class="keyword">return</span> __ziplistInsert(zl,p,s,slen);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在 __ziplistInsert 函数中实现了新节点的插入，主要的步骤为：</p>
<ol>
<li>根据前置节点和当前节点计算 entry 的 previous_entry_length、encoding 和 contents 字段占用的字节数</li>
<li>判断当前指针指向的位置是否能够存储当前的节点，如果不能存储，则需用 realloc 函数调整压缩列表的大小</li>
<li>移动后续节点腾出空间，将当前需要插入的节点放入，同时需要更新后续的节点的 previous_entry_length</li>
</ol>
<p>具体的代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *__ziplistInsert(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl, <span class="keyword">unsigned</span> <span class="keyword">char</span> *p, <span class="keyword">unsigned</span> <span class="keyword">char</span> *s, <span class="keyword">unsigned</span> <span class="keyword">int</span> slen) &#123;</div><div class="line">    <span class="comment">// 记录当前 ziplist 的长度</span></div><div class="line">    <span class="keyword">size_t</span> curlen = intrev32ifbe(ZIPLIST_BYTES(zl)), reqlen, prevlen = <span class="number">0</span>;</div><div class="line">    <span class="keyword">size_t</span> offset;</div><div class="line">    <span class="keyword">int</span> nextdiff = <span class="number">0</span>;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> encoding = <span class="number">0</span>;</div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> value = <span class="number">123456789</span>;</div><div class="line">    zlentry entry, tail;</div><div class="line">    <span class="keyword">if</span> (p[<span class="number">0</span>] != ZIP_END) &#123;</div><div class="line">        <span class="comment">// 如果 p[0] 不指向列表末端，说明列表非空，并且 p 正指向列表的其中一个节点，那么取出 p 所指向节点的信息，并将它保存到 entry 结构中</span></div><div class="line">        <span class="comment">// 然后用 prevlen 变量记录前置节点的长度，当插入新节点之后 p 所指向的节点就成了新节点的前置节点</span></div><div class="line">        entry = zipEntry(p);</div><div class="line">        prevlen = entry.prevrawlen;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 如果 p 指向表尾末端，那么程序需要检查列表是否为：</span></div><div class="line">        <span class="comment">// 1)如果 ptail 也指向 ZIP_END ，那么列表为空；</span></div><div class="line">        <span class="comment">// 2)如果列表不为空，那么 ptail 将指向列表的最后一个节点。</span></div><div class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> *ptail = ZIPLIST_ENTRY_TAIL(zl);</div><div class="line">        <span class="keyword">if</span> (ptail[<span class="number">0</span>] != ZIP_END) &#123;</div><div class="line">            <span class="comment">// 表尾节点为新节点的前置节点</span></div><div class="line">            <span class="comment">// 取出表尾节点的长度</span></div><div class="line">            <span class="comment">// T = O(1)</span></div><div class="line">            prevlen = zipRawEntryLength(ptail);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 尝试看能否将输入字符串转换为整数，如果成功的话：</span></div><div class="line">    <span class="comment">// 1)value 将保存转换后的整数值</span></div><div class="line">    <span class="comment">// 2)encoding 则保存适用于 value 的编码方式</span></div><div class="line">    <span class="comment">// 无论使用什么编码， reqlen 都保存节点值的长度</span></div><div class="line">    <span class="keyword">if</span> (zipTryEncoding(s,slen,&amp;value,&amp;encoding)) &#123;</div><div class="line">        reqlen = zipIntSize(encoding);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        reqlen = slen;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 计算编码前置节点的长度所需的大小</span></div><div class="line">    reqlen += zipPrevEncodeLength(<span class="literal">NULL</span>,prevlen);</div><div class="line">    <span class="comment">// 计算编码当前节点值所需的大小</span></div><div class="line">    reqlen += zipEncodeLength(<span class="literal">NULL</span>,encoding,slen);</div><div class="line">    <span class="comment">// 只要新节点不是被添加到列表末端，</span></div><div class="line">    <span class="comment">// 那么程序就需要检查看 p 所指向的节点（的 header）能否编码新节点的长度。</span></div><div class="line">    <span class="comment">// nextdiff 保存了新旧编码之间的字节大小差，如果这个值大于 0</span></div><div class="line">    <span class="comment">// 那么说明需要对 p 所指向的节点（的 header ）进行扩展</span></div><div class="line">    <span class="comment">// T = O(1)</span></div><div class="line">    nextdiff = (p[<span class="number">0</span>] != ZIP_END) ? zipPrevLenByteDiff(p,reqlen) : <span class="number">0</span>;</div><div class="line">    <span class="comment">// 因为重分配空间可能会改变 zl 的地址</span></div><div class="line">    <span class="comment">// 所以在分配之前，需要记录 zl 到 p 的偏移量，然后在分配之后依靠偏移量还原 p</span></div><div class="line">    offset = p-zl;</div><div class="line"></div><div class="line">    <span class="comment">// curlen 是 ziplist 原来的长度</span></div><div class="line">    <span class="comment">// reqlen 是整个新节点的长度</span></div><div class="line">    <span class="comment">// nextdiff 是新节点的后继节点扩展 header 的长度（要么 0 字节，要么 4 个字节）</span></div><div class="line">    zl = ziplistResize(zl,curlen+reqlen+nextdiff);</div><div class="line">    p = zl+offset;</div><div class="line">    <span class="keyword">if</span> (p[<span class="number">0</span>] != ZIP_END) &#123;</div><div class="line">        <span class="comment">// 新元素之后还有节点，因为新元素的加入，需要对这些原有节点进行调整</span></div><div class="line">        <span class="comment">// 移动现有元素，为新元素的插入空间腾出位置</span></div><div class="line">        memmove(p+reqlen,p-nextdiff,curlen-offset<span class="number">-1</span>+nextdiff);</div><div class="line">        <span class="comment">// 将新节点的长度编码至后置节点</span></div><div class="line">        <span class="comment">// p+reqlen 定位到后置节点</span></div><div class="line">        <span class="comment">// reqlen 是新节点的长度</span></div><div class="line">        zipPrevEncodeLength(p+reqlen,reqlen);</div><div class="line">        <span class="comment">// 更新到达表尾的偏移量，将新节点的长度也算上</span></div><div class="line">        ZIPLIST_TAIL_OFFSET(zl) =</div><div class="line">            intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+reqlen);</div><div class="line">        <span class="comment">// 如果新节点的后面有多于一个节点</span></div><div class="line">        <span class="comment">// 那么程序需要将 nextdiff 记录的字节数也计算到表尾偏移量中</span></div><div class="line">        <span class="comment">// 这样才能让表尾偏移量正确对齐表尾节点</span></div><div class="line">        tail = zipEntry(p+reqlen);</div><div class="line">        <span class="keyword">if</span> (p[reqlen+tail.headersize+tail.len] != ZIP_END) &#123;</div><div class="line">            ZIPLIST_TAIL_OFFSET(zl) =</div><div class="line">                intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+nextdiff);</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">/* This element will be the new tail. */</span></div><div class="line">        <span class="comment">// 新元素是新的表尾节点</span></div><div class="line">        ZIPLIST_TAIL_OFFSET(zl) = intrev32ifbe(p-zl);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/* When nextdiff != 0, the raw length of the next entry has changed, so</span></div><div class="line">     * we need to cascade the update throughout the ziplist */</div><div class="line">    <span class="comment">// 当 nextdiff != 0 时，新节点的后继节点的（header 部分）长度已经被改变，</span></div><div class="line">    <span class="comment">// 所以需要级联地更新后续的节点</span></div><div class="line">    <span class="keyword">if</span> (nextdiff != <span class="number">0</span>) &#123;</div><div class="line">        offset = p-zl;</div><div class="line">        <span class="comment">// T  = O(N^2)</span></div><div class="line">        zl = __ziplistCascadeUpdate(zl,p+reqlen);</div><div class="line">        p = zl+offset;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/* Write the entry */</span></div><div class="line">    <span class="comment">// 一切搞定，将前置节点的长度写入新节点的 header</span></div><div class="line">    p += zipPrevEncodeLength(p,prevlen);</div><div class="line">    <span class="comment">// 将节点值的长度写入新节点的 header</span></div><div class="line">    p += zipEncodeLength(p,encoding,slen);</div><div class="line">    <span class="comment">// 写入节点值</span></div><div class="line">    <span class="keyword">if</span> (ZIP_IS_STR(encoding)) &#123;</div><div class="line">        <span class="comment">// T = O(N)</span></div><div class="line">        <span class="built_in">memcpy</span>(p,s,slen);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// T = O(1)</span></div><div class="line">        zipSaveInteger(p,value,encoding);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 更新列表的节点数量计数器</span></div><div class="line">    <span class="comment">// T = O(1)</span></div><div class="line">    ZIPLIST_INCR_LENGTH(zl,<span class="number">1</span>);</div><div class="line">    <span class="keyword">return</span> zl;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在更新后续节点的 previous_entry_length 的过程中，可能会发生如下一种情况：当前的节点原先的长度小于 254，而新插入的节点长度大于 254，那么 encoding 的长度变长了，这样，若后续节点是一系列长度为 250 - 254，那么需要连续地更新后续节点的 header（即计算节点长度、重新分配空间然后后移后续节点插入新的 encoding 字段，直到整个压缩列表满足条件）。这个过程是在函数 __ziplistCascadeUpdate 中完成的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *__ziplistCascadeUpdate(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl, <span class="keyword">unsigned</span> <span class="keyword">char</span> *p) &#123;</div><div class="line">    <span class="keyword">size_t</span> curlen = intrev32ifbe(ZIPLIST_BYTES(zl)), rawlen, rawlensize;</div><div class="line">    <span class="keyword">size_t</span> offset, noffset, extra;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *np;</div><div class="line">    zlentry cur, next;</div><div class="line">    <span class="keyword">while</span> (p[<span class="number">0</span>] != ZIP_END) &#123;</div><div class="line">        <span class="comment">// 将 p 所指向的节点的信息保存到 cur 结构中</span></div><div class="line">        cur = zipEntry(p);</div><div class="line">        <span class="comment">// 当前节点的长度</span></div><div class="line">        rawlen = cur.headersize + cur.len;</div><div class="line">        <span class="comment">// 计算编码当前节点的长度所需的字节数</span></div><div class="line">        <span class="comment">// T = O(1)</span></div><div class="line">        rawlensize = zipPrevEncodeLength(<span class="literal">NULL</span>,rawlen);</div><div class="line">        <span class="comment">/* Abort if there is no next entry. */</span></div><div class="line">        <span class="comment">// 如果已经没有后续空间需要更新了，跳出</span></div><div class="line">        <span class="keyword">if</span> (p[rawlen] == ZIP_END) <span class="keyword">break</span>;</div><div class="line">        <span class="comment">// 取出后续节点的信息，保存到 next 结构中</span></div><div class="line">        next = zipEntry(p+rawlen);</div><div class="line">        <span class="comment">// 后续节点编码当前节点的空间已经足够，无须再进行任何处理，跳出</span></div><div class="line">        <span class="comment">// 可以证明，只要遇到一个空间足够的节点，</span></div><div class="line">        <span class="comment">// 那么这个节点之后的所有节点的空间都是足够的</span></div><div class="line">        <span class="keyword">if</span> (next.prevrawlen == rawlen) <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">if</span> (next.prevrawlensize &lt; rawlensize) &#123;</div><div class="line">            <span class="comment">// 执行到这里，表示 next 空间的大小不足以编码 cur 的长度</span></div><div class="line">            <span class="comment">// 所以程序需要对 next 节点的（header 部分）空间进行扩展</span></div><div class="line">            <span class="comment">// 记录 p 的偏移量</span></div><div class="line">            offset = p-zl;</div><div class="line">            <span class="comment">// 计算需要增加的节点数量</span></div><div class="line">            extra = rawlensize-next.prevrawlensize;</div><div class="line">            <span class="comment">// 扩展 zl 的大小</span></div><div class="line">            zl = ziplistResize(zl,curlen+extra);</div><div class="line">            <span class="comment">// 还原指针 p</span></div><div class="line">            p = zl+offset;</div><div class="line">            <span class="comment">/* Current pointer and offset for next element. */</span></div><div class="line">            <span class="comment">// 记录下一节点的偏移量</span></div><div class="line">            np = p+rawlen;</div><div class="line">            noffset = np-zl;</div><div class="line">            <span class="comment">// 当 next 节点不是表尾节点时，更新列表到表尾节点的偏移量</span></div><div class="line">            <span class="keyword">if</span> ((zl+intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))) != np) &#123;</div><div class="line">                ZIPLIST_TAIL_OFFSET(zl) =</div><div class="line">                    intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+extra);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 向后移动 cur 节点之后的数据，为 cur 的新 header 腾出空间</span></div><div class="line">            memmove(np+rawlensize,</div><div class="line">                np+next.prevrawlensize,</div><div class="line">                curlen-noffset-next.prevrawlensize<span class="number">-1</span>);</div><div class="line">            <span class="comment">// 将新的前一节点长度值编码进新的 next 节点的 header</span></div><div class="line">            zipPrevEncodeLength(np,rawlen);</div><div class="line">            <span class="comment">// 移动指针，继续处理下个节点</span></div><div class="line">            p += rawlen;</div><div class="line">            curlen += extra;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">if</span> (next.prevrawlensize &gt; rawlensize) &#123;</div><div class="line">                <span class="comment">/* This would result in shrinking, which we want to avoid.</span></div><div class="line">                 * So, set "rawlen" in the available bytes. */</div><div class="line">                <span class="comment">// 执行到这里，说明 next 节点编码前置节点的 header 空间有 5 字节</span></div><div class="line">                <span class="comment">// 而编码 rawlen 只需要 1 字节</span></div><div class="line">                <span class="comment">// 但是程序不会对 next 进行缩小，</span></div><div class="line">                <span class="comment">// 所以这里只将 rawlen 写入 5 字节的 header 中就算了。</span></div><div class="line">                <span class="comment">// T = O(1)</span></div><div class="line">                zipPrevEncodeLengthForceLarge(p+rawlen,rawlen);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// 运行到这里，说明 cur 节点的长度正好可以编码到 next 节点的 header 中</span></div><div class="line">                zipPrevEncodeLength(p+rawlen,rawlen);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> zl;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>不仅是插入有可能导致这样的连锁更新，当删除或改变一个节点的内容时，也可能发生这样的连锁更新。这样的连锁更新是非常耗费时间的（最差的情况时间复杂度为 O(N)），但是只有碰到连续长度为 250 - 254 的节点串时，才会触发该操作，当遍历到第一个满足条件的节点以后，操作就停止了。</p>
<p>值得注意的是，由于压缩列表的各项操作都需要遍历整个列表才能完成，因此，操作的时间复杂度都为 O(N)，这样使得在使用压缩列表时，表中的节点数不能太多，否则将极度影响操作的效率。在后续的数据结构介绍过程中，我们可以看到 Redis 对于压缩列表的使用是有限制的，使得既能利用压缩列表节省空间的特性，也能通过其它的设计或约束降低操作的时间复杂度。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/10/28/redis_intset/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="柿子">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柿子的果盘">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/10/28/redis_intset/" itemprop="url">Redis数据结构: 整数集合</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-10-28T00:00:00+08:00">
                2016-10-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/开源项目/" itemprop="url" rel="index">
                    <span itemprop="name">开源项目</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Redis 实现的整数集合是一种只包含整数数值的集合，是一种非常简单的数据结构，它按照数值的大小依次存储这些整数。为了节省存储空间，整数集合使用基本的一个字节作为存储单位，在更大的数值插入时完成整个集合的类型提升。</p>
<p>C 语言对应的整数值可以存在不同大小的类型（short int、int、long 和 long long）中，这些类型使用的是不同数量的字节（分别是 1 字节、2 字节、4 字节 和 8 字节）。如果我们给整数集合统一使用 long long 类型（8 个字节），那么全部由小整数组成的集合将浪费多余的空间；而如果使用太小的类型，则许多大的整数数值将无法存储。因此，需要能够动态调节整数的类型，使得在不同的场景下，用不同的类型存储整数，而 Redis 正是这么做的。Redis 使用 int8_t（即一个字节）作为整数集合的基本存储单位，对于 short int、int、long、long long 对应的数值采用数组中连续的多个字节来保存。初始使用 int16_t 来保存整数值；一旦发现更大的数值存入的时候，对于原先的数组进行类型提升，使得更大的数值能够存入。了解了这个基本的想法以后，对于整数集合的设计和实现就变得很简单。</p>
<p>整数集合的实现在 intset.h 和 intset.c 中，我们先来看看它的结构：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span> &#123;</span></div><div class="line">    <span class="keyword">uint32_t</span> encoding;     <span class="comment">// 编码方式</span></div><div class="line">    <span class="keyword">uint32_t</span> length;       <span class="comment">// 集合包含的元素数量</span></div><div class="line">    <span class="keyword">int8_t</span> contents[];     <span class="comment">// 保存元素的数组</span></div><div class="line">&#125; intset;</div></pre></td></tr></table></figure></p>
<p>在这个结构中，所有的整数保存在 contents 数组中，而这个数组的类型是 int8_t（一个字节，现行的计算机通常都是以一个字节为存储单位），但是这个数据结构并不保存 int8_t 类型的整数，而是用于保存 int16_t, int32_t 或 int62_t 的整数，具体保存的类型由 encoding 来决定。按照这样的保存方式，一个整数是由数组中的若干个连续的数合起来进行表示的，例如 int16_t 类型的整数 12345 就需要数组中的连续 2 个元素进行保存，分别是 48 和 57，这两个数的顺序由整数在内存中的存储顺序（大端或小端）决定。Redis 对于大端小端这两种存储方式的处理在 endianconv.h 和 endianconv.c 中，比较简单就不展开介绍了。<br>当创建一个新的整数集合时，默认将编码方式设置为 int16_t。当一个新的整数被添加的时候，此时需要检查该整数的类型是否是是 int16_t。若是，则直接找到需要插入的位置，将其插入；若不是 int16_t，而是更大的数据类型，则需要分配更大的空间，然后将数据从后到前依次放入新的位置。举个例子，一个 int16_t 类型的整数集合：</p>
<table>
<thead>
<tr>
<th>位</th>
<th>0至15位</th>
<th>16至31位</th>
<th>32至47位</th>
</tr>
</thead>
<tbody>
<tr>
<td>元素</td>
<td>123</td>
<td>2322</td>
<td>56223</td>
</tr>
</tbody>
</table>
<p>此时我们需要插入一个 int32_t 类型的数据 123456，这个时候需要先分配一些新的空间：</p>
<table>
<thead>
<tr>
<th>位</th>
<th>0至15位</th>
<th>16至31位</th>
<th>32至47位</th>
<th>48位至127位</th>
</tr>
</thead>
<tbody>
<tr>
<td>元素</td>
<td>123</td>
<td>2322</td>
<td>56223</td>
<td>(新分配空间)</td>
</tr>
</tbody>
</table>
<p>然后由后向前依次将原来的数放到新的位置上，这里需要预先判断一下，新加入的数的位置，由于类型变大，所以新存入的整数不是最大的，就是最小的：</p>
<table>
<thead>
<tr>
<th>位</th>
<th>0至31位</th>
<th>32至63位</th>
<th>64至95位</th>
<th>96位至127位</th>
</tr>
</thead>
<tbody>
<tr>
<td>元素</td>
<td>123</td>
<td>2322</td>
<td>56223</td>
<td>(新分配空间)</td>
</tr>
</tbody>
</table>
<p>由于 12345 比 原先的数都大，因此存入最后的位置，自此插入整数操作就完成了。由于需要挪动所有的元素，所以时间复杂度为 O(N)。</p>
<table>
<thead>
<tr>
<th>位</th>
<th>0至31位</th>
<th>32至63位</th>
<th>64至95位</th>
<th>96位至127位</th>
</tr>
</thead>
<tbody>
<tr>
<td>元素</td>
<td>123</td>
<td>2322</td>
<td>56223</td>
<td>123456</td>
</tr>
</tbody>
</table>
<p>具体的代码可以查看 intsetMoveTail 函数，由于类型发生增大的情况（否则将高位的 0 去掉，可以直接存入当前的集合）只有可能有两种：</p>
<ol>
<li>比集合中所有的元素都大</li>
<li>比集合中所有的元素都小，此时，插入的数为负数</li>
</ol>
<p>所以插入的位置肯定在两端：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">uint8_t</span> _intsetValueEncoding(<span class="keyword">int64_t</span> v) &#123;</div><div class="line">    <span class="comment">// 查找最小的整型类型存储对应的整数值</span></div><div class="line">    <span class="keyword">if</span> (v &lt; INT32_MIN || v &gt; INT32_MAX)</div><div class="line">        <span class="keyword">return</span> INTSET_ENC_INT64;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (v &lt; INT16_MIN || v &gt; INT16_MAX)</div><div class="line">        <span class="keyword">return</span> INTSET_ENC_INT32;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        <span class="keyword">return</span> INTSET_ENC_INT16;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">static</span> intset *<span class="title">intsetUpgradeAndAdd</span><span class="params">(intset *is, <span class="keyword">int64_t</span> value)</span> </span>&#123;</div><div class="line">    <span class="keyword">uint8_t</span> curenc = intrev32ifbe(is-&gt;encoding);</div><div class="line">    <span class="keyword">uint8_t</span> newenc = _intsetValueEncoding(value);</div><div class="line">    <span class="keyword">int</span> length = intrev32ifbe(is-&gt;length);</div><div class="line">    <span class="comment">// 判断若发生了类型增大，则在集合的哪头进行插入</span></div><div class="line">    <span class="keyword">int</span> prepend = value &lt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</div><div class="line">    <span class="comment">// 调整整数结合的大小</span></div><div class="line">    is-&gt;encoding = intrev32ifbe(newenc);</div><div class="line">    is = intsetResize(is,intrev32ifbe(is-&gt;length)+<span class="number">1</span>);</div><div class="line">    <span class="comment">//自后向前将值放入新的位置</span></div><div class="line">    <span class="keyword">while</span>(length--)</div><div class="line">        _intsetSet(is,length+prepend,_intsetGetEncoded(is,length,curenc));</div><div class="line">    <span class="comment">// 将新的整数放入集合</span></div><div class="line">    <span class="keyword">if</span> (prepend)</div><div class="line">        _intsetSet(is,<span class="number">0</span>,value);</div><div class="line">    <span class="keyword">else</span></div><div class="line">        _intsetSet(is,intrev32ifbe(is-&gt;length),value);</div><div class="line">    is-&gt;length = intrev32ifbe(intrev32ifbe(is-&gt;length)+<span class="number">1</span>);</div><div class="line">    <span class="keyword">return</span> is;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意，整数集合并没有提供降级操作，即一旦该整数集合被升级了以后，即使插入数据类型大的数被删除以后，对于该整数集合的提升并不会撤销。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/10/21/redis_dict/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="柿子">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柿子的果盘">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/10/21/redis_dict/" itemprop="url">Redis数据结构: 字典</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-10-21T00:00:00+08:00">
                2016-10-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/开源项目/" itemprop="url" rel="index">
                    <span itemprop="name">开源项目</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>字典是一种常用的数据结构，在很多其它的高级编程语言里都有内置的实现方式，但是 C 语言没有，所以 Redis 自己实现了一个。Redis 使用哈希表作为字典的实现方式，代码主要在 dict.h 和 dict.c 中。</p>
<p>首先来看看哈希表的节点结构，这里面包含键值对和一个指向下个节点的指针：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></div><div class="line">    <span class="keyword">void</span> *key;</div><div class="line">    <span class="keyword">union</span> &#123;</div><div class="line">        <span class="keyword">void</span> *val;</div><div class="line">        <span class="keyword">uint64_t</span> u64;</div><div class="line">        <span class="keyword">int64_t</span> s64;</div><div class="line">        <span class="keyword">double</span> d;</div><div class="line">    &#125; v;</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></div><div class="line">&#125; dictEntry;</div></pre></td></tr></table></figure>
<p>通过这个结构能知道，Redis 的哈希解决冲突的方式是链表，将相同哈希值的键值对保存在一个单项列表中，而且为了性能的考虑，Redis 总是将最后插入链表的节点作为这个链表的表头，这样使得插入操作的时间复杂度为 O(1)，例如 dictRehash 函数中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">de-&gt;next = d-&gt;ht[<span class="number">1</span>].table[h];</div><div class="line">d-&gt;ht[<span class="number">1</span>].table[h] = de;</div></pre></td></tr></table></figure>
<p>其次是哈希表的结构，里面包含了哈希表内容、长度、掩码值和已使用的空间，其中掩码值用于将哈希函数计算出的哈希值对应到表中的索引值，对于哈希函数的使用可以看后面的介绍：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></div><div class="line">    dictEntry **table;       <span class="comment">// 哈希表内容</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> size;      <span class="comment">// 哈希表的长度</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask;  <span class="comment">// 掩码值，永远等于 size - 1，用于将哈希值对应到索引值</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used;      <span class="comment">// 已使用的空间大小</span></div><div class="line">&#125; dictht;</div></pre></td></tr></table></figure>
<p>接下来是字典的结构，在字典中包含了两个哈希表，自定义类型相关的函数和私有数据，以及 rehash 过程需要用到的索引和安全迭代器的数量，具体的 Rehash 过程在后面进行介绍：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></div><div class="line">    dictType *type;           <span class="comment">// 类型特定函数</span></div><div class="line">    <span class="keyword">void</span> *privdata;           <span class="comment">// 私有数据</span></div><div class="line">    dictht ht[<span class="number">2</span>];             <span class="comment">// 哈希表</span></div><div class="line">    <span class="keyword">int</span> rehashidx;            <span class="comment">// rehash 索引，当 rehash 不在进行时，值为 -1</span></div><div class="line">    <span class="keyword">int</span> iterators;            <span class="comment">// 目前正在运行的安全迭代器的数量</span></div><div class="line">&#125; dict;</div></pre></td></tr></table></figure>
<p>通过 dictType 的定义，可以看到 privdata 保存了类型特定函数的一些可选参数，在调用函数时传入。Redis 给不同的字典实现不同的类型函数以及定义不同的私有数据，从而实现字典的多态：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictType</span> &#123;</span></div><div class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span> <span class="params">(*hashFunction)</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *key)</span></span>;</div><div class="line">    <span class="keyword">void</span> *(*keyDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key);</div><div class="line">    <span class="keyword">void</span> *(*valDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *obj);</div><div class="line">    <span class="keyword">int</span> (*keyCompare)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key1, <span class="keyword">const</span> <span class="keyword">void</span> *key2);</div><div class="line">    <span class="keyword">void</span> (*keyDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *key);</div><div class="line">    <span class="keyword">void</span> (*valDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *obj);</div><div class="line">&#125; dictType;</div></pre></td></tr></table></figure>
<p>在了解完基本的结构以后，我们再来看哈希表和字典的具体实现细节进行。</p>
<h2 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h2><p>从上述的介绍中，我们可以知道 Redis 利用 dictType 定义的类型特定函数来实现多态，在这些类型函数中，hashFunction 负责将 key 进行转换，得到对应的哈希值。根据不同的字典，使用的哈希算法也不相同。得到哈希值以后，再通过与哈希表的掩码值进行与操作，就获得 key 对应的索引值，具体可以看 dictRehash 函数中计算索引值的操作：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> dictHashKey(d, key) (d)-&gt;type-&gt;hashFunction(key)</span></div><div class="line">h = dictHashKey(d, de-&gt;key) &amp; d-&gt;ht[<span class="number">1</span>].sizemask;</div></pre></td></tr></table></figure>
<p>Redis 提供了几种种哈希函数:</p>
<ol>
<li>Thomas Wang 发明的 32 bits / 64 bits 的整数哈希函数<br>在之前的版本中，使用这个哈希函数来对整数进行哈希操作，这个哈希函数通过加法和位移操作进行哈希值的计算，避免了乘法操作带来的性能损失，同时使结果具有均匀的分布，以及雪崩效应。在之前的版本中单独编写函数，对于整数进行哈希，而在最新的版本中，只作为 figureprint 生成的函数。对于这个哈希函数的细节，可以参考我之前翻译的 Thomas Wang 写的整数哈希函数。</li>
<li>Austin Appleby 发明的 MurmurHash2 算法<br>murmur 是 multiply and rotate 的意思，因为算法的核心就是不断的乘和移位。MurmurHash 算法具有高运算性能，低碰撞率的特点，由 Austin Appleby 创建于2008年，最新的版本是 MurmurHash3，现已应用到Hadoop、libstdc++、nginx、libmemcached等开源系统。<br>通过 murmur 函数获得的哈希值分布均匀，比如：murmur计算”abc”是1118836419，”abd”是413429783。而使用 Horner 算法，”abc”是96354， “abd”就比它多1（96355）。</li>
<li>DJB 算法的修改版<br>DJB 算法同样是用于字符串类型的哈希函数，原理也非常简单，就是不断乘以 33 再加上对应的字符。该算法的执行效率和随机性都不错。在 Redis 中对该算法进行了简单的修改，使得它对大小写不敏感。</li>
</ol>
<p>对于 MurmurHash2 和 DJB 两种字符串哈希函数的比较：</p>
<ol>
<li>有人做过一个<a href="http://blog.csdn.net/wwwsq/article/details/4254123" target="_blank" rel="external">性能对比的实验</a>，得出结论：从计算速度上来看，MurmurHash只适用于已知长度的、长度比较长的字符串。长度未知或者长度不超过10字节，都应该使用DJB。而在前面介绍 SDS 的时候，我们知道 Redis 的字符串的 strlen 操作的时间复杂度是 O(1)，因此在长度大于 10 字节时，使用 MurmurHash2 可以获得一个随机性更好的哈希值，性能也更优；</li>
<li>另外，在代码的实现中，也将 DJB 和 MurmurHash2 算法进行了区别，DJB 的实现对字母的大小写不敏感，而 MurmurHash2 则是敏感的。</li>
</ol>
<h2 id="Rehash"><a href="#Rehash" class="headerlink" title="Rehash"></a>Rehash</h2><p>随着各类操作的不断执行，字典中的键值对的数量会不断地变化。当键值对的数量增加到一定数量以后，会使得碰撞冲突变得剧烈，影响哈希表的性能；而当键值对减少到一定程度以后，则会空闲大量的存储空间。因此，为了让哈希表的负载因子（键值对数量 / 哈希表大小）维持在一个合理的范围内，我们需要对哈希表进行适当的收缩和扩张。这个操作的基本步骤为：</p>
<ol>
<li>根据不同的操作（不同的大小）创建一个新的哈希表 ht[1]</li>
<li>渐进式地进行哈希表节点的迁移</li>
<li>完成迁移以后，将 ht[0] 的空间释放掉，将 ht[1] 替换 ht[0]</li>
</ol>
<h3 id="进行-Rehash-操作的条件"><a href="#进行-Rehash-操作的条件" class="headerlink" title="进行 Rehash 操作的条件"></a>进行 Rehash 操作的条件</h3><p>Redis 基于哈希表的性能和整体服务的性能考虑，将进行 Rehash 的情况分为两种：</p>
<ol>
<li>正常使用 Redis 时，当负载因子超过 1 时，就考虑进行 Rehash 操作；</li>
<li>Redis 利用后台线程进行持久化，这个时候为了最大程度利用 Copy On Write 机制带来的性能提升，会暂时停止 Rehash 操作，除非负载因子超过 dict_force_resize_ratio 的值</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> _dictExpandIfNeeded(dict *d)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (dictIsRehashing(d)) <span class="keyword">return</span> DICT_OK;</div><div class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].size == <span class="number">0</span>) <span class="keyword">return</span> dictExpand(d, DICT_HT_INITIAL_SIZE);</div><div class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].used &gt;= d-&gt;ht[<span class="number">0</span>].size &amp;&amp;</div><div class="line">        (dict_can_resize ||</div><div class="line">         d-&gt;ht[<span class="number">0</span>].used/d-&gt;ht[<span class="number">0</span>].size &gt; dict_force_resize_ratio))</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> dictExpand(d, d-&gt;ht[<span class="number">0</span>].used*<span class="number">2</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> DICT_OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="创建新的哈希表"><a href="#创建新的哈希表" class="headerlink" title="创建新的哈希表"></a>创建新的哈希表</h3><p>扩张哈希表的操作是在 _dictExpandIfNeeded 函数里进行判断和扩张的，而收缩哈希表的操作则是通过调用 dictResize 函数进行。而这两个函数同时调用了 dictExpand 函数。具体如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictExpand</span><span class="params">(dict *d, <span class="keyword">unsigned</span> <span class="keyword">long</span> size)</span></span></div><div class="line">&#123;</div><div class="line">    dictht n; <span class="comment">// 新哈希表</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> realsize = _dictNextPower(size);  <span class="comment">// 根据 size 参数，计算哈希表的大小</span></div><div class="line">    <span class="comment">// 不能在字典正在 rehash 时进行</span></div><div class="line">    <span class="comment">// size 的值也不能小于 0 号哈希表的当前已使用节点</span></div><div class="line">    <span class="keyword">if</span> (dictIsRehashing(d) || d-&gt;ht[<span class="number">0</span>].used &gt; size)</div><div class="line">        <span class="keyword">return</span> DICT_ERR;</div><div class="line">    <span class="comment">// 为哈希表分配空间，并将所有指针指向 NULL</span></div><div class="line">    n.size = realsize;</div><div class="line">    n.sizemask = realsize<span class="number">-1</span>;</div><div class="line">    n.table = zcalloc(realsize*<span class="keyword">sizeof</span>(dictEntry*));</div><div class="line">    n.used = <span class="number">0</span>;</div><div class="line">    <span class="comment">// 如果此时 ht[0] 如果为空，则表示当前的操作是初始化哈希表</span></div><div class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].table == <span class="literal">NULL</span>) &#123;</div><div class="line">        d-&gt;ht[<span class="number">0</span>] = n;</div><div class="line">        <span class="keyword">return</span> DICT_OK;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 设置新的哈希表大小，开始进行迁移</span></div><div class="line">    d-&gt;ht[<span class="number">1</span>] = n;</div><div class="line">    d-&gt;rehashidx = <span class="number">0</span>;</div><div class="line">    <span class="keyword">return</span> DICT_OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这个函数中，根据传入 size 的大小，查找到第一个大于等于 size 的 2 的次幂，作为新的哈希表的大小。在 dictResize 函数中，传入的是 ht[0].used，而在 _dictExpandIfNeeded 中传入的是 ht[0].used * 2。</p>
<h3 id="渐进式迁移"><a href="#渐进式迁移" class="headerlink" title="渐进式迁移"></a>渐进式迁移</h3><p>如果保存的哈希表节点特别多，将整个迁移过程一次性完成的话，将很长时间无法进行正常的插入操作，所以 Redis 使用渐进式的方式来完成哈希节点的迁移。具体的过程在 dictRehash 中实现，这个函数完成 n 个哈希表节点的迁移，并同时检测 rehash 操作是否已经完成：当整个 ht[0] 中的节点都迁移到 ht[1] 以后，释放 ht[0] 的空间，将 ht[1] 换入 ht[0]，同时重置所有的 rehash 相关的参数，就完成 rehash 的过程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictRehash</span><span class="params">(dict *d, <span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">    <span class="comment">// 只可以在 rehash 进行中时执行</span></div><div class="line">    <span class="keyword">if</span> (!dictIsRehashing(d)) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    <span class="comment">// 进行 N 步迁移</span></div><div class="line">    <span class="keyword">while</span>(n--) &#123;</div><div class="line">        dictEntry *de, *nextde;</div><div class="line">        <span class="comment">// 如果 0 号哈希表为空，那么表示 rehash 执行完毕</span></div><div class="line">        <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].used == <span class="number">0</span>) &#123;</div><div class="line">            zfree(d-&gt;ht[<span class="number">0</span>].table);</div><div class="line">            d-&gt;ht[<span class="number">0</span>] = d-&gt;ht[<span class="number">1</span>];</div><div class="line">            _dictReset(&amp;d-&gt;ht[<span class="number">1</span>]);</div><div class="line">            d-&gt;rehashidx = <span class="number">-1</span>;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 确保 rehashidx 没有越界</span></div><div class="line">        assert(d-&gt;ht[<span class="number">0</span>].size &gt; (<span class="keyword">unsigned</span>)d-&gt;rehashidx);</div><div class="line">        <span class="comment">// 略过数组中为空的索引，找到下一个非空索引</span></div><div class="line">        <span class="keyword">while</span>(d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx] == <span class="literal">NULL</span>) d-&gt;rehashidx++;</div><div class="line">        <span class="comment">// 指向该索引的链表表头节点</span></div><div class="line">        de = d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx];</div><div class="line">        <span class="comment">// 将链表中的所有节点迁移到新哈希表</span></div><div class="line">        <span class="keyword">while</span>(de) &#123;</div><div class="line">            <span class="keyword">unsigned</span> <span class="keyword">int</span> h;</div><div class="line">            <span class="comment">// 保存下个节点的指针</span></div><div class="line">            nextde = de-&gt;next;</div><div class="line">            <span class="comment">// 计算新哈希表的哈希值，以及节点插入的索引位置</span></div><div class="line">            h = dictHashKey(d, de-&gt;key) &amp; d-&gt;ht[<span class="number">1</span>].sizemask;</div><div class="line">            <span class="comment">// 插入节点到新哈希表</span></div><div class="line">            de-&gt;next = d-&gt;ht[<span class="number">1</span>].table[h];</div><div class="line">            d-&gt;ht[<span class="number">1</span>].table[h] = de;</div><div class="line">            <span class="comment">// 更新计数器</span></div><div class="line">            d-&gt;ht[<span class="number">0</span>].used--;</div><div class="line">            d-&gt;ht[<span class="number">1</span>].used++;</div><div class="line"></div><div class="line">            de = nextde;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 将刚迁移完的哈希表索引的指针设为空</span></div><div class="line">        d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx] = <span class="literal">NULL</span>;</div><div class="line">        <span class="comment">// 更新 rehash 索引</span></div><div class="line">        d-&gt;rehashidx++;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>那么什么时候执行 Rehash 的操作呢？Redis 定义了两个进行渐进式操作的时机：</p>
<ul>
<li>在哈希表被使用的同时，例如对哈希表进行查询或修改，执行 n = 1 的 dictRehash 操作，即调用 _dictRehashStep</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> _dictRehashStep(dict *d) &#123;</div><div class="line">    <span class="keyword">if</span> (d-&gt;iterators == <span class="number">0</span>) dictRehash(d,<span class="number">1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>如果哈希表长时间没有被使用，同样也需要将 rehash 操作进行下去，dictRehashMilliseconds 函数在指定时间内（10ms）以 100 次为单位进行 dictRehash 操作</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictRehashMilliseconds</span><span class="params">(dict *d, <span class="keyword">int</span> ms)</span> </span>&#123;</div><div class="line">    <span class="comment">// 记录开始时间</span></div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> start = timeInMilliseconds();</div><div class="line">    <span class="keyword">int</span> rehashes = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span>(dictRehash(d,<span class="number">100</span>)) &#123;</div><div class="line">        rehashes += <span class="number">100</span>;</div><div class="line">        <span class="comment">// 如果时间已过，跳出</span></div><div class="line">        <span class="keyword">if</span> (timeInMilliseconds()-start &gt; ms) <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> rehashes;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Rehash-执行期间的哈希表使用"><a href="#Rehash-执行期间的哈希表使用" class="headerlink" title="Rehash 执行期间的哈希表使用"></a>Rehash 执行期间的哈希表使用</h3><p>在字典进行 Rehash 的过程中，两个哈希表 ht[0] 和 ht[1] 同时存在并且被使用。因此，所有的查找、更新和删除都需要在两个哈希表上同时进行（先在 ht[0] 上进行操作，如果没有对应的目标，则在 ht[1] 上继续进行）。而增加操作只在 ht[1] 上进行，随着渐进式的迁移操作，ht[0] 表中的节点会越来越少，直到所有的节点都进入 ht[1]，rehash就完成了。</p>
<h2 id="哈希表的迭代器"><a href="#哈希表的迭代器" class="headerlink" title="哈希表的迭代器"></a>哈希表的迭代器</h2><p>迭代器的结构定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictIterator</span> &#123;</span></div><div class="line"></div><div class="line">    <span class="comment">// 被迭代的字典</span></div><div class="line">    dict *d;</div><div class="line">    <span class="comment">// table ：正在被迭代的哈希表号码，值可以是 0 或 1 。</span></div><div class="line">    <span class="comment">// index ：迭代器当前所指向的哈希表索引位置。</span></div><div class="line">    <span class="comment">// safe ：标识这个迭代器是否安全</span></div><div class="line">    <span class="keyword">int</span> table, index, safe;</div><div class="line">    <span class="comment">// entry ：当前迭代到的节点的指针</span></div><div class="line">    <span class="comment">// nextEntry ：当前迭代节点的下一个节点</span></div><div class="line">    <span class="comment">//             因为在安全迭代器运作时， entry 所指向的节点可能会被修改，</span></div><div class="line">    <span class="comment">//             所以需要一个额外的指针来保存下一节点的位置，</span></div><div class="line">    <span class="comment">//             从而防止指针丢失</span></div><div class="line">    dictEntry *entry, *nextEntry;</div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> fingerprint;</div><div class="line">&#125; dictIterator;</div></pre></td></tr></table></figure>
<p>Redis 的哈希表的迭代器按照是否 Rehash 安全分为两种，由 safe 字段进行标注。当 Rehash 安全的迭代器存在的时候，将不会进行单步的 Rehash，即在 _dictRehashStep 函数中先判断字典是否存在使用中的安全迭代器，不存在时才会进行 dictRehash。但是对于定时执行的情况，我没有找到在代码中保证在有安全迭代器时不进行 dictRehash 的判断，或许需要阅读更多的代码才能进行判断。<br>此外，由于迭代器返回以后可能会将迭代器当前指针对应的节点删除，所以还需要保存后续节点指针。而fingerprint 是使用 Thomas Wang 64bits 哈希算法在创建不安全迭代器时生成的指纹，用于在迭代器释放的时候判断在该迭代器在执行的过程中哈希表是否发生了变化。<br>为什么需要设置这两类迭代器呢？主要针对进行迭代的哈希表是否是可变的。由于在安全迭代器运行的期间不能执行 Rehash 操作，因此会影响性能，在对不可变的哈希表进行迭代操作时（例如 Redis 利用子线程进行 dump 操作），就可以使用不安全的迭代器。</p>
<h2 id="Scan-操作"><a href="#Scan-操作" class="headerlink" title="Scan 操作"></a>Scan 操作</h2><p>由于整体的数据设计，Redis 没有办法提供特别准确的 Scan 操作，它的特点是：</p>
<ul>
<li>提供键空间的遍历操作，支持游标，遍历一遍值需要 O(N) 的时间复杂度</li>
<li>无法提供完整的快照遍历，也就是中间如果有数据修改，可能有些涉及改动的数据遍历不到</li>
<li>每次返回的数据条数不一定，极度依赖内部实现</li>
<li>返回的数据可能有重复，应用层必须能够处理重入逻辑</li>
</ul>
<p>整个 Scan 操作的算法比较让人费解，我找到了一个写得比较好的博客，直接在这里转载一下，有兴趣的可以直接看，这里就不做过多的解释了：<a href="http://chenzhenianqing.cn/articles/1101.html" target="_blank" rel="external">http://chenzhenianqing.cn/articles/1101.html</a></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://redisbook.readthedocs.io/en/latest/internal-datastruct/dict.html" target="_blank" rel="external">Redis 设计与实现 - 字典</a></li>
<li><a href="http://www.tuicool.com/articles/3eeIJrR" target="_blank" rel="external">Redis的字典(dict)rehash过程源码解析</a></li>
<li><a href="http://chenzhenianqing.cn/articles/1090.html" target="_blank" rel="external">Redis Scan迭代器遍历操作原理（一）– 基础</a></li>
<li><a href="http://chenzhenianqing.cn/articles/1101.html" target="_blank" rel="external">Redis Scan迭代器遍历操作原理（二）– dictScan反向二进制迭代器</a></li>
<li><a href="http://stackoverflow.com/questions/9223397/whats-the-difference-of-safe-non-safe-dict-itereator-in-redis-dict-implementat" target="_blank" rel="external">what’s the difference of safe/non-safe dict itereator in redis’ dict implementation?</a></li>
<li><a href="http://github.thinkingbar.com/redisbook_chapter01/" target="_blank" rel="external">Redis设计与实现（一）内部数据结构</a></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="柿子" />
          <p class="site-author-name" itemprop="name">柿子</p>
           
              <p class="site-description motion-element" itemprop="description">一个非主流程序员</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">16</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">4</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">4</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">柿子</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.1"></script>



  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  





  

  

  

  

  

  

</body>
</html>
