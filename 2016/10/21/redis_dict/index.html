<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Redis," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="字典是一种常用的数据结构，在很多其它的高级编程语言里都有内置的实现方式，但是 C 语言没有，所以 Redis 自己实现了一个。Redis 使用哈希表作为字典的实现方式，代码主要在 dict.h 和 dict.c 中。 首先来看看哈希表的节点结构，这里面包含键值对和一个指向下个节点的指针： 12345678910typedef struct dictEntry &amp;#123;    void *key">
<meta name="keywords" content="Redis">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis数据结构: 字典">
<meta property="og:url" content="http://yoursite.com/2016/10/21/redis_dict/index.html">
<meta property="og:site_name" content="柿子的果盘">
<meta property="og:description" content="字典是一种常用的数据结构，在很多其它的高级编程语言里都有内置的实现方式，但是 C 语言没有，所以 Redis 自己实现了一个。Redis 使用哈希表作为字典的实现方式，代码主要在 dict.h 和 dict.c 中。 首先来看看哈希表的节点结构，这里面包含键值对和一个指向下个节点的指针： 12345678910typedef struct dictEntry &amp;#123;    void *key">
<meta property="og:updated_time" content="2017-06-24T11:38:04.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Redis数据结构: 字典">
<meta name="twitter:description" content="字典是一种常用的数据结构，在很多其它的高级编程语言里都有内置的实现方式，但是 C 语言没有，所以 Redis 自己实现了一个。Redis 使用哈希表作为字典的实现方式，代码主要在 dict.h 和 dict.c 中。 首先来看看哈希表的节点结构，这里面包含键值对和一个指向下个节点的指针： 12345678910typedef struct dictEntry &amp;#123;    void *key">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2016/10/21/redis_dict/"/>





  <title>Redis数据结构: 字典 | 柿子的果盘</title>
  
<script>
  window.fbAsyncInit = function() {
    FB.init({
      appId      : '328629287562794',
      xfbml      : true,
      version    : 'v2.6'
    });
  };

  (function(d, s, id){
     var js, fjs = d.getElementsByTagName(s)[0];
     if (d.getElementById(id)) {return;}
     js = d.createElement(s); js.id = id;
     js.src = "//connect.facebook.net/zh_Hans/sdk.js";
     fjs.parentNode.insertBefore(js, fjs);
   }(document, 'script', 'facebook-jssdk'));
</script>






  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?30798a6e72702e12c529efb9326dc7e1";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>










</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">柿子的果盘</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">随手记录一些所读、所思、所感</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/10/21/redis_dict/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="柿子">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柿子的果盘">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Redis数据结构: 字典</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-10-21T00:00:00+08:00">
                2016-10-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/开源项目/" itemprop="url" rel="index">
                    <span itemprop="name">开源项目</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2016/10/21/redis_dict/#comments" itemprop="discussionUrl">
                  评论数 <span class="post-comments-count fb-comments-count" data-href="http://yoursite.com/2016/10/21/redis_dict/" itemprop="commentCount">0</span>
                </a>
              </span>
            
          

          
          
             <span id="/2016/10/21/redis_dict/" class="leancloud_visitors" data-flag-title="Redis数据结构: 字典">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>字典是一种常用的数据结构，在很多其它的高级编程语言里都有内置的实现方式，但是 C 语言没有，所以 Redis 自己实现了一个。Redis 使用哈希表作为字典的实现方式，代码主要在 dict.h 和 dict.c 中。</p>
<p>首先来看看哈希表的节点结构，这里面包含键值对和一个指向下个节点的指针：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></div><div class="line">    <span class="keyword">void</span> *key;</div><div class="line">    <span class="keyword">union</span> &#123;</div><div class="line">        <span class="keyword">void</span> *val;</div><div class="line">        <span class="keyword">uint64_t</span> u64;</div><div class="line">        <span class="keyword">int64_t</span> s64;</div><div class="line">        <span class="keyword">double</span> d;</div><div class="line">    &#125; v;</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></div><div class="line">&#125; dictEntry;</div></pre></td></tr></table></figure>
<p>通过这个结构能知道，Redis 的哈希解决冲突的方式是链表，将相同哈希值的键值对保存在一个单项列表中，而且为了性能的考虑，Redis 总是将最后插入链表的节点作为这个链表的表头，这样使得插入操作的时间复杂度为 O(1)，例如 dictRehash 函数中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">de-&gt;next = d-&gt;ht[<span class="number">1</span>].table[h];</div><div class="line">d-&gt;ht[<span class="number">1</span>].table[h] = de;</div></pre></td></tr></table></figure>
<p>其次是哈希表的结构，里面包含了哈希表内容、长度、掩码值和已使用的空间，其中掩码值用于将哈希函数计算出的哈希值对应到表中的索引值，对于哈希函数的使用可以看后面的介绍：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></div><div class="line">    dictEntry **table;       <span class="comment">// 哈希表内容</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> size;      <span class="comment">// 哈希表的长度</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask;  <span class="comment">// 掩码值，永远等于 size - 1，用于将哈希值对应到索引值</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used;      <span class="comment">// 已使用的空间大小</span></div><div class="line">&#125; dictht;</div></pre></td></tr></table></figure>
<p>接下来是字典的结构，在字典中包含了两个哈希表，自定义类型相关的函数和私有数据，以及 rehash 过程需要用到的索引和安全迭代器的数量，具体的 Rehash 过程在后面进行介绍：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></div><div class="line">    dictType *type;           <span class="comment">// 类型特定函数</span></div><div class="line">    <span class="keyword">void</span> *privdata;           <span class="comment">// 私有数据</span></div><div class="line">    dictht ht[<span class="number">2</span>];             <span class="comment">// 哈希表</span></div><div class="line">    <span class="keyword">int</span> rehashidx;            <span class="comment">// rehash 索引，当 rehash 不在进行时，值为 -1</span></div><div class="line">    <span class="keyword">int</span> iterators;            <span class="comment">// 目前正在运行的安全迭代器的数量</span></div><div class="line">&#125; dict;</div></pre></td></tr></table></figure>
<p>通过 dictType 的定义，可以看到 privdata 保存了类型特定函数的一些可选参数，在调用函数时传入。Redis 给不同的字典实现不同的类型函数以及定义不同的私有数据，从而实现字典的多态：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictType</span> &#123;</span></div><div class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span> <span class="params">(*hashFunction)</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *key)</span></span>;</div><div class="line">    <span class="keyword">void</span> *(*keyDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key);</div><div class="line">    <span class="keyword">void</span> *(*valDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *obj);</div><div class="line">    <span class="keyword">int</span> (*keyCompare)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key1, <span class="keyword">const</span> <span class="keyword">void</span> *key2);</div><div class="line">    <span class="keyword">void</span> (*keyDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *key);</div><div class="line">    <span class="keyword">void</span> (*valDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *obj);</div><div class="line">&#125; dictType;</div></pre></td></tr></table></figure>
<p>在了解完基本的结构以后，我们再来看哈希表和字典的具体实现细节进行。</p>
<h2 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h2><p>从上述的介绍中，我们可以知道 Redis 利用 dictType 定义的类型特定函数来实现多态，在这些类型函数中，hashFunction 负责将 key 进行转换，得到对应的哈希值。根据不同的字典，使用的哈希算法也不相同。得到哈希值以后，再通过与哈希表的掩码值进行与操作，就获得 key 对应的索引值，具体可以看 dictRehash 函数中计算索引值的操作：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> dictHashKey(d, key) (d)-&gt;type-&gt;hashFunction(key)</span></div><div class="line">h = dictHashKey(d, de-&gt;key) &amp; d-&gt;ht[<span class="number">1</span>].sizemask;</div></pre></td></tr></table></figure>
<p>Redis 提供了几种种哈希函数:</p>
<ol>
<li>Thomas Wang 发明的 32 bits / 64 bits 的整数哈希函数<br>在之前的版本中，使用这个哈希函数来对整数进行哈希操作，这个哈希函数通过加法和位移操作进行哈希值的计算，避免了乘法操作带来的性能损失，同时使结果具有均匀的分布，以及雪崩效应。在之前的版本中单独编写函数，对于整数进行哈希，而在最新的版本中，只作为 figureprint 生成的函数。对于这个哈希函数的细节，可以参考我之前翻译的 Thomas Wang 写的整数哈希函数。</li>
<li>Austin Appleby 发明的 MurmurHash2 算法<br>murmur 是 multiply and rotate 的意思，因为算法的核心就是不断的乘和移位。MurmurHash 算法具有高运算性能，低碰撞率的特点，由 Austin Appleby 创建于2008年，最新的版本是 MurmurHash3，现已应用到Hadoop、libstdc++、nginx、libmemcached等开源系统。<br>通过 murmur 函数获得的哈希值分布均匀，比如：murmur计算”abc”是1118836419，”abd”是413429783。而使用 Horner 算法，”abc”是96354， “abd”就比它多1（96355）。</li>
<li>DJB 算法的修改版<br>DJB 算法同样是用于字符串类型的哈希函数，原理也非常简单，就是不断乘以 33 再加上对应的字符。该算法的执行效率和随机性都不错。在 Redis 中对该算法进行了简单的修改，使得它对大小写不敏感。</li>
</ol>
<p>对于 MurmurHash2 和 DJB 两种字符串哈希函数的比较：</p>
<ol>
<li>有人做过一个<a href="http://blog.csdn.net/wwwsq/article/details/4254123" target="_blank" rel="external">性能对比的实验</a>，得出结论：从计算速度上来看，MurmurHash只适用于已知长度的、长度比较长的字符串。长度未知或者长度不超过10字节，都应该使用DJB。而在前面介绍 SDS 的时候，我们知道 Redis 的字符串的 strlen 操作的时间复杂度是 O(1)，因此在长度大于 10 字节时，使用 MurmurHash2 可以获得一个随机性更好的哈希值，性能也更优；</li>
<li>另外，在代码的实现中，也将 DJB 和 MurmurHash2 算法进行了区别，DJB 的实现对字母的大小写不敏感，而 MurmurHash2 则是敏感的。</li>
</ol>
<h2 id="Rehash"><a href="#Rehash" class="headerlink" title="Rehash"></a>Rehash</h2><p>随着各类操作的不断执行，字典中的键值对的数量会不断地变化。当键值对的数量增加到一定数量以后，会使得碰撞冲突变得剧烈，影响哈希表的性能；而当键值对减少到一定程度以后，则会空闲大量的存储空间。因此，为了让哈希表的负载因子（键值对数量 / 哈希表大小）维持在一个合理的范围内，我们需要对哈希表进行适当的收缩和扩张。这个操作的基本步骤为：</p>
<ol>
<li>根据不同的操作（不同的大小）创建一个新的哈希表 ht[1]</li>
<li>渐进式地进行哈希表节点的迁移</li>
<li>完成迁移以后，将 ht[0] 的空间释放掉，将 ht[1] 替换 ht[0]</li>
</ol>
<h3 id="进行-Rehash-操作的条件"><a href="#进行-Rehash-操作的条件" class="headerlink" title="进行 Rehash 操作的条件"></a>进行 Rehash 操作的条件</h3><p>Redis 基于哈希表的性能和整体服务的性能考虑，将进行 Rehash 的情况分为两种：</p>
<ol>
<li>正常使用 Redis 时，当负载因子超过 1 时，就考虑进行 Rehash 操作；</li>
<li>Redis 利用后台线程进行持久化，这个时候为了最大程度利用 Copy On Write 机制带来的性能提升，会暂时停止 Rehash 操作，除非负载因子超过 dict_force_resize_ratio 的值</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> _dictExpandIfNeeded(dict *d)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (dictIsRehashing(d)) <span class="keyword">return</span> DICT_OK;</div><div class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].size == <span class="number">0</span>) <span class="keyword">return</span> dictExpand(d, DICT_HT_INITIAL_SIZE);</div><div class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].used &gt;= d-&gt;ht[<span class="number">0</span>].size &amp;&amp;</div><div class="line">        (dict_can_resize ||</div><div class="line">         d-&gt;ht[<span class="number">0</span>].used/d-&gt;ht[<span class="number">0</span>].size &gt; dict_force_resize_ratio))</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> dictExpand(d, d-&gt;ht[<span class="number">0</span>].used*<span class="number">2</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> DICT_OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="创建新的哈希表"><a href="#创建新的哈希表" class="headerlink" title="创建新的哈希表"></a>创建新的哈希表</h3><p>扩张哈希表的操作是在 _dictExpandIfNeeded 函数里进行判断和扩张的，而收缩哈希表的操作则是通过调用 dictResize 函数进行。而这两个函数同时调用了 dictExpand 函数。具体如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictExpand</span><span class="params">(dict *d, <span class="keyword">unsigned</span> <span class="keyword">long</span> size)</span></span></div><div class="line">&#123;</div><div class="line">    dictht n; <span class="comment">// 新哈希表</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> realsize = _dictNextPower(size);  <span class="comment">// 根据 size 参数，计算哈希表的大小</span></div><div class="line">    <span class="comment">// 不能在字典正在 rehash 时进行</span></div><div class="line">    <span class="comment">// size 的值也不能小于 0 号哈希表的当前已使用节点</span></div><div class="line">    <span class="keyword">if</span> (dictIsRehashing(d) || d-&gt;ht[<span class="number">0</span>].used &gt; size)</div><div class="line">        <span class="keyword">return</span> DICT_ERR;</div><div class="line">    <span class="comment">// 为哈希表分配空间，并将所有指针指向 NULL</span></div><div class="line">    n.size = realsize;</div><div class="line">    n.sizemask = realsize<span class="number">-1</span>;</div><div class="line">    n.table = zcalloc(realsize*<span class="keyword">sizeof</span>(dictEntry*));</div><div class="line">    n.used = <span class="number">0</span>;</div><div class="line">    <span class="comment">// 如果此时 ht[0] 如果为空，则表示当前的操作是初始化哈希表</span></div><div class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].table == <span class="literal">NULL</span>) &#123;</div><div class="line">        d-&gt;ht[<span class="number">0</span>] = n;</div><div class="line">        <span class="keyword">return</span> DICT_OK;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 设置新的哈希表大小，开始进行迁移</span></div><div class="line">    d-&gt;ht[<span class="number">1</span>] = n;</div><div class="line">    d-&gt;rehashidx = <span class="number">0</span>;</div><div class="line">    <span class="keyword">return</span> DICT_OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这个函数中，根据传入 size 的大小，查找到第一个大于等于 size 的 2 的次幂，作为新的哈希表的大小。在 dictResize 函数中，传入的是 ht[0].used，而在 _dictExpandIfNeeded 中传入的是 ht[0].used * 2。</p>
<h3 id="渐进式迁移"><a href="#渐进式迁移" class="headerlink" title="渐进式迁移"></a>渐进式迁移</h3><p>如果保存的哈希表节点特别多，将整个迁移过程一次性完成的话，将很长时间无法进行正常的插入操作，所以 Redis 使用渐进式的方式来完成哈希节点的迁移。具体的过程在 dictRehash 中实现，这个函数完成 n 个哈希表节点的迁移，并同时检测 rehash 操作是否已经完成：当整个 ht[0] 中的节点都迁移到 ht[1] 以后，释放 ht[0] 的空间，将 ht[1] 换入 ht[0]，同时重置所有的 rehash 相关的参数，就完成 rehash 的过程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictRehash</span><span class="params">(dict *d, <span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">    <span class="comment">// 只可以在 rehash 进行中时执行</span></div><div class="line">    <span class="keyword">if</span> (!dictIsRehashing(d)) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    <span class="comment">// 进行 N 步迁移</span></div><div class="line">    <span class="keyword">while</span>(n--) &#123;</div><div class="line">        dictEntry *de, *nextde;</div><div class="line">        <span class="comment">// 如果 0 号哈希表为空，那么表示 rehash 执行完毕</span></div><div class="line">        <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].used == <span class="number">0</span>) &#123;</div><div class="line">            zfree(d-&gt;ht[<span class="number">0</span>].table);</div><div class="line">            d-&gt;ht[<span class="number">0</span>] = d-&gt;ht[<span class="number">1</span>];</div><div class="line">            _dictReset(&amp;d-&gt;ht[<span class="number">1</span>]);</div><div class="line">            d-&gt;rehashidx = <span class="number">-1</span>;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 确保 rehashidx 没有越界</span></div><div class="line">        assert(d-&gt;ht[<span class="number">0</span>].size &gt; (<span class="keyword">unsigned</span>)d-&gt;rehashidx);</div><div class="line">        <span class="comment">// 略过数组中为空的索引，找到下一个非空索引</span></div><div class="line">        <span class="keyword">while</span>(d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx] == <span class="literal">NULL</span>) d-&gt;rehashidx++;</div><div class="line">        <span class="comment">// 指向该索引的链表表头节点</span></div><div class="line">        de = d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx];</div><div class="line">        <span class="comment">// 将链表中的所有节点迁移到新哈希表</span></div><div class="line">        <span class="keyword">while</span>(de) &#123;</div><div class="line">            <span class="keyword">unsigned</span> <span class="keyword">int</span> h;</div><div class="line">            <span class="comment">// 保存下个节点的指针</span></div><div class="line">            nextde = de-&gt;next;</div><div class="line">            <span class="comment">// 计算新哈希表的哈希值，以及节点插入的索引位置</span></div><div class="line">            h = dictHashKey(d, de-&gt;key) &amp; d-&gt;ht[<span class="number">1</span>].sizemask;</div><div class="line">            <span class="comment">// 插入节点到新哈希表</span></div><div class="line">            de-&gt;next = d-&gt;ht[<span class="number">1</span>].table[h];</div><div class="line">            d-&gt;ht[<span class="number">1</span>].table[h] = de;</div><div class="line">            <span class="comment">// 更新计数器</span></div><div class="line">            d-&gt;ht[<span class="number">0</span>].used--;</div><div class="line">            d-&gt;ht[<span class="number">1</span>].used++;</div><div class="line"></div><div class="line">            de = nextde;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 将刚迁移完的哈希表索引的指针设为空</span></div><div class="line">        d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx] = <span class="literal">NULL</span>;</div><div class="line">        <span class="comment">// 更新 rehash 索引</span></div><div class="line">        d-&gt;rehashidx++;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>那么什么时候执行 Rehash 的操作呢？Redis 定义了两个进行渐进式操作的时机：</p>
<ul>
<li>在哈希表被使用的同时，例如对哈希表进行查询或修改，执行 n = 1 的 dictRehash 操作，即调用 _dictRehashStep</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> _dictRehashStep(dict *d) &#123;</div><div class="line">    <span class="keyword">if</span> (d-&gt;iterators == <span class="number">0</span>) dictRehash(d,<span class="number">1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>如果哈希表长时间没有被使用，同样也需要将 rehash 操作进行下去，dictRehashMilliseconds 函数在指定时间内（10ms）以 100 次为单位进行 dictRehash 操作</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictRehashMilliseconds</span><span class="params">(dict *d, <span class="keyword">int</span> ms)</span> </span>&#123;</div><div class="line">    <span class="comment">// 记录开始时间</span></div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> start = timeInMilliseconds();</div><div class="line">    <span class="keyword">int</span> rehashes = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span>(dictRehash(d,<span class="number">100</span>)) &#123;</div><div class="line">        rehashes += <span class="number">100</span>;</div><div class="line">        <span class="comment">// 如果时间已过，跳出</span></div><div class="line">        <span class="keyword">if</span> (timeInMilliseconds()-start &gt; ms) <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> rehashes;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Rehash-执行期间的哈希表使用"><a href="#Rehash-执行期间的哈希表使用" class="headerlink" title="Rehash 执行期间的哈希表使用"></a>Rehash 执行期间的哈希表使用</h3><p>在字典进行 Rehash 的过程中，两个哈希表 ht[0] 和 ht[1] 同时存在并且被使用。因此，所有的查找、更新和删除都需要在两个哈希表上同时进行（先在 ht[0] 上进行操作，如果没有对应的目标，则在 ht[1] 上继续进行）。而增加操作只在 ht[1] 上进行，随着渐进式的迁移操作，ht[0] 表中的节点会越来越少，直到所有的节点都进入 ht[1]，rehash就完成了。</p>
<h2 id="哈希表的迭代器"><a href="#哈希表的迭代器" class="headerlink" title="哈希表的迭代器"></a>哈希表的迭代器</h2><p>迭代器的结构定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictIterator</span> &#123;</span></div><div class="line"></div><div class="line">    <span class="comment">// 被迭代的字典</span></div><div class="line">    dict *d;</div><div class="line">    <span class="comment">// table ：正在被迭代的哈希表号码，值可以是 0 或 1 。</span></div><div class="line">    <span class="comment">// index ：迭代器当前所指向的哈希表索引位置。</span></div><div class="line">    <span class="comment">// safe ：标识这个迭代器是否安全</span></div><div class="line">    <span class="keyword">int</span> table, index, safe;</div><div class="line">    <span class="comment">// entry ：当前迭代到的节点的指针</span></div><div class="line">    <span class="comment">// nextEntry ：当前迭代节点的下一个节点</span></div><div class="line">    <span class="comment">//             因为在安全迭代器运作时， entry 所指向的节点可能会被修改，</span></div><div class="line">    <span class="comment">//             所以需要一个额外的指针来保存下一节点的位置，</span></div><div class="line">    <span class="comment">//             从而防止指针丢失</span></div><div class="line">    dictEntry *entry, *nextEntry;</div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> fingerprint;</div><div class="line">&#125; dictIterator;</div></pre></td></tr></table></figure>
<p>Redis 的哈希表的迭代器按照是否 Rehash 安全分为两种，由 safe 字段进行标注。当 Rehash 安全的迭代器存在的时候，将不会进行单步的 Rehash，即在 _dictRehashStep 函数中先判断字典是否存在使用中的安全迭代器，不存在时才会进行 dictRehash。但是对于定时执行的情况，我没有找到在代码中保证在有安全迭代器时不进行 dictRehash 的判断，或许需要阅读更多的代码才能进行判断。<br>此外，由于迭代器返回以后可能会将迭代器当前指针对应的节点删除，所以还需要保存后续节点指针。而fingerprint 是使用 Thomas Wang 64bits 哈希算法在创建不安全迭代器时生成的指纹，用于在迭代器释放的时候判断在该迭代器在执行的过程中哈希表是否发生了变化。<br>为什么需要设置这两类迭代器呢？主要针对进行迭代的哈希表是否是可变的。由于在安全迭代器运行的期间不能执行 Rehash 操作，因此会影响性能，在对不可变的哈希表进行迭代操作时（例如 Redis 利用子线程进行 dump 操作），就可以使用不安全的迭代器。</p>
<h2 id="Scan-操作"><a href="#Scan-操作" class="headerlink" title="Scan 操作"></a>Scan 操作</h2><p>由于整体的数据设计，Redis 没有办法提供特别准确的 Scan 操作，它的特点是：</p>
<ul>
<li>提供键空间的遍历操作，支持游标，遍历一遍值需要 O(N) 的时间复杂度</li>
<li>无法提供完整的快照遍历，也就是中间如果有数据修改，可能有些涉及改动的数据遍历不到</li>
<li>每次返回的数据条数不一定，极度依赖内部实现</li>
<li>返回的数据可能有重复，应用层必须能够处理重入逻辑</li>
</ul>
<p>整个 Scan 操作的算法比较让人费解，我找到了一个写得比较好的博客，直接在这里转载一下，有兴趣的可以直接看，这里就不做过多的解释了：<a href="http://chenzhenianqing.cn/articles/1101.html" target="_blank" rel="external">http://chenzhenianqing.cn/articles/1101.html</a></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://redisbook.readthedocs.io/en/latest/internal-datastruct/dict.html" target="_blank" rel="external">Redis 设计与实现 - 字典</a></li>
<li><a href="http://www.tuicool.com/articles/3eeIJrR" target="_blank" rel="external">Redis的字典(dict)rehash过程源码解析</a></li>
<li><a href="http://chenzhenianqing.cn/articles/1090.html" target="_blank" rel="external">Redis Scan迭代器遍历操作原理（一）– 基础</a></li>
<li><a href="http://chenzhenianqing.cn/articles/1101.html" target="_blank" rel="external">Redis Scan迭代器遍历操作原理（二）– dictScan反向二进制迭代器</a></li>
<li><a href="http://stackoverflow.com/questions/9223397/whats-the-difference-of-safe-non-safe-dict-itereator-in-redis-dict-implementat" target="_blank" rel="external">what’s the difference of safe/non-safe dict itereator in redis’ dict implementation?</a></li>
<li><a href="http://github.thinkingbar.com/redisbook_chapter01/" target="_blank" rel="external">Redis设计与实现（一）内部数据结构</a></li>
</ul>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Redis/" rel="tag"># Redis</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/10/16/integer_hash_function/" rel="next" title="整数哈希函数">
                <i class="fa fa-chevron-left"></i> 整数哈希函数
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/10/28/redis_intset/" rel="prev" title="Redis数据结构: 整数集合">
                Redis数据结构: 整数集合 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="fb-comments"
           data-href="http://yoursite.com/2016/10/21/redis_dict/"
           data-numposts="10"
           data-width="100%"
           data-colorscheme="light">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="柿子" />
          <p class="site-author-name" itemprop="name">柿子</p>
           
              <p class="site-description motion-element" itemprop="description">一个非主流程序员</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">19</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">7</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#哈希算法"><span class="nav-number">1.</span> <span class="nav-text">哈希算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Rehash"><span class="nav-number">2.</span> <span class="nav-text">Rehash</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#进行-Rehash-操作的条件"><span class="nav-number">2.1.</span> <span class="nav-text">进行 Rehash 操作的条件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#创建新的哈希表"><span class="nav-number">2.2.</span> <span class="nav-text">创建新的哈希表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#渐进式迁移"><span class="nav-number">2.3.</span> <span class="nav-text">渐进式迁移</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Rehash-执行期间的哈希表使用"><span class="nav-number">2.4.</span> <span class="nav-text">Rehash 执行期间的哈希表使用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#哈希表的迭代器"><span class="nav-number">3.</span> <span class="nav-text">哈希表的迭代器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Scan-操作"><span class="nav-number">4.</span> <span class="nav-text">Scan 操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考资料"><span class="nav-number">5.</span> <span class="nav-text">参考资料</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">柿子</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.1"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("m5cJ6uWE1c1GaX65w4A1DubN-gzGzoHsz", "kI8J0OH8eDBG6WdG10XRj37j");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  

  

  

</body>
</html>
