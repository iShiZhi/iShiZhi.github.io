<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Redis," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="在前面对于压缩列表的介绍中，我们可以知道压缩列表的一些缺点，如查找操作需要 O(N) 的时间复杂度（即使有对应节点的索引值），数据变动的时候可能会引发连锁的更新，这些缺点决定了压缩列表无法用于大规模的数据。而快速列表的设计，则一定程度上克服了这些缺点，在空间利用率和时间复杂度上取得一个平衡。 快速列表的本质是一个双端链表，它的每一个节点都是压缩列表。这样的设计好处是：  可以通过限制压缩列表的节点">
<meta name="keywords" content="Redis">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis数据结构: 快速列表">
<meta property="og:url" content="http://yoursite.com/2016/11/22/redis_quick_list/index.html">
<meta property="og:site_name" content="柿子的果盘">
<meta property="og:description" content="在前面对于压缩列表的介绍中，我们可以知道压缩列表的一些缺点，如查找操作需要 O(N) 的时间复杂度（即使有对应节点的索引值），数据变动的时候可能会引发连锁的更新，这些缺点决定了压缩列表无法用于大规模的数据。而快速列表的设计，则一定程度上克服了这些缺点，在空间利用率和时间复杂度上取得一个平衡。 快速列表的本质是一个双端链表，它的每一个节点都是压缩列表。这样的设计好处是：  可以通过限制压缩列表的节点">
<meta property="og:updated_time" content="2017-06-23T08:29:42.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Redis数据结构: 快速列表">
<meta name="twitter:description" content="在前面对于压缩列表的介绍中，我们可以知道压缩列表的一些缺点，如查找操作需要 O(N) 的时间复杂度（即使有对应节点的索引值），数据变动的时候可能会引发连锁的更新，这些缺点决定了压缩列表无法用于大规模的数据。而快速列表的设计，则一定程度上克服了这些缺点，在空间利用率和时间复杂度上取得一个平衡。 快速列表的本质是一个双端链表，它的每一个节点都是压缩列表。这样的设计好处是：  可以通过限制压缩列表的节点">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2016/11/22/redis_quick_list/"/>





  <title>Redis数据结构: 快速列表 | 柿子的果盘</title>
  
<script>
  window.fbAsyncInit = function() {
    FB.init({
      appId      : '328629287562794',
      xfbml      : true,
      version    : 'v2.6'
    });
  };

  (function(d, s, id){
     var js, fjs = d.getElementsByTagName(s)[0];
     if (d.getElementById(id)) {return;}
     js = d.createElement(s); js.id = id;
     js.src = "//connect.facebook.net/zh_Hans/sdk.js";
     fjs.parentNode.insertBefore(js, fjs);
   }(document, 'script', 'facebook-jssdk'));
</script>






  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?30798a6e72702e12c529efb9326dc7e1";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>










</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">柿子的果盘</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">随手记录一些所读、所思、所感</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/11/22/redis_quick_list/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="柿子">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柿子的果盘">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Redis数据结构: 快速列表</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-11-22T00:00:00+08:00">
                2016-11-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/开源项目/" itemprop="url" rel="index">
                    <span itemprop="name">开源项目</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2016/11/22/redis_quick_list/#comments" itemprop="discussionUrl">
                  评论数 <span class="post-comments-count fb-comments-count" data-href="http://yoursite.com/2016/11/22/redis_quick_list/" itemprop="commentCount">0</span>
                </a>
              </span>
            
          

          
          
             <span id="/2016/11/22/redis_quick_list/" class="leancloud_visitors" data-flag-title="Redis数据结构: 快速列表">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>在前面对于压缩列表的介绍中，我们可以知道压缩列表的一些缺点，如查找操作需要 O(N) 的时间复杂度（即使有对应节点的索引值），数据变动的时候可能会引发连锁的更新，这些缺点决定了压缩列表无法用于大规模的数据。而快速列表的设计，则一定程度上克服了这些缺点，在空间利用率和时间复杂度上取得一个平衡。</p>
<p>快速列表的本质是一个双端链表，它的每一个节点都是压缩列表。这样的设计好处是：</p>
<ul>
<li>可以通过限制压缩列表的节点数和长度，使得双端链表的每个节点对应的压缩列表不会太大，避免更新数据产生 realloc 时需要大量的数据拷贝；</li>
<li>使用压缩列表作为节点，可以使得连续的节点的存储在同一段内存空间中，减少内存碎片，同时提高存储效率；</li>
<li>由于压缩列表中记录了节点数，所以在使用索引进行查找时，可以比单纯使用双端链表或压缩列表更快。</li>
</ul>
<p>此外，由于 Redis 频繁地在快速列表的两端进行操作，而中间的节点比较少被使用到，因此，使用 LZF 压缩算法对中间的压缩列表进行压缩能够进一步地节省空间。</p>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>quicklist.h 中定义了快速列表的节点结构，包含了：</p>
<ul>
<li>prev、next：前驱节点和后继节点的指针</li>
<li>zl：指向压缩列表的指针</li>
<li>sz：压缩列表中的字节数，包括了 zlbytes、zltail、zllen、zlend 和各个数据项，此外，即使压缩列表被压缩了，这边表示的依旧是压缩前的字节数<br>各类标记，这里使用了一个 C 语言的语法，unsigned int count : 16 表示使用 16 个 bit 来存储 count 变量，因此使用了 32 bit（即 2 个字节）来存储这些标记，包括：<ul>
<li>count（16 bits）：压缩列表包含的数据项</li>
<li>encoding（2 bits）：表示是否压缩过，未压缩则是 1，压缩过的则是 2</li>
<li>container（2 bits）：预留字段，当前是固定值 2</li>
<li>recompress（1 bit）：置为 1 的时候表示需要将压缩列表重新压缩，由于在遍历的时候，需要把压缩的节点解压后使用，所以解压后设置标志位，以便后面再进行压缩</li>
<li>attempted_compress（1 bit）：测试时用的字段，表示不需要进行压缩</li>
<li>extra（10 bits）：还未用上的预留空间</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> &#123;</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> *<span class="title">prev</span>;</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> *<span class="title">next</span>;</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *zl;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> sz;             <span class="comment">/* ziplist size in bytes */</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> count : <span class="number">16</span>;     <span class="comment">/* count of items in ziplist */</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> encoding : <span class="number">2</span>;   <span class="comment">/* RAW==1 or LZF==2 */</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> container : <span class="number">2</span>;  <span class="comment">/* NONE==1 or ZIPLIST==2 */</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> recompress : <span class="number">1</span>; <span class="comment">/* was this node previous compressed? */</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> attempted_compress : <span class="number">1</span>; <span class="comment">/* node can't compress; too small */</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> extra : <span class="number">10</span>; <span class="comment">/* more bits to steal for future usage */</span></div><div class="line">&#125; quicklistNode;</div></pre></td></tr></table></figure>
<p>quicklistLZF 表示了一个被压缩的节点结构，其中：</p>
<ul>
<li>sz：表示压缩以后压缩列表的字节数</li>
<li>compressed：存放压缩后的压缩列表的字节数组，与 SDS 的 buf 一样，这是一个柔性数组。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklistLZF</span> &#123;</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> sz; <span class="comment">/* LZF size in bytes*/</span></div><div class="line">    <span class="keyword">char</span> compressed[];</div><div class="line">&#125; quicklistLZF;</div></pre></td></tr></table></figure>
<p>快速列表的结构则包括：</p>
<ul>
<li>head、tail：列表表头和表尾指针</li>
<li>count：所有的压缩列表的节点数总和</li>
<li>len：快速列表的节点数</li>
<li>32 位的标记：<ul>
<li>fill（16 bits）：ziplist 大小设置，存放 list-max-ziplist-size 参数的值<br>若为负数，则表示ziplist的最大字节数，取值为 -1（4 Kb），-2（8 Kb），-3（16 Kb），-4（32 Kb），-5（64 Kb）<br>若为正数，则表示ziplist的最大节点数，最大为 8192（2^13）</li>
<li>compress（16 bits）：节点压缩深度设置，存放 list-compress-depth 参数的值，表示前后各有几个节点不压缩，0 是个特殊值，表示所有节点都不压缩，这是 Redis 的默认值</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklist</span> &#123;</span></div><div class="line">    quicklistNode *head;</div><div class="line">    quicklistNode *tail;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> count;        <span class="comment">/* total count of all entries in all ziplists */</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> len;           <span class="comment">/* number of quicklistNodes */</span></div><div class="line">    <span class="keyword">int</span> fill : <span class="number">16</span>;              <span class="comment">/* fill factor for individual nodes */</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> compress : <span class="number">16</span>; <span class="comment">/* depth of end nodes not to compress;0=off */</span></div><div class="line">&#125; quicklist;</div></pre></td></tr></table></figure>
<p>快速列表中 fill 属性的设置是为了使存储效率和时间复杂度达到一个平衡：</p>
<ul>
<li>如果压缩列表的节点数太多，则会导致分配连续内存空间的难度加大，同时更新节点数据操作造成大量数据拷贝的风险加大；</li>
<li>如果压缩列表的节点数太少，则会使快速列表退化成双端链表，存储效率低，内存空间随便多。</li>
</ul>
<p>根据使用的场景不同，可以对应地设置限定压缩列表的字节数（每个节点需要的存储空间较大时）或节点数（每个节点需要的存储空间较小时），同时这个参数的设置，也影响了 quicklistNode 结构中的 count 的位数：</p>
<ul>
<li>若这个参数取正值时，压缩列表的最大个数被限定在 2^15（实际上限制为 8192，即 2^13），可以使用 16 bits 进行存储；</li>
<li>若这个参数取负值时，压缩列表的最大字节数是 64 K，由于每一个节点至少占用 2 个字节，因此最大的数量为 32 K，也可以使用 16 bits 进行存储。</li>
</ul>
<p>而 compress 属性的设置主要是由于快速列表的使用场景是针对列表两端的节点进行频繁操作，而对于列表中间的节点进行操作的频率很低，这样压缩中间的节点，可以节省空间，而两端的节点不压缩则方便操作。</p>
<h3 id="压缩列表大小的判定"><a href="#压缩列表大小的判定" class="headerlink" title="压缩列表大小的判定"></a>压缩列表大小的判定</h3><p>由于快速列表设计的关键是压缩列表的大小限定，通过列表结构中的 fill 属性进行约束，因此在进行压缩列表新节点的插入，或者两个压缩列表的合并时，需要判定是否满足 fill 定义的限制条件，具体代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line">REDIS_STATIC <span class="keyword">int</span> _quicklistNodeAllowInsert(<span class="keyword">const</span> quicklistNode *node,</div><div class="line">                                           <span class="keyword">const</span> <span class="keyword">int</span> fill, <span class="keyword">const</span> <span class="keyword">size_t</span> sz) &#123;</div><div class="line">    <span class="keyword">if</span> (unlikely(!node))</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> ziplist_overhead;</div><div class="line">    <span class="comment">/* size of previous offset</span></div><div class="line">     *</div><div class="line">     * 判断 header 占用的字节数</div><div class="line">     */</div><div class="line">    <span class="keyword">if</span> (sz &lt; <span class="number">254</span>)</div><div class="line">        ziplist_overhead = <span class="number">1</span>;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        ziplist_overhead = <span class="number">5</span>;</div><div class="line">    <span class="comment">/* size of forward offset</span></div><div class="line">     *</div><div class="line">     * 判断 encoding 占用的字节数</div><div class="line">     */</div><div class="line">    <span class="keyword">if</span> (sz &lt; <span class="number">64</span>)</div><div class="line">        ziplist_overhead += <span class="number">1</span>;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (likely(sz &lt; <span class="number">16384</span>))</div><div class="line">        ziplist_overhead += <span class="number">2</span>;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        ziplist_overhead += <span class="number">5</span>;</div><div class="line">    <span class="comment">/* new_sz overestimates if 'sz' encodes to an integer type</span></div><div class="line">     *</div><div class="line">     * 当新节点存入的是整型数时，这边会过高估计使用的字节数</div><div class="line">     */</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> new_sz = node-&gt;sz + sz + ziplist_overhead;</div><div class="line">    <span class="comment">// 首先判断字节数是否满足要求，若 fill &gt; 0，则表示对字节数没有限制，只对数量进行限制</span></div><div class="line">    <span class="keyword">if</span> (likely(_quicklistNodeSizeMeetsOptimizationRequirement(new_sz, fill)))</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!sizeMeetsSafetyLimit(new_sz))</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    <span class="comment">// 若到这里进行判断，则要么是字节数不满足限制（这种情况下 fill 为负数，这边也肯定不满足要求）</span></div><div class="line">    <span class="comment">// 要么是字节数没有限制，而节点数有限制，此时 fill 为正数</span></div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="keyword">int</span>)node-&gt;count &lt; fill)</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line">REDIS_STATIC <span class="keyword">int</span> _quicklistNodeAllowMerge(<span class="keyword">const</span> quicklistNode *a,</div><div class="line">                                          <span class="keyword">const</span> quicklistNode *b,</div><div class="line">                                          <span class="keyword">const</span> <span class="keyword">int</span> fill) &#123;</div><div class="line">    <span class="keyword">if</span> (!a || !b)</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    <span class="comment">/* approximate merged ziplist size (- 11 to remove one ziplist</span></div><div class="line">     * header/trailer)</div><div class="line">     *</div><div class="line">     * 11 是 header 和 tail 的大小，合并以后只需要一个 header 和一个 tail</div><div class="line">     */</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> merge_sz = a-&gt;sz + b-&gt;sz - <span class="number">11</span>;</div><div class="line">    <span class="comment">// 首先判断字节数是否满足条件</span></div><div class="line">    <span class="keyword">if</span> (likely(_quicklistNodeSizeMeetsOptimizationRequirement(merge_sz, fill)))</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    <span class="comment">// 其次判断是否满足最大字节数的条件</span></div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!sizeMeetsSafetyLimit(merge_sz))</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    <span class="comment">// 判断节点数是否满足条件</span></div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="keyword">int</span>)(a-&gt;count + b-&gt;count) &lt;= fill)</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Push-和-Pop-操作"><a href="#Push-和-Pop-操作" class="headerlink" title="Push 和 Pop 操作"></a>Push 和 Pop 操作</h3><p>如前所述，快速列表的操作经常在两端进行，因此定义了 Push 和 Pop 两个操作。<br>在进行 Push 操作的时候，需要判断表头节点（或表尾节点）是否有足够的空间（满足 fill 属性）可以存储新的节点。若可以存储，则直接存入，否则需要新建一个快速列表节点（即压缩列表）进行存储。具体代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">quicklistPushHead</span><span class="params">(quicklist *quicklist, <span class="keyword">void</span> *value, <span class="keyword">size_t</span> sz)</span> </span>&#123;</div><div class="line">    quicklistNode *orig_head = quicklist-&gt;head;</div><div class="line">    <span class="keyword">if</span> (likely(</div><div class="line">            _quicklistNodeAllowInsert(quicklist-&gt;head, quicklist-&gt;fill, sz))) &#123;</div><div class="line">        quicklist-&gt;head-&gt;zl =</div><div class="line">            ziplistPush(quicklist-&gt;head-&gt;zl, value, sz, ZIPLIST_HEAD);</div><div class="line">        quicklistNodeUpdateSz(quicklist-&gt;head);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        quicklistNode *node = quicklistCreateNode();</div><div class="line">        node-&gt;zl = ziplistPush(ziplistNew(), value, sz, ZIPLIST_HEAD);</div><div class="line">        quicklistNodeUpdateSz(node);</div><div class="line">        _quicklistInsertNodeBefore(quicklist, quicklist-&gt;head, node);</div><div class="line">    &#125;</div><div class="line">    quicklist-&gt;count++;</div><div class="line">    quicklist-&gt;head-&gt;count++;</div><div class="line">    <span class="keyword">return</span> (orig_head != quicklist-&gt;head);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">quicklistPushTail</span><span class="params">(quicklist *quicklist, <span class="keyword">void</span> *value, <span class="keyword">size_t</span> sz)</span> </span>&#123;</div><div class="line">    quicklistNode *orig_tail = quicklist-&gt;tail;</div><div class="line">    <span class="keyword">if</span> (likely(</div><div class="line">            _quicklistNodeAllowInsert(quicklist-&gt;tail, quicklist-&gt;fill, sz))) &#123;</div><div class="line">        quicklist-&gt;tail-&gt;zl =</div><div class="line">            ziplistPush(quicklist-&gt;tail-&gt;zl, value, sz, ZIPLIST_TAIL);</div><div class="line">        quicklistNodeUpdateSz(quicklist-&gt;tail);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        quicklistNode *node = quicklistCreateNode();</div><div class="line">        node-&gt;zl = ziplistPush(ziplistNew(), value, sz, ZIPLIST_TAIL);</div><div class="line">        quicklistNodeUpdateSz(node);</div><div class="line">        _quicklistInsertNodeAfter(quicklist, quicklist-&gt;tail, node);</div><div class="line">    &#125;</div><div class="line">    quicklist-&gt;count++;</div><div class="line">    quicklist-&gt;tail-&gt;count++;</div><div class="line">    <span class="keyword">return</span> (orig_tail != quicklist-&gt;tail);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicklistPush</span><span class="params">(quicklist *quicklist, <span class="keyword">void</span> *value, <span class="keyword">const</span> <span class="keyword">size_t</span> sz,</span></span></div><div class="line">                   <span class="keyword">int</span> where) &#123;</div><div class="line">    <span class="keyword">if</span> (where == QUICKLIST_HEAD) &#123;</div><div class="line">        quicklistPushHead(quicklist, value, sz);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (where == QUICKLIST_TAIL) &#123;</div><div class="line">        quicklistPushTail(quicklist, value, sz);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在进行 Pop 操作的时候，需要根据传入的 saver 函数将取出的节点内容保存在对应的指针中：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line">int quicklistPopCustom(quicklist *quicklist, int where, unsigned char **data,</div><div class="line">                       unsigned int *sz, long long *sval,</div><div class="line">                       void *(*saver)(unsigned char *data, unsigned int sz)) &#123;</div><div class="line">    unsigned char *p;</div><div class="line">    unsigned char *vstr;</div><div class="line">    unsigned int vlen;</div><div class="line">    long long vlong;</div><div class="line">    int pos = (where == QUICKLIST_HEAD) ? 0 : -1;</div><div class="line">    if (quicklist-&gt;count == 0)</div><div class="line">        return 0;</div><div class="line">    if (data)</div><div class="line">        *data = NULL;</div><div class="line">    if (sz)</div><div class="line">        *sz = 0;</div><div class="line">    if (sval)</div><div class="line">        *sval = -123456789;</div><div class="line">    quicklistNode *node;</div><div class="line">    if (where == QUICKLIST_HEAD &amp;&amp; quicklist-&gt;head) &#123;</div><div class="line">        node = quicklist-&gt;head;</div><div class="line">    &#125; else if (where == QUICKLIST_TAIL &amp;&amp; quicklist-&gt;tail) &#123;</div><div class="line">        node = quicklist-&gt;tail;</div><div class="line">    &#125; else &#123;</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line">    // 取出对应的节点</div><div class="line">    p = ziplistIndex(node-&gt;zl, pos);</div><div class="line">    if (ziplistGet(p, &amp;vstr, &amp;vlen, &amp;vlong)) &#123;</div><div class="line">        if (vstr) &#123;</div><div class="line">            if (data)</div><div class="line">                *data = saver(vstr, vlen);</div><div class="line">            if (sz)</div><div class="line">                *sz = vlen;</div><div class="line">        &#125; else &#123;</div><div class="line">            if (data)</div><div class="line">                *data = NULL;</div><div class="line">            if (sval)</div><div class="line">                *sval = vlong;</div><div class="line">        &#125;</div><div class="line">        quicklistDelIndex(quicklist, node, &amp;p);</div><div class="line">        return 1;</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div><div class="line">REDIS_STATIC void *_quicklistSaver(unsigned char *data, unsigned int sz) &#123;</div><div class="line">    unsigned char *vstr;</div><div class="line">    if (data) &#123;</div><div class="line">        vstr = zmalloc(sz);</div><div class="line">        memcpy(vstr, data, sz);</div><div class="line">        return vstr;</div><div class="line">    &#125;</div><div class="line">    return NULL;</div><div class="line">&#125;</div><div class="line">int quicklistPop(quicklist *quicklist, int where, unsigned char **data,</div><div class="line">                 unsigned int *sz, long long *slong) &#123;</div><div class="line">    unsigned char *vstr;</div><div class="line">    unsigned int vlen;</div><div class="line">    long long vlong;</div><div class="line">    if (quicklist-&gt;count == 0)</div><div class="line">        return 0;</div><div class="line">    int ret = quicklistPopCustom(quicklist, where, &amp;vstr, &amp;vlen, &amp;vlong,</div><div class="line">                                 _quicklistSaver);</div><div class="line">    if (data)</div><div class="line">        *data = vstr;</div><div class="line">    if (slong)</div><div class="line">        *slong = vlong;</div><div class="line">    if (sz)</div><div class="line">        *sz = vlen;</div><div class="line">    return ret;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="任意位置的插入"><a href="#任意位置的插入" class="headerlink" title="任意位置的插入"></a>任意位置的插入</h3><p>除了从头部或尾部插入，快速列表还实现了从任意指定的位置插入，这时候由于需要满足 fill 设定的压缩列表大小，会将逻辑分为如下几种情况：</p>
<ul>
<li>若当前的压缩列表有空间可以存入新的节点，则直接存入；</li>
<li>若当前的压缩列表没有空间，且插入位置在表头或表尾，则考虑前一个或后一个压缩列表是否有空间存储：<ul>
<li>若有空间，则直接存入；</li>
<li>否则，新建一个快速列表的节点，将其插入对应的位置，用于存储新节点；</li>
</ul>
</li>
<li>若当前的压缩列表没有空间，且插入位置不在表头或表尾，则需要将当前的压缩列表拆分以后，插入合适的压缩列表。</li>
</ul>
<p>具体代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div></pre></td><td class="code"><pre><div class="line">REDIS_STATIC <span class="keyword">void</span> _quicklistInsert(quicklist *quicklist, quicklistEntry *entry,</div><div class="line">                                   <span class="keyword">void</span> *value, <span class="keyword">const</span> <span class="keyword">size_t</span> sz, <span class="keyword">int</span> after) &#123;</div><div class="line">    <span class="keyword">int</span> full = <span class="number">0</span>, at_tail = <span class="number">0</span>, at_head = <span class="number">0</span>, full_next = <span class="number">0</span>, full_prev = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> fill = quicklist-&gt;fill;</div><div class="line">    quicklistNode *node = entry-&gt;node;</div><div class="line">    quicklistNode *new_node = <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">if</span> (!node) &#123;</div><div class="line">        <span class="comment">/* we have no reference node, so let's create only node in the list</span></div><div class="line">         *</div><div class="line">         * 若没有指定快速列表的节点，则新建一个节点用于存储压缩列表节点</div><div class="line">         */</div><div class="line">        D(<span class="string">"No node given!"</span>);</div><div class="line">        new_node = quicklistCreateNode();</div><div class="line">        new_node-&gt;zl = ziplistPush(ziplistNew(), value, sz, ZIPLIST_HEAD);</div><div class="line">        __quicklistInsertNode(quicklist, <span class="literal">NULL</span>, new_node, after);</div><div class="line">        new_node-&gt;count++;</div><div class="line">        quicklist-&gt;count++;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/* Populate accounting flags for easier boolean checks later</span></div><div class="line">     *</div><div class="line">     * 判断压缩列表是否还能存入新节点，插入的位置在表头或者表尾</div><div class="line">     */</div><div class="line">    <span class="keyword">if</span> (!_quicklistNodeAllowInsert(node, fill, sz)) &#123;</div><div class="line">        D(<span class="string">"Current node is full with count %d with requested fill %lu"</span>,</div><div class="line">          node-&gt;count, fill);</div><div class="line">        full = <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (after &amp;&amp; (entry-&gt;offset == node-&gt;count)) &#123;</div><div class="line">        D(<span class="string">"At Tail of current ziplist"</span>);</div><div class="line">        at_tail = <span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span> (!_quicklistNodeAllowInsert(node-&gt;next, fill, sz)) &#123;</div><div class="line">            D(<span class="string">"Next node is full too."</span>);</div><div class="line">            full_next = <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (!after &amp;&amp; (entry-&gt;offset == <span class="number">0</span>)) &#123;</div><div class="line">        D(<span class="string">"At Head"</span>);</div><div class="line">        at_head = <span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span> (!_quicklistNodeAllowInsert(node-&gt;prev, fill, sz)) &#123;</div><div class="line">            D(<span class="string">"Prev node is full too."</span>);</div><div class="line">            full_prev = <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/* Now determine where and how to insert the new element</span></div><div class="line">     *</div><div class="line">     * 判断该如何插入节点</div><div class="line">     */</div><div class="line">    <span class="keyword">if</span> (!full &amp;&amp; after) &#123;</div><div class="line">        D(<span class="string">"Not full, inserting after current position."</span>);</div><div class="line">        quicklistDecompressNodeForUse(node);</div><div class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> *next = ziplistNext(node-&gt;zl, entry-&gt;zi);</div><div class="line">        <span class="comment">// 判断是否在压缩列表的表尾插入</span></div><div class="line">        <span class="keyword">if</span> (next == <span class="literal">NULL</span>) &#123;</div><div class="line">            node-&gt;zl = ziplistPush(node-&gt;zl, value, sz, ZIPLIST_TAIL);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            node-&gt;zl = ziplistInsert(node-&gt;zl, next, value, sz);</div><div class="line">        &#125;</div><div class="line">        node-&gt;count++;</div><div class="line">        quicklistNodeUpdateSz(node);</div><div class="line">        quicklistRecompressOnly(quicklist, node);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!full &amp;&amp; !after) &#123;</div><div class="line">        D(<span class="string">"Not full, inserting before current position."</span>);</div><div class="line">        quicklistDecompressNodeForUse(node);</div><div class="line">        node-&gt;zl = ziplistInsert(node-&gt;zl, entry-&gt;zi, value, sz);</div><div class="line">        node-&gt;count++;</div><div class="line">        quicklistNodeUpdateSz(node);</div><div class="line">        quicklistRecompressOnly(quicklist, node);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (full &amp;&amp; at_tail &amp;&amp; node-&gt;next &amp;&amp; !full_next &amp;&amp; after) &#123;</div><div class="line">        <span class="comment">/* If we are: at tail, next has free space, and inserting after:</span></div><div class="line">         *   - insert entry at head of next node.</div><div class="line">         *</div><div class="line">         * 如果当前压缩列表已满，而后一个节点未满，且插入在当前压缩列表的表尾，则插入到后一个节点表头</div><div class="line">         */</div><div class="line">        D(<span class="string">"Full and tail, but next isn't full; inserting next node head"</span>);</div><div class="line">        new_node = node-&gt;next;</div><div class="line">        quicklistDecompressNodeForUse(new_node);</div><div class="line">        new_node-&gt;zl = ziplistPush(new_node-&gt;zl, value, sz, ZIPLIST_HEAD);</div><div class="line">        new_node-&gt;count++;</div><div class="line">        quicklistNodeUpdateSz(new_node);</div><div class="line">        quicklistRecompressOnly(quicklist, new_node);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (full &amp;&amp; at_head &amp;&amp; node-&gt;prev &amp;&amp; !full_prev &amp;&amp; !after) &#123;</div><div class="line">        <span class="comment">/* If we are: at head, previous has free space, and inserting before:</span></div><div class="line">         *   - insert entry at tail of previous node.</div><div class="line">         *</div><div class="line">         * 如果当前压缩列表已满，而前一个节点未满，且插入在当前压缩列表的表头，则插入到前一个节点表尾</div><div class="line">         */</div><div class="line">        D(<span class="string">"Full and head, but prev isn't full, inserting prev node tail"</span>);</div><div class="line">        new_node = node-&gt;prev;</div><div class="line">        quicklistDecompressNodeForUse(new_node);</div><div class="line">        new_node-&gt;zl = ziplistPush(new_node-&gt;zl, value, sz, ZIPLIST_TAIL);</div><div class="line">        new_node-&gt;count++;</div><div class="line">        quicklistNodeUpdateSz(new_node);</div><div class="line">        quicklistRecompressOnly(quicklist, new_node);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (full &amp;&amp; ((at_tail &amp;&amp; node-&gt;next &amp;&amp; full_next &amp;&amp; after) ||</div><div class="line">                        (at_head &amp;&amp; node-&gt;prev &amp;&amp; full_prev &amp;&amp; !after))) &#123;</div><div class="line">        <span class="comment">/* If we are: full, and our prev/next is full, then:</span></div><div class="line">         *   - create new node and attach to quicklist</div><div class="line">         * 如果插入在压缩列表的表头或表尾，且前后节点也已满，则创建新快速列表节点</div><div class="line">         */</div><div class="line">        D(<span class="string">"\tprovisioning new node..."</span>);</div><div class="line">        new_node = quicklistCreateNode();</div><div class="line">        new_node-&gt;zl = ziplistPush(ziplistNew(), value, sz, ZIPLIST_HEAD);</div><div class="line">        new_node-&gt;count++;</div><div class="line">        quicklistNodeUpdateSz(new_node);</div><div class="line">        __quicklistInsertNode(quicklist, node, new_node, after);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (full) &#123;</div><div class="line">        <span class="comment">/* else, node is full we need to split it.</span></div><div class="line">         * covers both after and !after cases</div><div class="line">         *</div><div class="line">         * 如果不是在两端，则将当前的节点进行拆分后再进行插入</div><div class="line">         */</div><div class="line">        D(<span class="string">"\tsplitting node..."</span>);</div><div class="line">        quicklistDecompressNodeForUse(node);</div><div class="line">        new_node = _quicklistSplitNode(node, entry-&gt;offset, after);</div><div class="line">        new_node-&gt;zl = ziplistPush(new_node-&gt;zl, value, sz,</div><div class="line">                                   after ? ZIPLIST_HEAD : ZIPLIST_TAIL);</div><div class="line">        new_node-&gt;count++;</div><div class="line">        quicklistNodeUpdateSz(new_node);</div><div class="line">        __quicklistInsertNode(quicklist, node, new_node, after);</div><div class="line">        _quicklistMergeNodes(quicklist, node);</div><div class="line">    &#125;</div><div class="line">    quicklist-&gt;count++;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicklistInsertBefore</span><span class="params">(quicklist *quicklist, quicklistEntry *entry,</span></span></div><div class="line">                           <span class="keyword">void</span> *value, <span class="keyword">const</span> <span class="keyword">size_t</span> sz) &#123;</div><div class="line">    _quicklistInsert(quicklist, entry, value, sz, <span class="number">0</span>);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicklistInsertAfter</span><span class="params">(quicklist *quicklist, quicklistEntry *entry,</span></span></div><div class="line">                          <span class="keyword">void</span> *value, <span class="keyword">const</span> <span class="keyword">size_t</span> sz) &#123;</div><div class="line">    _quicklistInsert(quicklist, entry, value, sz, <span class="number">1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>快速列表定义了迭代器和压缩列表节点结构，并且可以从表头和表尾两个方向对所有的压缩列表中的节点进行遍历，具体的数据结构定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 快速列表的迭代器，用于遍历快速列表中所有压缩列表的所有节点，按照每个压缩列表节点进行遍历</span></div><div class="line"><span class="comment">// 可以选择遍历压缩列表的方向，从头遍历 AL_START_HEAD 或者从尾遍历 AL_START_TAIL</span></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklistIter</span> &#123;</span></div><div class="line">    <span class="keyword">const</span> quicklist *quicklist;    <span class="comment">// 遍历的快速列表指针</span></div><div class="line">    quicklistNode *current;        <span class="comment">// 遍历的快速列表节点指针</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *zi;             <span class="comment">// 遍历到的压缩列表节点的指针</span></div><div class="line">    <span class="keyword">long</span> offset;                   <span class="comment">// 遍历到的压缩列表节点的偏移量</span></div><div class="line">    <span class="keyword">int</span> direction;                 <span class="comment">// 遍历方向 AL_START_HEAD 或 AL_START_TAIL</span></div><div class="line">&#125; quicklistIter;</div><div class="line"><span class="comment">// 快速列表迭代过程中取出的压缩列表节点的结构</span></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklistEntry</span> &#123;</span></div><div class="line">    <span class="keyword">const</span> quicklist *quicklist;    <span class="comment">// 快速列表指针</span></div><div class="line">    quicklistNode *node;           <span class="comment">// 快速列表的节点指针</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *zi;             <span class="comment">// 压缩列表节点的指针</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *value;          <span class="comment">// 压缩列表节点的字符串指针（如果内容无法保存到 longval 的话）</span></div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> longval;             <span class="comment">// 压缩列表节点的数值</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> sz;               <span class="comment">// 压缩列表节点的字符串长度</span></div><div class="line">    <span class="keyword">int</span> offset;                    <span class="comment">// 压缩列表节点的索引值，如果从后向前遍历时，为负数</span></div><div class="line">&#125; quicklistEntry;</div></pre></td></tr></table></figure>
<p>以下是具体的遍历代码，在进行遍历的过程中，会逐一取出压缩列表的节点，若节点被压缩，则进行解压，同时标注 recompress 为 1，以待该节点被使用完以后重新压缩。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">quicklistNext</span><span class="params">(quicklistIter *iter, quicklistEntry *entry)</span> </span>&#123;</div><div class="line">    initEntry(entry);</div><div class="line">    <span class="keyword">if</span> (!iter) &#123;</div><div class="line">        D(<span class="string">"Returning because no iter!"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 从迭代器里获得当前压缩节点对应的快速列表信息</span></div><div class="line">    entry-&gt;quicklist = iter-&gt;quicklist;</div><div class="line">    entry-&gt;node = iter-&gt;current;</div><div class="line">    <span class="comment">// 如果当前的快速列表的节点为空，则返回</span></div><div class="line">    <span class="keyword">if</span> (!iter-&gt;current) &#123;</div><div class="line">        D(<span class="string">"Returning because current node is NULL"</span>)</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 定义一个函数指针，后面将根据遍历的方向决定具体的实现</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *(*nextFn)(<span class="keyword">unsigned</span> <span class="keyword">char</span> *, <span class="keyword">unsigned</span> <span class="keyword">char</span> *) = <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">int</span> offset_update = <span class="number">0</span>;</div><div class="line">    <span class="comment">// 如果已经有对应的指针，则说明在遍历一个压缩列表没有结束，这时候可以直接使用，否则需要解压一个快速列表的节点，然后查找对应的节点</span></div><div class="line">    <span class="keyword">if</span> (!iter-&gt;zi) &#123;</div><div class="line">        <span class="comment">/* If !zi, use current index.</span></div><div class="line">         *</div><div class="line">         * 上一个压缩列表已经遍历完了，现在要遍历一个新的快速列表节点对应的压缩列表</div><div class="line">         */</div><div class="line">        quicklistDecompressNodeForUse(iter-&gt;current);</div><div class="line">        iter-&gt;zi = ziplistIndex(iter-&gt;current-&gt;zl, iter-&gt;offset);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">/* else, use existing iterator offset and get prev/next as necessary.</span></div><div class="line">         *</div><div class="line">         * 获取下一个节点的指针和偏移量</div><div class="line">         */</div><div class="line">        <span class="keyword">if</span> (iter-&gt;direction == AL_START_HEAD) &#123;</div><div class="line">            nextFn = ziplistNext;</div><div class="line">            offset_update = <span class="number">1</span>;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (iter-&gt;direction == AL_START_TAIL) &#123;</div><div class="line">            nextFn = ziplistPrev;</div><div class="line">            offset_update = <span class="number">-1</span>;</div><div class="line">        &#125;</div><div class="line">        iter-&gt;zi = nextFn(iter-&gt;current-&gt;zl, iter-&gt;zi);</div><div class="line">        iter-&gt;offset += offset_update;</div><div class="line">    &#125;</div><div class="line">    entry-&gt;zi = iter-&gt;zi;</div><div class="line">    entry-&gt;offset = iter-&gt;offset;</div><div class="line">    <span class="keyword">if</span> (iter-&gt;zi) &#123;</div><div class="line">        <span class="comment">/* Populate value from existing ziplist position</span></div><div class="line">         *</div><div class="line">         * 如果当前的压缩列表没有遍历完成，则取出对应的节点的值</div><div class="line">         */</div><div class="line">        ziplistGet(entry-&gt;zi, &amp;entry-&gt;value, &amp;entry-&gt;sz, &amp;entry-&gt;longval);</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">/* We ran out of ziplist entries.</span></div><div class="line">         * Pick next node, update offset, then re-run retrieval.</div><div class="line">         *</div><div class="line">         * 将遍历完的节点压缩，然后按照遍历方向进行下一个快速列表节点对应的压缩列表的遍历</div><div class="line">         */</div><div class="line">        quicklistCompress(iter-&gt;quicklist, iter-&gt;current);</div><div class="line">        <span class="keyword">if</span> (iter-&gt;direction == AL_START_HEAD) &#123;</div><div class="line">            <span class="comment">/* Forward traversal */</span></div><div class="line">            D(<span class="string">"Jumping to start of next node"</span>);</div><div class="line">            iter-&gt;current = iter-&gt;current-&gt;next;</div><div class="line">            iter-&gt;offset = <span class="number">0</span>;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (iter-&gt;direction == AL_START_TAIL) &#123;</div><div class="line">            <span class="comment">/* Reverse traversal */</span></div><div class="line">            D(<span class="string">"Jumping to end of previous node"</span>);</div><div class="line">            iter-&gt;current = iter-&gt;current-&gt;prev;</div><div class="line">            iter-&gt;offset = <span class="number">-1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 获取新的压缩列表的第一个遍历节点（根据遍历方向，有可能是头节点，也可能是尾节点）</span></div><div class="line">        iter-&gt;zi = <span class="literal">NULL</span>;</div><div class="line">        <span class="keyword">return</span> quicklistNext(iter, entry);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>快速列表的主要操作都在上面进行了叙述，其它的操作可以查看相应的源代码注释。</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Redis/" rel="tag"># Redis</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/11/12/redis_skip_list/" rel="next" title="Redis数据结构: 跳跃表">
                <i class="fa fa-chevron-left"></i> Redis数据结构: 跳跃表
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/12/01/redis_object/" rel="prev" title="Redis数据结构: 对象">
                Redis数据结构: 对象 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="fb-comments"
           data-href="http://yoursite.com/2016/11/22/redis_quick_list/"
           data-numposts="10"
           data-width="100%"
           data-colorscheme="light">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="柿子" />
          <p class="site-author-name" itemprop="name">柿子</p>
           
              <p class="site-description motion-element" itemprop="description">一个非主流程序员</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">20</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">7</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#数据结构"><span class="nav-number">1.</span> <span class="nav-text">数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#压缩列表大小的判定"><span class="nav-number">2.</span> <span class="nav-text">压缩列表大小的判定</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Push-和-Pop-操作"><span class="nav-number">3.</span> <span class="nav-text">Push 和 Pop 操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#任意位置的插入"><span class="nav-number">4.</span> <span class="nav-text">任意位置的插入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#迭代器"><span class="nav-number">5.</span> <span class="nav-text">迭代器</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">柿子</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.1"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("m5cJ6uWE1c1GaX65w4A1DubN-gzGzoHsz", "kI8J0OH8eDBG6WdG10XRj37j");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  

  

  

</body>
</html>
